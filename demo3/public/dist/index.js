var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// dist/littlejs.esm.min.js
var exports_littlejs_esm_min = {};
__export(exports_littlejs_esm_min, {
  zzfx: () => {
    {
      return zzfx;
    }
  },
  worldToScreen: () => {
    {
      return worldToScreen;
    }
  },
  wave: () => {
    {
      return wave;
    }
  },
  vibrateStop: () => {
    {
      return vibrateStop;
    }
  },
  vibrateEnable: () => {
    {
      return vibrateEnable;
    }
  },
  vibrate: () => {
    {
      return vibrate;
    }
  },
  vec2: () => {
    {
      return vec2;
    }
  },
  touchGamepadSize: () => {
    {
      return touchGamepadSize;
    }
  },
  touchGamepadEnable: () => {
    {
      return touchGamepadEnable;
    }
  },
  touchGamepadAnalog: () => {
    {
      return touchGamepadAnalog;
    }
  },
  touchGamepadAlpha: () => {
    {
      return touchGamepadAlpha;
    }
  },
  toggleFullscreen: () => {
    {
      return toggleFullscreen;
    }
  },
  timeReal: () => {
    {
      return timeReal;
    }
  },
  timeDelta: () => {
    {
      return timeDelta;
    }
  },
  time: () => {
    {
      return time;
    }
  },
  tileSizeDefault: () => {
    {
      return tileSizeDefault;
    }
  },
  tileFixBleedScale: () => {
    {
      return tileFixBleedScale;
    }
  },
  tileCollisionTest: () => {
    {
      return tileCollisionTest;
    }
  },
  tileCollisionSize: () => {
    {
      return tileCollisionSize;
    }
  },
  tileCollisionRaycast: () => {
    {
      return tileCollisionRaycast;
    }
  },
  tileCollision: () => {
    {
      return tileCollision;
    }
  },
  tile: () => {
    {
      return tile;
    }
  },
  textureInfos: () => {
    {
      return textureInfos;
    }
  },
  speakStop: () => {
    {
      return speakStop;
    }
  },
  speak: () => {
    {
      return speak;
    }
  },
  soundVolume: () => {
    {
      return soundVolume;
    }
  },
  soundEnable: () => {
    {
      return soundEnable;
    }
  },
  soundDefaultTaper: () => {
    {
      return soundDefaultTaper;
    }
  },
  soundDefaultRange: () => {
    {
      return soundDefaultRange;
    }
  },
  smoothStep: () => {
    {
      return smoothStep;
    }
  },
  sign: () => {
    {
      return sign;
    }
  },
  showWatermark: () => {
    {
      return showWatermark;
    }
  },
  showSplashScreen: () => {
    {
      return showSplashScreen;
    }
  },
  setVibrateEnable: () => {
    {
      return setVibrateEnable;
    }
  },
  setTouchInputEnable: () => {
    {
      return setTouchInputEnable;
    }
  },
  setTouchGamepadSize: () => {
    {
      return setTouchGamepadSize;
    }
  },
  setTouchGamepadEnable: () => {
    {
      return setTouchGamepadEnable;
    }
  },
  setTouchGamepadAnalog: () => {
    {
      return setTouchGamepadAnalog;
    }
  },
  setTouchGamepadAlpha: () => {
    {
      return setTouchGamepadAlpha;
    }
  },
  setTileSizeDefault: () => {
    {
      return setTileSizeDefault;
    }
  },
  setTileFixBleedScale: () => {
    {
      return setTileFixBleedScale;
    }
  },
  setTileCollisionData: () => {
    {
      return setTileCollisionData;
    }
  },
  setSoundVolume: () => {
    {
      return setSoundVolume;
    }
  },
  setSoundEnable: () => {
    {
      return setSoundEnable;
    }
  },
  setSoundDefaultTaper: () => {
    {
      return setSoundDefaultTaper;
    }
  },
  setSoundDefaultRange: () => {
    {
      return setSoundDefaultRange;
    }
  },
  setShowWatermark: () => {
    {
      return setShowWatermark;
    }
  },
  setShowSplashScreen: () => {
    {
      return setShowSplashScreen;
    }
  },
  setPaused: () => {
    {
      return setPaused;
    }
  },
  setParticleEmitRateScale: () => {
    {
      return setParticleEmitRateScale;
    }
  },
  setObjectMaxSpeed: () => {
    {
      return setObjectMaxSpeed;
    }
  },
  setObjectDefaultMass: () => {
    {
      return setObjectDefaultMass;
    }
  },
  setObjectDefaultFriction: () => {
    {
      return setObjectDefaultFriction;
    }
  },
  setObjectDefaultElasticity: () => {
    {
      return setObjectDefaultElasticity;
    }
  },
  setObjectDefaultDamping: () => {
    {
      return setObjectDefaultDamping;
    }
  },
  setObjectDefaultAngleDamping: () => {
    {
      return setObjectDefaultAngleDamping;
    }
  },
  setMedalsPreventUnlock: () => {
    {
      return setMedalsPreventUnlock;
    }
  },
  setMedalDisplayTime: () => {
    {
      return setMedalDisplayTime;
    }
  },
  setMedalDisplaySlideTime: () => {
    {
      return setMedalDisplaySlideTime;
    }
  },
  setMedalDisplaySize: () => {
    {
      return setMedalDisplaySize;
    }
  },
  setMedalDisplayIconSize: () => {
    {
      return setMedalDisplayIconSize;
    }
  },
  setInputWASDEmulateDirection: () => {
    {
      return setInputWASDEmulateDirection;
    }
  },
  setHeadlessMode: () => {
    {
      return setHeadlessMode;
    }
  },
  setGravity: () => {
    {
      return setGravity;
    }
  },
  setGlOverlay: () => {
    {
      return setGlOverlay;
    }
  },
  setGlEnable: () => {
    {
      return setGlEnable;
    }
  },
  setGamepadsEnable: () => {
    {
      return setGamepadsEnable;
    }
  },
  setGamepadDirectionEmulateStick: () => {
    {
      return setGamepadDirectionEmulateStick;
    }
  },
  setFontDefault: () => {
    {
      return setFontDefault;
    }
  },
  setEnablePhysicsSolver: () => {
    {
      return setEnablePhysicsSolver;
    }
  },
  setDebugKey: () => {
    {
      return setDebugKey;
    }
  },
  setCanvasPixelated: () => {
    {
      return setCanvasPixelated;
    }
  },
  setCanvasMaxSize: () => {
    {
      return setCanvasMaxSize;
    }
  },
  setCanvasFixedSize: () => {
    {
      return setCanvasFixedSize;
    }
  },
  setCameraScale: () => {
    {
      return setCameraScale;
    }
  },
  setCameraPos: () => {
    {
      return setCameraPos;
    }
  },
  setBlendMode: () => {
    {
      return setBlendMode;
    }
  },
  screenToWorld: () => {
    {
      return screenToWorld;
    }
  },
  rgb: () => {
    {
      return rgb;
    }
  },
  randVector: () => {
    {
      return randVector;
    }
  },
  randSign: () => {
    {
      return randSign;
    }
  },
  randInt: () => {
    {
      return randInt;
    }
  },
  randInCircle: () => {
    {
      return randInCircle;
    }
  },
  randColor: () => {
    {
      return randColor;
    }
  },
  rand: () => {
    {
      return rand;
    }
  },
  preventDefaultInput: () => {
    {
      return preventDefaultInput;
    }
  },
  playSamples: () => {
    {
      return playSamples;
    }
  },
  playAudioFile: () => {
    {
      return playAudioFile;
    }
  },
  percent: () => {
    {
      return percent;
    }
  },
  paused: () => {
    {
      return paused;
    }
  },
  particleEmitRateScale: () => {
    {
      return particleEmitRateScale;
    }
  },
  overlayContext: () => {
    {
      return overlayContext;
    }
  },
  overlayCanvas: () => {
    {
      return overlayCanvas;
    }
  },
  objectMaxSpeed: () => {
    {
      return objectMaxSpeed;
    }
  },
  objectDefaultMass: () => {
    {
      return objectDefaultMass;
    }
  },
  objectDefaultFriction: () => {
    {
      return objectDefaultFriction;
    }
  },
  objectDefaultElasticity: () => {
    {
      return objectDefaultElasticity;
    }
  },
  objectDefaultDamping: () => {
    {
      return objectDefaultDamping;
    }
  },
  objectDefaultAngleDamping: () => {
    {
      return objectDefaultAngleDamping;
    }
  },
  nearestPowerOfTwo: () => {
    {
      return nearestPowerOfTwo;
    }
  },
  mouseWheel: () => {
    {
      return mouseWheel;
    }
  },
  mouseWasReleased: () => {
    {
      return mouseWasReleased;
    }
  },
  mouseWasPressed: () => {
    {
      return mouseWasPressed;
    }
  },
  mouseToScreen: () => {
    {
      return mouseToScreen;
    }
  },
  mousePosScreen: () => {
    {
      return mousePosScreen;
    }
  },
  mousePos: () => {
    {
      return mousePos;
    }
  },
  mouseIsDown: () => {
    {
      return mouseIsDown;
    }
  },
  mod: () => {
    {
      return mod;
    }
  },
  min: () => {
    {
      return min;
    }
  },
  medalsPreventUnlock: () => {
    {
      return medalsPreventUnlock;
    }
  },
  medalsInit: () => {
    {
      return medalsInit;
    }
  },
  medals: () => {
    {
      return medals;
    }
  },
  medalDisplayTime: () => {
    {
      return medalDisplayTime;
    }
  },
  medalDisplaySlideTime: () => {
    {
      return medalDisplaySlideTime;
    }
  },
  medalDisplaySize: () => {
    {
      return medalDisplaySize;
    }
  },
  medalDisplayIconSize: () => {
    {
      return medalDisplayIconSize;
    }
  },
  max: () => {
    {
      return max;
    }
  },
  mainContext: () => {
    {
      return mainContext;
    }
  },
  mainCanvasSize: () => {
    {
      return mainCanvasSize;
    }
  },
  mainCanvas: () => {
    {
      return mainCanvas;
    }
  },
  lerpWrap: () => {
    {
      return lerpWrap;
    }
  },
  lerpAngle: () => {
    {
      return lerpAngle;
    }
  },
  lerp: () => {
    {
      return lerp;
    }
  },
  keyWasReleased: () => {
    {
      return keyWasReleased;
    }
  },
  keyWasPressed: () => {
    {
      return keyWasPressed;
    }
  },
  keyIsDown: () => {
    {
      return keyIsDown;
    }
  },
  isUsingGamepad: () => {
    {
      return isUsingGamepad;
    }
  },
  isTouchDevice: () => {
    {
      return isTouchDevice;
    }
  },
  isOverlapping: () => {
    {
      return isOverlapping;
    }
  },
  isIntersecting: () => {
    {
      return isIntersecting;
    }
  },
  isFullscreen: () => {
    {
      return isFullscreen;
    }
  },
  isColor: () => {
    {
      return isColor;
    }
  },
  inputWASDEmulateDirection: () => {
    {
      return inputWASDEmulateDirection;
    }
  },
  initTileCollision: () => {
    {
      return initTileCollision;
    }
  },
  hsl: () => {
    {
      return hsl;
    }
  },
  headlessMode: () => {
    {
      return headlessMode;
    }
  },
  gravity: () => {
    {
      return gravity;
    }
  },
  glShader: () => {
    {
      return glShader;
    }
  },
  glSetTexture: () => {
    {
      return glSetTexture;
    }
  },
  glSetAntialias: () => {
    {
      return glSetAntialias;
    }
  },
  glPositionData: () => {
    {
      return glPositionData;
    }
  },
  glOverlay: () => {
    {
      return glOverlay;
    }
  },
  glInstanceCount: () => {
    {
      return glInstanceCount;
    }
  },
  glGeometryBuffer: () => {
    {
      return glGeometryBuffer;
    }
  },
  glFlush: () => {
    {
      return glFlush;
    }
  },
  glEnable: () => {
    {
      return glEnable;
    }
  },
  glDraw: () => {
    {
      return glDraw;
    }
  },
  glCreateTexture: () => {
    {
      return glCreateTexture;
    }
  },
  glCreateProgram: () => {
    {
      return glCreateProgram;
    }
  },
  glCopyToContext: () => {
    {
      return glCopyToContext;
    }
  },
  glContext: () => {
    {
      return glContext;
    }
  },
  glCompileShader: () => {
    {
      return glCompileShader;
    }
  },
  glColorData: () => {
    {
      return glColorData;
    }
  },
  glCanvas: () => {
    {
      return glCanvas;
    }
  },
  glBatchAdditive: () => {
    {
      return glBatchAdditive;
    }
  },
  glArrayBuffer: () => {
    {
      return glArrayBuffer;
    }
  },
  glAntialias: () => {
    {
      return glAntialias;
    }
  },
  glAdditive: () => {
    {
      return glAdditive;
    }
  },
  glActiveTexture: () => {
    {
      return glActiveTexture;
    }
  },
  getTileCollisionData: () => {
    {
      return getTileCollisionData;
    }
  },
  getNoteFrequency: () => {
    {
      return getNoteFrequency;
    }
  },
  getCameraSize: () => {
    {
      return getCameraSize;
    }
  },
  gamepadsUpdate: () => {
    {
      return gamepadsUpdate;
    }
  },
  gamepadsEnable: () => {
    {
      return gamepadsEnable;
    }
  },
  gamepadWasReleased: () => {
    {
      return gamepadWasReleased;
    }
  },
  gamepadWasPressed: () => {
    {
      return gamepadWasPressed;
    }
  },
  gamepadStick: () => {
    {
      return gamepadStick;
    }
  },
  gamepadIsDown: () => {
    {
      return gamepadIsDown;
    }
  },
  gamepadDirectionEmulateStick: () => {
    {
      return gamepadDirectionEmulateStick;
    }
  },
  frameRate: () => {
    {
      return frameRate;
    }
  },
  frame: () => {
    {
      return frame;
    }
  },
  formatTime: () => {
    {
      return formatTime;
    }
  },
  fontDefault: () => {
    {
      return fontDefault;
    }
  },
  engineVersion: () => {
    {
      return engineVersion;
    }
  },
  engineObjectsUpdate: () => {
    {
      return engineObjectsUpdate;
    }
  },
  engineObjectsRaycast: () => {
    {
      return engineObjectsRaycast;
    }
  },
  engineObjectsDestroy: () => {
    {
      return engineObjectsDestroy;
    }
  },
  engineObjectsCallback: () => {
    {
      return engineObjectsCallback;
    }
  },
  engineObjects: () => {
    {
      return engineObjects;
    }
  },
  engineName: () => {
    {
      return engineName;
    }
  },
  engineInit: () => {
    {
      return engineInit;
    }
  },
  engineFontImage: () => {
    {
      return engineFontImage;
    }
  },
  engineAddPlugin: () => {
    {
      return engineAddPlugin;
    }
  },
  enablePhysicsSolver: () => {
    {
      return enablePhysicsSolver;
    }
  },
  drawTile: () => {
    {
      return drawTile;
    }
  },
  drawTextScreen: () => {
    {
      return drawTextScreen;
    }
  },
  drawText: () => {
    {
      return drawText;
    }
  },
  drawRect: () => {
    {
      return drawRect;
    }
  },
  drawPoly: () => {
    {
      return drawPoly;
    }
  },
  drawLine: () => {
    {
      return drawLine;
    }
  },
  drawEllipse: () => {
    {
      return drawEllipse;
    }
  },
  drawCircle: () => {
    {
      return drawCircle;
    }
  },
  drawCanvas2D: () => {
    {
      return drawCanvas2D;
    }
  },
  distanceWrap: () => {
    {
      return distanceWrap;
    }
  },
  distanceAngle: () => {
    {
      return distanceAngle;
    }
  },
  debugText: () => {
    {
      return debugText;
    }
  },
  debugSaveText: () => {
    {
      return debugSaveText;
    }
  },
  debugSaveDataURL: () => {
    {
      return debugSaveDataURL;
    }
  },
  debugSaveCanvas: () => {
    {
      return debugSaveCanvas;
    }
  },
  debugRect: () => {
    {
      return debugRect;
    }
  },
  debugPoly: () => {
    {
      return debugPoly;
    }
  },
  debugPoint: () => {
    {
      return debugPoint;
    }
  },
  debugOverlay: () => {
    {
      return debugOverlay;
    }
  },
  debugOverlap: () => {
    {
      return debugOverlap;
    }
  },
  debugLine: () => {
    {
      return debugLine;
    }
  },
  debugClear: () => {
    {
      return debugClear;
    }
  },
  debugCircle: () => {
    {
      return debugCircle;
    }
  },
  debug: () => {
    {
      return debug;
    }
  },
  clearInput: () => {
    {
      return clearInput;
    }
  },
  clamp: () => {
    {
      return clamp;
    }
  },
  canvasPixelated: () => {
    {
      return canvasPixelated;
    }
  },
  canvasMaxSize: () => {
    {
      return canvasMaxSize;
    }
  },
  canvasFixedSize: () => {
    {
      return canvasFixedSize;
    }
  },
  cameraScale: () => {
    {
      return cameraScale;
    }
  },
  cameraPos: () => {
    {
      return cameraPos;
    }
  },
  audioContext: () => {
    {
      return audioContext;
    }
  },
  abs: () => {
    {
      return abs;
    }
  },
  YELLOW: () => {
    {
      return YELLOW;
    }
  },
  WHITE: () => {
    {
      return WHITE;
    }
  },
  Vector2: () => {
    {
      return Vector2;
    }
  },
  Timer: () => {
    {
      return Timer;
    }
  },
  TileLayerData: () => {
    {
      return TileLayerData;
    }
  },
  TileLayer: () => {
    {
      return TileLayer;
    }
  },
  TileInfo: () => {
    {
      return TileInfo;
    }
  },
  TextureInfo: () => {
    {
      return TextureInfo;
    }
  },
  SoundWave: () => {
    {
      return SoundWave;
    }
  },
  Sound: () => {
    {
      return Sound;
    }
  },
  RandomGenerator: () => {
    {
      return RandomGenerator;
    }
  },
  RED: () => {
    {
      return RED;
    }
  },
  ParticleEmitter: () => {
    {
      return ParticleEmitter;
    }
  },
  Particle: () => {
    {
      return Particle;
    }
  },
  PURPLE: () => {
    {
      return PURPLE;
    }
  },
  PI: () => {
    {
      return PI;
    }
  },
  ORANGE: () => {
    {
      return ORANGE;
    }
  },
  Music: () => {
    {
      return Music;
    }
  },
  Medal: () => {
    {
      return Medal;
    }
  },
  MAGENTA: () => {
    {
      return MAGENTA;
    }
  },
  GREEN: () => {
    {
      return GREEN;
    }
  },
  GRAY: () => {
    {
      return GRAY;
    }
  },
  FontImage: () => {
    {
      return FontImage;
    }
  },
  EngineObject: () => {
    {
      return EngineObject;
    }
  },
  Color: () => {
    {
      return Color;
    }
  },
  CYAN: () => {
    {
      return CYAN;
    }
  },
  BLUE: () => {
    {
      return BLUE;
    }
  },
  BLACK: () => {
    {
      return BLACK;
    }
  },
  ASSERT: () => {
    {
      return ASSERT;
    }
  }
});
var ASSERT = function() {
};
var debugInit = function() {
};
var debugUpdate = function() {
};
var debugRender = function() {
};
var debugRect = function() {
};
var debugPoly = function() {
};
var debugCircle = function() {
};
var debugPoint = function() {
};
var debugLine = function() {
};
var debugOverlap = function() {
};
var debugText = function() {
};
var debugClear = function() {
};
var debugSaveCanvas = function() {
};
var debugSaveText = function() {
};
var debugSaveDataURL = function() {
};
var abs = function(a) {
  return Math.abs(a);
};
var min = function(a, b) {
  return Math.min(a, b);
};
var max = function(a, b) {
  return Math.max(a, b);
};
var sign = function(a) {
  return Math.sign(a);
};
var mod = function(a, b = 1) {
  return (a % b + b) % b;
};
var clamp = function(a, b = 0, c = 1) {
  return a < b ? b : a > c ? c : a;
};
var percent = function(a, b, c) {
  return (c -= b) ? clamp((a - b) / c) : 0;
};
var lerp = function(a, b, c) {
  return b + clamp(a) * (c - b);
};
var distanceWrap = function(a, b, c = 1) {
  a = (a - b) % c;
  return 2 * a % c - a;
};
var lerpWrap = function(a, b, c, d = 1) {
  return c + clamp(a) * distanceWrap(b, c, d);
};
var distanceAngle = function(a, b) {
  return distanceWrap(a, b, 2 * PI);
};
var lerpAngle = function(a, b, c) {
  return lerpWrap(a, b, c, 2 * PI);
};
var smoothStep = function(a) {
  return a * a * (3 - 2 * a);
};
var nearestPowerOfTwo = function(a) {
  return 2 ** Math.ceil(Math.log2(a));
};
var isOverlapping = function(a, b, c, d = vec2()) {
  return 2 * abs(a.x - c.x) < b.x + d.x && 2 * abs(a.y - c.y) < b.y + d.y;
};
var isIntersecting = function(a, b, c, d) {
  c = c.subtract(d.scale(0.5));
  d = c.add(d);
  b = b.subtract(a);
  c = a.subtract(c);
  d = a.subtract(d);
  a = [-b.x, b.x, -b.y, b.y];
  b = [c.x, -d.x, c.y, -d.y];
  c = 0;
  d = 1;
  for (let e = 4;e--; )
    if (a[e]) {
      const f = b[e] / a[e];
      if (0 > a[e]) {
        if (f > d)
          return false;
        c = max(f, c);
      } else {
        if (f < c)
          return false;
        d = min(f, d);
      }
    } else if (0 > b[e])
      return false;
  return true;
};
var wave = function(a = 1, b = 1, c = time) {
  return b / 2 * (1 - Math.cos(c * a * 2 * PI));
};
var formatTime = function(a) {
  return (a / 60 | 0) + ":" + (10 > a % 60 ? "0" : "") + (a % 60 | 0);
};
var rand = function(a = 1, b = 0) {
  return b + Math.random() * (a - b);
};
var randInt = function(a, b = 0) {
  return Math.floor(rand(a, b));
};
var randSign = function() {
  return 2 * randInt(2) - 1;
};
var randVector = function(a = 1) {
  return new Vector2().setAngle(rand(2 * PI), a);
};
var randInCircle = function(a = 1, b = 0) {
  return 0 < a ? randVector(a * rand(b / a, 1) ** 0.5) : new Vector2;
};
var randColor = function(a = new Color, b = new Color(0, 0, 0, 1), c = false) {
  return c ? a.lerp(b, rand()) : new Color(rand(a.r, b.r), rand(a.g, b.g), rand(a.b, b.b), rand(a.a, b.a));
};
var vec2 = function(a = 0, b) {
  return typeof a == "number" ? new Vector2(a, b == undefined ? a : b) : new Vector2(a.x, a.y);
};
var isVector2 = function(a) {
  return a instanceof Vector2;
};
var rgb = function(a, b, c, d) {
  return new Color(a, b, c, d);
};
var hsl = function(a, b, c, d) {
  return new Color().setHSLA(a, b, c, d);
};
var isColor = function(a) {
  return a instanceof Color;
};
var setCameraPos = function(a) {
  cameraPos = a;
};
var setCameraScale = function(a) {
  cameraScale = a;
};
var setCanvasMaxSize = function(a) {
  canvasMaxSize = a;
};
var setCanvasFixedSize = function(a) {
  canvasFixedSize = a;
};
var setCanvasPixelated = function(a) {
  canvasPixelated = a;
};
var setFontDefault = function(a) {
  fontDefault = a;
};
var setShowSplashScreen = function(a) {
  showSplashScreen = a;
};
var setHeadlessMode = function(a) {
  headlessMode = a;
};
var setGlEnable = function(a) {
  glEnable = a;
};
var setGlOverlay = function(a) {
  glOverlay = a;
};
var setTileSizeDefault = function(a) {
  tileSizeDefault = a;
};
var setTileFixBleedScale = function(a) {
  tileFixBleedScale = a;
};
var setEnablePhysicsSolver = function(a) {
  enablePhysicsSolver = a;
};
var setObjectDefaultMass = function(a) {
  objectDefaultMass = a;
};
var setObjectDefaultDamping = function(a) {
  objectDefaultDamping = a;
};
var setObjectDefaultAngleDamping = function(a) {
  objectDefaultAngleDamping = a;
};
var setObjectDefaultElasticity = function(a) {
  objectDefaultElasticity = a;
};
var setObjectDefaultFriction = function(a) {
  objectDefaultFriction = a;
};
var setObjectMaxSpeed = function(a) {
  objectMaxSpeed = a;
};
var setGravity = function(a) {
  gravity = a;
};
var setParticleEmitRateScale = function(a) {
  particleEmitRateScale = a;
};
var setGamepadsEnable = function(a) {
  gamepadsEnable = a;
};
var setGamepadDirectionEmulateStick = function(a) {
  gamepadDirectionEmulateStick = a;
};
var setInputWASDEmulateDirection = function(a) {
  inputWASDEmulateDirection = a;
};
var setTouchInputEnable = function(a) {
  touchInputEnable = a;
};
var setTouchGamepadEnable = function(a) {
  touchGamepadEnable = a;
};
var setTouchGamepadAnalog = function(a) {
  touchGamepadAnalog = a;
};
var setTouchGamepadSize = function(a) {
  touchGamepadSize = a;
};
var setTouchGamepadAlpha = function(a) {
  touchGamepadAlpha = a;
};
var setVibrateEnable = function(a) {
  vibrateEnable = a;
};
var setSoundEnable = function(a) {
  soundEnable = a;
};
var setSoundVolume = function(a) {
  soundVolume = a;
  soundEnable && !headlessMode && audioGainNode && (audioGainNode.gain.value = a);
};
var setSoundDefaultRange = function(a) {
  soundDefaultRange = a;
};
var setSoundDefaultTaper = function(a) {
  soundDefaultTaper = a;
};
var setMedalDisplayTime = function(a) {
  medalDisplayTime = a;
};
var setMedalDisplaySlideTime = function(a) {
  medalDisplaySlideTime = a;
};
var setMedalDisplaySize = function(a) {
  medalDisplaySize = a;
};
var setMedalDisplayIconSize = function(a) {
  medalDisplayIconSize = a;
};
var setMedalsPreventUnlock = function(a) {
  medalsPreventUnlock = a;
};
var setShowWatermark = function(a) {
  showWatermark = a;
};
var setDebugKey = function(a) {
  debugKey = a;
};
var tile = function(a = vec2(), b = tileSizeDefault, c = 0, d = 0) {
  if (headlessMode)
    return new TileInfo;
  typeof b === "number" && (ASSERT(0 < b), b = vec2(b));
  var e = textureInfos[c];
  ASSERT(e, "Texture not loaded");
  const f = b.add(vec2(2 * d));
  e = e.size.x / f.x | 0;
  typeof a === "number" && (a = vec2(a % e, a / e | 0));
  a = vec2(a.x * f.x + d, a.y * f.y + d);
  return new TileInfo(a, b, c, d);
};
var screenToWorld = function(a) {
  return new Vector2((a.x - mainCanvasSize.x / 2 + 0.5) / cameraScale + cameraPos.x, (a.y - mainCanvasSize.y / 2 + 0.5) / -cameraScale + cameraPos.y);
};
var worldToScreen = function(a) {
  return new Vector2((a.x - cameraPos.x) * cameraScale + mainCanvasSize.x / 2 - 0.5, (a.y - cameraPos.y) * -cameraScale + mainCanvasSize.y / 2 - 0.5);
};
var getCameraSize = function() {
  return mainCanvasSize.scale(1 / cameraScale);
};
var drawTile = function(a, b = vec2(1), c, d = new Color, e = 0, f, g = new Color(0, 0, 0, 0), k = glEnable, h, m) {
  ASSERT(!m || !k, "context only supported in canvas 2D mode");
  ASSERT(typeof c !== "number" || !c, "this is an old style calls, to fix replace it with tile(tileIndex, tileSize)");
  const n = c && c.getTextureInfo();
  if (k)
    if (h && (a = screenToWorld(a), b = b.scale(1 / cameraScale)), n) {
      var l = vec2(1).divide(n.size);
      k = c.pos.x * l.x;
      h = c.pos.y * l.y;
      m = c.size.x * l.x;
      const p = c.size.y * l.y;
      l = l.scale(tileFixBleedScale);
      glSetTexture(n.glTexture);
      glDraw(a.x, a.y, f ? -b.x : b.x, b.y, e, k + l.x, h + l.y, k - l.x + m, h - l.y + p, d.rgbaInt(), g.rgbaInt());
    } else
      glDraw(a.x, a.y, b.x, b.y, e, 0, 0, 0, 0, 0, d.rgbaInt());
  else
    showWatermark && ++drawCount, b = vec2(b.x, -b.y), drawCanvas2D(a, b, e, f, (p) => {
      if (n) {
        const q = c.pos.x + tileFixBleedScale, r = c.pos.y + tileFixBleedScale, x = c.size.x - 2 * tileFixBleedScale, v = c.size.y - 2 * tileFixBleedScale;
        p.globalAlpha = d.a;
        p.drawImage(n.image, q, r, x, v, -0.5, -0.5, 1, 1);
        p.globalAlpha = 1;
      } else
        p.fillStyle = d, p.fillRect(-0.5, -0.5, 1, 1);
    }, h, m);
};
var drawRect = function(a, b, c, d, e, f, g) {
  drawTile(a, b, undefined, c, d, false, undefined, e, f, g);
};
var drawLine = function(a, b, c = 0.1, d, e, f, g) {
  b = vec2((b.x - a.x) / 2, (b.y - a.y) / 2);
  c = vec2(c, 2 * b.length());
  drawRect(a.add(b), c, d, b.angle(), e, f, g);
};
var drawPoly = function(a, b = new Color, c = 0, d = new Color(0, 0, 0), e, f = mainContext) {
  f.fillStyle = b.toString();
  f.beginPath();
  for (const g of e ? a : a.map(worldToScreen))
    f.lineTo(g.x, g.y);
  f.closePath();
  f.fill();
  c && (f.strokeStyle = d.toString(), f.lineWidth = e ? c : c * cameraScale, f.stroke());
};
var drawEllipse = function(a, b = 1, c = 1, d = 0, e = new Color, f = 0, g = new Color(0, 0, 0), k, h = mainContext) {
  k || (a = worldToScreen(a), b *= cameraScale, c *= cameraScale, f *= cameraScale);
  h.fillStyle = e.toString();
  h.beginPath();
  h.ellipse(a.x, a.y, b, c, d, 0, 9);
  h.fill();
  f && (h.strokeStyle = g.toString(), h.lineWidth = f, h.stroke());
};
var drawCircle = function(a, b = 1, c = new Color, d = 0, e = new Color(0, 0, 0), f, g = mainContext) {
  drawEllipse(a, b, b, 0, c, d, e, f, g);
};
var drawCanvas2D = function(a, b, c, d, e, f, g = mainContext) {
  f || (a = worldToScreen(a), b = b.scale(cameraScale));
  g.save();
  g.translate(a.x + 0.5, a.y + 0.5);
  g.rotate(c);
  g.scale(d ? -b.x : b.x, -b.y);
  e(g);
  g.restore();
};
var setBlendMode = function(a, b = glEnable, c) {
  ASSERT(!c || !b, "context only supported in canvas 2D mode");
  b ? glAdditive = a : (c ||= mainContext, c.globalCompositeOperation = a ? "lighter" : "source-over");
};
var drawText = function(a, b, c = 1, d, e = 0, f, g, k, h, m) {
  drawTextScreen(a, worldToScreen(b), c * cameraScale, d, e * cameraScale, f, g, k, h, m);
};
var drawTextScreen = function(a, b, c = 1, d = new Color, e = 0, f = new Color(0, 0, 0), g = "center", k = fontDefault, h = overlayContext, m) {
  h.fillStyle = d.toString();
  h.lineWidth = e;
  h.strokeStyle = f.toString();
  h.textAlign = g;
  h.font = c + "px " + k;
  h.textBaseline = "middle";
  h.lineJoin = "round";
  b = b.copy();
  (a + "").split("\n").forEach((n) => {
    e && h.strokeText(n, b.x, b.y, m);
    h.fillText(n, b.x, b.y, m);
    b.y += c;
  });
};
var isFullscreen = function() {
  return !!document.fullscreenElement;
};
var toggleFullscreen = function() {
  const a = mainCanvas.parentElement;
  isFullscreen() ? document.exitFullscreen && document.exitFullscreen() : a.requestFullscreen && a.requestFullscreen();
};
var keyIsDown = function(a, b = 0) {
  ASSERT(0 < b || typeof a !== "number" || 3 > a, "use code string for keyboard");
  return inputData[b] && !!(inputData[b][a] & 1);
};
var keyWasPressed = function(a, b = 0) {
  ASSERT(0 < b || typeof a !== "number" || 3 > a, "use code string for keyboard");
  return inputData[b] && !!(inputData[b][a] & 2);
};
var keyWasReleased = function(a, b = 0) {
  ASSERT(0 < b || typeof a !== "number" || 3 > a, "use code string for keyboard");
  return inputData[b] && !!(inputData[b][a] & 4);
};
var clearInput = function() {
  inputData = [[]];
  touchGamepadButtons = [];
};
var gamepadIsDown = function(a, b = 0) {
  return keyIsDown(a, b + 1);
};
var gamepadWasPressed = function(a, b = 0) {
  return keyWasPressed(a, b + 1);
};
var gamepadWasReleased = function(a, b = 0) {
  return keyWasReleased(a, b + 1);
};
var gamepadStick = function(a, b = 0) {
  return gamepadStickData[b] ? gamepadStickData[b][a] || vec2() : vec2();
};
var inputUpdate = function() {
  headlessMode || (touchInputEnable && isTouchDevice || document.hasFocus() || clearInput(), mousePos = screenToWorld(mousePosScreen), gamepadsUpdate());
};
var inputUpdatePost = function() {
  if (!headlessMode) {
    for (const a of inputData)
      for (const b in a)
        a[b] &= 1;
    mouseWheel = 0;
  }
};
var inputInit = function() {
  function a(b) {
    return inputWASDEmulateDirection ? b == "KeyW" ? "ArrowUp" : b == "KeyS" ? "ArrowDown" : b == "KeyA" ? "ArrowLeft" : b == "KeyD" ? "ArrowRight" : b : b;
  }
  headlessMode || (onkeydown = (b) => {
    b.repeat || (isUsingGamepad = false, inputData[0][b.code] = 3, inputWASDEmulateDirection && (inputData[0][a(b.code)] = 3));
    preventDefaultInput && b.preventDefault();
  }, onkeyup = (b) => {
    inputData[0][b.code] = 4;
    inputWASDEmulateDirection && (inputData[0][a(b.code)] = 4);
  }, onmousedown = (b) => {
    soundEnable && !headlessMode && audioContext && audioContext.state != "running" && audioContext.resume();
    isUsingGamepad = false;
    inputData[0][b.button] = 3;
    mousePosScreen = mouseToScreen(b);
    b.button && b.preventDefault();
  }, onmouseup = (b) => inputData[0][b.button] = inputData[0][b.button] & 2 | 4, onmousemove = (b) => mousePosScreen = mouseToScreen(b), onwheel = (b) => mouseWheel = b.ctrlKey ? 0 : sign(b.deltaY), oncontextmenu = (b) => false, onblur = (b) => clearInput(), isTouchDevice && touchInputEnable && touchInputInit());
};
var mouseToScreen = function(a) {
  if (!mainCanvas || headlessMode)
    return vec2();
  const b = mainCanvas.getBoundingClientRect();
  return vec2(mainCanvas.width, mainCanvas.height).multiply(vec2(percent(a.x, b.left, b.right), percent(a.y, b.top, b.bottom)));
};
var gamepadsUpdate = function() {
  const a = (g) => {
    const k = (h) => 0.3 < h ? percent(h, 0.3, 0.8) : -0.3 > h ? -percent(-h, 0.3, 0.8) : 0;
    return vec2(k(g.x), k(-g.y)).clampLength();
  };
  if (touchGamepadEnable && isTouchDevice && (ASSERT(touchGamepadButtons, "set touchGamepadEnable before calling init!"), touchGamepadTimer.isSet())) {
    var b = gamepadStickData[0] || (gamepadStickData[0] = []);
    b[0] = vec2();
    touchGamepadAnalog ? b[0] = a(touchGamepadStick) : 0.3 < touchGamepadStick.lengthSquared() && (b[0].x = Math.round(touchGamepadStick.x), b[0].y = -Math.round(touchGamepadStick.y), b[0] = b[0].clampLength());
    b = inputData[1] || (inputData[1] = []);
    for (var c = 10;c--; ) {
      var d = c == 3 ? 2 : c == 2 ? 3 : c, e = gamepadIsDown(d, 0);
      b[d] = touchGamepadButtons[c] ? e ? 1 : 3 : e ? 4 : 0;
    }
  }
  if (gamepadsEnable && navigator && navigator.getGamepads && (debug || document.hasFocus()))
    for (b = navigator.getGamepads(), c = b.length;c--; ) {
      e = b[c];
      const g = inputData[c + 1] || (inputData[c + 1] = []);
      d = gamepadStickData[c] || (gamepadStickData[c] = []);
      if (e) {
        for (var f = 0;f < e.axes.length - 1; f += 2)
          d[f >> 1] = a(vec2(e.axes[f], e.axes[f + 1]));
        for (f = e.buttons.length;f--; ) {
          const k = e.buttons[f], h = gamepadIsDown(f, c);
          g[f] = k.pressed ? h ? 1 : 3 : h ? 4 : 0;
          isUsingGamepad ||= !c && k.pressed;
        }
        gamepadDirectionEmulateStick && (e = vec2((gamepadIsDown(15, c) && 1) - (gamepadIsDown(14, c) && 1), (gamepadIsDown(12, c) && 1) - (gamepadIsDown(13, c) && 1)), e.lengthSquared() && (d[0] = e.clampLength()));
        touchGamepadEnable && isUsingGamepad && touchGamepadTimer.unset();
      }
    }
};
var vibrate = function(a = 100) {
  vibrateEnable && !headlessMode && navigator && navigator.vibrate && navigator.vibrate(a);
};
var vibrateStop = function() {
  vibrate(0);
};
var touchInputInit = function() {
  function a(e) {
    soundEnable && !headlessMode && audioContext && audioContext.state != "running" && audioContext.resume();
    const f = e.touches.length;
    if (f) {
      const g = vec2(e.touches[0].clientX, e.touches[0].clientY);
      mousePosScreen = mouseToScreen(g);
      d ? isUsingGamepad = touchGamepadEnable : inputData[0][0] = 3;
    } else
      d && (inputData[0][0] = inputData[0][0] & 2 | 4);
    d = f;
    document.hasFocus() && e.preventDefault();
    return true;
  }
  function b(e) {
    touchGamepadStick = vec2();
    touchGamepadButtons = [];
    isUsingGamepad = true;
    if (e.touches.length && (touchGamepadTimer.set(), paused && !d)) {
      touchGamepadButtons[9] = 1;
      a(e);
      return;
    }
    const f = vec2(touchGamepadSize, mainCanvasSize.y - touchGamepadSize), g = mainCanvasSize.subtract(vec2(touchGamepadSize, touchGamepadSize)), k = mainCanvasSize.scale(0.5);
    for (const m of e.touches) {
      var h = mouseToScreen(vec2(m.clientX, m.clientY));
      h.distance(f) < touchGamepadSize ? touchGamepadStick = h.subtract(f).scale(2 / touchGamepadSize).clampLength() : h.distance(g) < touchGamepadSize ? (h = h.subtract(g).direction(), touchGamepadButtons[h] = 1) : h.distance(k) < touchGamepadSize && !d && (touchGamepadButtons[9] = 1);
    }
    a(e);
    return true;
  }
  let c = a;
  touchGamepadEnable && (c = b, touchGamepadButtons = [], touchGamepadStick = vec2());
  document.addEventListener("touchstart", (e) => c(e), { passive: false });
  document.addEventListener("touchmove", (e) => c(e), { passive: false });
  document.addEventListener("touchend", (e) => c(e), { passive: false });
  onmousedown = onmouseup = () => 0;
  let d;
};
var touchGamepadRender = function() {
  if (touchInputEnable && isTouchDevice && !headlessMode && touchGamepadEnable && touchGamepadTimer.isSet()) {
    var a = percent(touchGamepadTimer.get(), 4, 3);
    if (a && !paused) {
      var b = overlayContext;
      b.save();
      b.globalAlpha = a * touchGamepadAlpha;
      b.strokeStyle = "#fff";
      b.lineWidth = 3;
      b.fillStyle = 0 < touchGamepadStick.lengthSquared() ? "#fff" : "#000";
      b.beginPath();
      a = vec2(touchGamepadSize, mainCanvasSize.y - touchGamepadSize);
      if (touchGamepadAnalog)
        b.arc(a.x, a.y, touchGamepadSize / 2, 0, 9), b.fill();
      else
        for (var c = 10;c--; ) {
          var d = c * PI / 4;
          b.arc(a.x, a.y, 0.6 * touchGamepadSize, d + PI / 8, d + PI / 8);
          c % 2 && b.arc(a.x, a.y, 0.33 * touchGamepadSize, d, d);
          c == 1 && b.fill();
        }
      b.stroke();
      a = vec2(mainCanvasSize.x - touchGamepadSize, mainCanvasSize.y - touchGamepadSize);
      for (c = 4;c--; )
        d = a.add(vec2().setDirection(c, touchGamepadSize / 2)), b.fillStyle = touchGamepadButtons[c] ? "#fff" : "#000", b.beginPath(), b.arc(d.x, d.y, touchGamepadSize / 4, 0, 9), b.fill(), b.stroke();
      b.restore();
    }
  }
};
var audioInit = function() {
  soundEnable && !headlessMode && (audioGainNode = audioContext.createGain(), audioGainNode.connect(audioContext.destination), audioGainNode.gain.value = soundVolume);
};
var playAudioFile = function(a, b = 1, c = false) {
  if (soundEnable && !headlessMode)
    return new SoundWave(a, 0, 0, 0, (d) => d.play(undefined, b, 1, 1, c));
};
var speak = function(a, b = "", c = 1, d = 1, e = 1) {
  if (soundEnable && !headlessMode && speechSynthesis)
    return a = new SpeechSynthesisUtterance(a), a.lang = b, a.volume = 2 * c * soundVolume, a.rate = d, a.pitch = e, speechSynthesis.speak(a), a;
};
var speakStop = function() {
  speechSynthesis && speechSynthesis.cancel();
};
var getNoteFrequency = function(a, b = 220) {
  return b * 2 ** (a / 12);
};
var playSamples = function(a, b = 1, c = 1, d = 0, e = false, f = zzfxR, g) {
  if (soundEnable && !headlessMode) {
    var k = audioContext.createBuffer(a.length, a[0].length, f), h = audioContext.createBufferSource();
    a.forEach((m, n) => k.getChannelData(n).set(m));
    h.buffer = k;
    h.playbackRate.value = c;
    h.loop = e;
    g = g || audioContext.createGain();
    g.gain.value = b;
    g.connect(audioGainNode);
    a = new StereoPannerNode(audioContext, { pan: clamp(d, -1, 1) });
    h.connect(a).connect(g);
    audioContext.state != "running" ? audioContext.resume().then(() => h.start()) : h.start();
    return h;
  }
};
var zzfx = function(...a) {
  return playSamples([zzfxG(...a)]);
};
var zzfxG = function(a = 1, b = 0.05, c = 220, d = 0, e = 0, f = 0.1, g = 0, k = 1, h = 0, m = 0, n = 0, l = 0, p = 0, q = 0, r = 0, x = 0, v = 0, D = 1, z = 0, E = 0, A = 0) {
  let w = 2 * PI;
  var t = zzfxR;
  let F = h *= 500 * w / t / t;
  b = c *= rand(1 + b, 1 - b) * w / t;
  let C = [], y = 0, G = 0, u = 0, H = 1, R = 0, S = 0, B = 0, J;
  var L = w * abs(A) * 2 / t, K = Math.cos(L), M = Math.sin(L) / 2 / 2, I = 1 + M;
  L = -2 * K / I;
  M = (1 - M) / I;
  let N = (1 + sign(A) * K) / 2 / I;
  K = -(sign(A) + K) / I;
  let O = I = 0, P = 0, Q = 0;
  d = d * t + 9;
  z *= t;
  e *= t;
  f *= t;
  v *= t;
  m *= 500 * w / t ** 3;
  r *= w / t;
  n *= w / t;
  l *= t;
  p = p * t | 0;
  for (J = d + z + e + f + v | 0;u < J; C[u++] = B * a)
    ++S % (100 * x | 0) || (B = g ? 1 < g ? 2 < g ? 3 < g ? Math.sin(y ** 3) : clamp(Math.tan(y), 1, -1) : 1 - (2 * y / w % 2 + 2) % 2 : 1 - 4 * abs(Math.round(y / w) - y / w) : Math.sin(y), B = (p ? 1 - E + E * Math.sin(w * u / p) : 1) * sign(B) * abs(B) ** k * (u < d ? u / d : u < d + z ? 1 - (u - d) / z * (1 - D) : u < d + z + e ? D : u < J - v ? (J - u - v) / f * D : 0), B = v ? B / 2 + (v > u ? 0 : (u < J - v ? 1 : (J - u) / v) * C[u - v | 0] / 2 / a) : B, A && (B = Q = N * I + K * (I = O) + N * (O = B) - M * P - L * (P = Q))), t = (c += h += m) * Math.cos(r * G++), y += t + t * q * Math.sin(u ** 5), H && ++H > l && (c += n, b += n, H = 0), !p || ++R % p || (c = b, h = F, H = H || 1);
  return C;
};
var zzfxM = function(a, b, c, d = 125) {
  let e, f, g, k, h, m, n, l, p, q, r, x, v, D = 0, z, E = [], A = [], w = [], t = 0, F = 0, C = 1, y = {}, G = zzfxR / d * 60 >> 2;
  for (;C; t++)
    E = [C = l = x = 0], c.forEach((u, H) => {
      n = b[u][t] || [0, 0, 0];
      C |= b[u][t] && 1;
      z = x + (b[u][0].length - 2 - (l ? 0 : 1)) * G;
      v = H == c.length - 1;
      e = 2;
      for (g = x;e < n.length + v; l = ++e) {
        h = n[e];
        p = e == n.length + v - 1 && v || q != (n[0] || 0) || h | 0;
        for (f = 0;f < G && l; f++ > G - 99 && p && 1 > r ? r += 1 / 99 : 0)
          m = (1 - r) * E[D++] / 2 || 0, A[g] = (A[g] || 0) - m * F + m, w[g] = (w[g++] || 0) + m * F + m;
        h && (r = h % 1, F = n[1] || 0, h |= 0) && (E = y[[q = n[D = 0] || 0, h]] = y[[q, h]] || (k = [...a[q]], k[2] *= 2 ** ((h - 12) / 12), 0 < h ? zzfxG(...k) : []));
      }
      x = z;
    });
  return [A, w];
};
var initTileCollision = function(a) {
  tileCollisionSize = a;
  tileCollision = [];
  for (a = tileCollision.length = tileCollisionSize.area();a--; )
    tileCollision[a] = 0;
};
var setTileCollisionData = function(a, b = 0) {
  a.arrayCheck(tileCollisionSize) && (tileCollision[(a.y | 0) * tileCollisionSize.x + a.x | 0] = b);
};
var getTileCollisionData = function(a) {
  return a.arrayCheck(tileCollisionSize) ? tileCollision[(a.y | 0) * tileCollisionSize.x + a.x | 0] : 0;
};
var tileCollisionTest = function(a, b = vec2(), c) {
  const d = max(a.x - b.x / 2 | 0, 0);
  var e = max(a.y - b.y / 2 | 0, 0);
  const f = min(a.x + b.x / 2, tileCollisionSize.x);
  for (a = min(a.y + b.y / 2, tileCollisionSize.y);e < a; ++e)
    for (b = d;b < f; ++b) {
      const g = tileCollision[e * tileCollisionSize.x + b];
      if (g && (!c || c.collideWithTile(g, vec2(b, e))))
        return true;
    }
  return false;
};
var tileCollisionRaycast = function(a, b, c) {
  const d = b.subtract(a), e = d.length();
  var f = d.normalize();
  f = vec2(abs(1 / f.x), abs(1 / f.y));
  let g = a.floor(), k = f.x * (0 > d.x ? a.x - g.x : g.x - a.x + 1), h = f.y * (0 > d.y ? a.y - g.y : g.y - a.y + 1);
  for (;; ) {
    const m = getTileCollisionData(g);
    if (m && (!c || c.collideWithTile(m, g)))
      return debugRaycast && debugLine(a, b, "#f00", 0.02), debugRaycast && debugPoint(g.add(vec2(0.5)), "#ff0"), g.add(vec2(0.5));
    if (k > e && h > e)
      break;
    k > h ? (g.y += sign(d.y), h += f.y) : (g.x += sign(d.x), k += f.x);
  }
  debugRaycast && debugLine(a, b, "#00f", 0.02);
};
var medalsInit = function(a) {
  medalsSaveName = a;
  debugMedals || medalsForEach((b) => b.unlocked = !!localStorage[b.storageKey()]);
  engineAddPlugin(undefined, function() {
    if (medalsDisplayQueue.length) {
      var b = medalsDisplayQueue[0], c = timeReal - medalsDisplayTimeLast;
      if (medalsDisplayTimeLast)
        if (c > medalDisplayTime)
          medalsDisplayTimeLast = 0, medalsDisplayQueue.shift();
        else {
          const d = medalDisplayTime - medalDisplaySlideTime;
          b.render(c < medalDisplaySlideTime ? 1 - c / medalDisplaySlideTime : c > d ? (c - d) / medalDisplaySlideTime : 0);
        }
      else
        medalsDisplayTimeLast = timeReal;
    }
  });
};
var medalsForEach = function(a) {
  Object.values(medals).forEach((b) => a(b));
};
var glInit = function() {
  if (glEnable && !headlessMode) {
    glCanvas = document.createElement("canvas");
    glContext = glCanvas.getContext("webgl2", { antialias: glAntialias });
    var a = mainCanvas.parentElement;
    glOverlay && a.appendChild(glCanvas);
    glShader = glCreateProgram("#version 300 es\nprecision highp float;uniform mat4 m;in vec2 g;in vec4 p,u,c,a;in float r;out vec2 v;out vec4 d,e;void main(){vec2 s=(g-.5)*p.zw;gl_Position=m*vec4(p.xy+s*cos(r)-vec2(-s.y,s)*sin(r),1,1);v=mix(u.xw,u.zy,g);d=c;e=a;}", "#version 300 es\nprecision highp float;uniform sampler2D s;in vec2 v;in vec4 d,e;out vec4 c;void main(){c=texture(s,v)*d+e;}");
    a = new ArrayBuffer(gl_INSTANCE_BUFFER_SIZE);
    glPositionData = new Float32Array(a);
    glColorData = new Uint32Array(a);
    glArrayBuffer = glContext.createBuffer();
    glGeometryBuffer = glContext.createBuffer();
    a = new Float32Array([glInstanceCount = 0, 0, 1, 0, 0, 1, 1, 1]);
    glContext.bindBuffer(gl_ARRAY_BUFFER, glGeometryBuffer);
    glContext.bufferData(gl_ARRAY_BUFFER, a, gl_STATIC_DRAW);
  }
};
var glPreRender = function() {
  if (glEnable && !headlessMode) {
    glContext.viewport(0, 0, glCanvas.width = mainCanvas.width, glCanvas.height = mainCanvas.height);
    glContext.clear(gl_COLOR_BUFFER_BIT);
    glContext.useProgram(glShader);
    glContext.activeTexture(gl_TEXTURE0);
    textureInfos[0] && glContext.bindTexture(gl_TEXTURE_2D, glActiveTexture = textureInfos[0].glTexture);
    var a = glAdditive = glBatchAdditive = 0, b = (d, e, f, g) => {
      d = glContext.getAttribLocation(glShader, d);
      const k = f && gl_INSTANCE_BYTE_STRIDE, h = f && 1, m = f == 1;
      glContext.enableVertexAttribArray(d);
      glContext.vertexAttribPointer(d, g, e, m, k, a);
      glContext.vertexAttribDivisor(d, h);
      a += g * f;
    };
    glContext.bindBuffer(gl_ARRAY_BUFFER, glGeometryBuffer);
    b("g", gl_FLOAT, 0, 2);
    glContext.bindBuffer(gl_ARRAY_BUFFER, glArrayBuffer);
    glContext.bufferData(gl_ARRAY_BUFFER, gl_INSTANCE_BUFFER_SIZE, gl_DYNAMIC_DRAW);
    b("p", gl_FLOAT, 4, 4);
    b("u", gl_FLOAT, 4, 4);
    b("c", gl_UNSIGNED_BYTE, 1, 4);
    b("a", gl_UNSIGNED_BYTE, 1, 4);
    b("r", gl_FLOAT, 4, 1);
    b = vec2(2 * cameraScale).divide(mainCanvasSize);
    var c = vec2(-1).subtract(cameraPos.multiply(b));
    glContext.uniformMatrix4fv(glContext.getUniformLocation(glShader, "m"), false, [b.x, 0, 0, 0, 0, b.y, 0, 0, 1, 1, 1, 1, c.x, c.y, 0, 0]);
  }
};
var glSetTexture = function(a) {
  headlessMode || a == glActiveTexture || (glFlush(), glContext.bindTexture(gl_TEXTURE_2D, glActiveTexture = a));
};
var glCompileShader = function(a, b) {
  b = glContext.createShader(b);
  glContext.shaderSource(b, a);
  glContext.compileShader(b);
  if (debug && !glContext.getShaderParameter(b, gl_COMPILE_STATUS))
    throw glContext.getShaderInfoLog(b);
  return b;
};
var glCreateProgram = function(a, b) {
  const c = glContext.createProgram();
  glContext.attachShader(c, glCompileShader(a, gl_VERTEX_SHADER));
  glContext.attachShader(c, glCompileShader(b, gl_FRAGMENT_SHADER));
  glContext.linkProgram(c);
  if (debug && !glContext.getProgramParameter(c, gl_LINK_STATUS))
    throw glContext.getProgramInfoLog(c);
  return c;
};
var glCreateTexture = function(a) {
  const b = glContext.createTexture();
  glContext.bindTexture(gl_TEXTURE_2D, b);
  a && a.width ? glContext.texImage2D(gl_TEXTURE_2D, 0, gl_RGBA, gl_RGBA, gl_UNSIGNED_BYTE, a) : (a = new Uint8Array([255, 255, 255, 255]), glContext.texImage2D(gl_TEXTURE_2D, 0, gl_RGBA, 1, 1, 0, gl_RGBA, gl_UNSIGNED_BYTE, a));
  a = canvasPixelated ? gl_NEAREST : gl_LINEAR;
  glContext.texParameteri(gl_TEXTURE_2D, gl_TEXTURE_MIN_FILTER, a);
  glContext.texParameteri(gl_TEXTURE_2D, gl_TEXTURE_MAG_FILTER, a);
  return b;
};
var glFlush = function() {
  if (glInstanceCount) {
    var a = glBatchAdditive ? gl_ONE : gl_ONE_MINUS_SRC_ALPHA;
    glContext.blendFuncSeparate(gl_SRC_ALPHA, a, gl_ONE, a);
    glContext.enable(gl_BLEND);
    glContext.bufferSubData(gl_ARRAY_BUFFER, 0, glPositionData);
    glContext.drawArraysInstanced(gl_TRIANGLE_STRIP, 0, 4, glInstanceCount);
    showWatermark && (drawCount += glInstanceCount);
    glInstanceCount = 0;
    glBatchAdditive = glAdditive;
  }
};
var glCopyToContext = function(a, b = false) {
  glEnable && (glInstanceCount || b) && (glFlush(), glOverlay && !b || a.drawImage(glCanvas, 0, 0));
};
var glSetAntialias = function(a = true) {
  ASSERT(!glCanvas, "must be called before engineInit");
  glAntialias = a;
};
var glDraw = function(a, b, c, d, e, f, g, k, h, m, n = 0) {
  ASSERT(typeof m == "number" && typeof n == "number", "invalid color");
  (glInstanceCount >= gl_MAX_INSTANCES || glBatchAdditive != glAdditive) && glFlush();
  let l = glInstanceCount * gl_INDICIES_PER_INSTANCE;
  glPositionData[l++] = a;
  glPositionData[l++] = b;
  glPositionData[l++] = c;
  glPositionData[l++] = d;
  glPositionData[l++] = f;
  glPositionData[l++] = g;
  glPositionData[l++] = k;
  glPositionData[l++] = h;
  glColorData[l++] = m;
  glColorData[l++] = n;
  glPositionData[l++] = e;
  glInstanceCount++;
};
var setPaused = function(a) {
  paused = a;
};
var engineAddPlugin = function(a, b) {
  ASSERT(!pluginUpdateList.includes(a));
  ASSERT(!pluginRenderList.includes(b));
  a && pluginUpdateList.push(a);
  b && pluginRenderList.push(b);
};
var engineInit = function(a, b, c, d, e, f = [], g = document.body) {
  function k(n = 0) {
    var l = n - frameTimeLastMS;
    frameTimeLastMS = n;
    if (debug || showWatermark)
      averageFPS = lerp(0.05, averageFPS, 1000 / (l || 1));
    n = debug && keyIsDown("Equal");
    const p = debug && keyIsDown("Minus");
    debug && (l *= n ? 5 : p ? 0.2 : 1);
    timeReal += l / 1000;
    frameTimeBufferMS += paused ? 0 : l;
    n || (frameTimeBufferMS = min(frameTimeBufferMS, 50));
    h();
    if (paused) {
      for (const r of engineObjects)
        r.parent || r.updateTransforms();
      inputUpdate();
      pluginUpdateList.forEach((r) => r());
      debugUpdate();
      c();
      inputUpdatePost();
    } else {
      l = 0;
      0 > frameTimeBufferMS && -9 < frameTimeBufferMS && (l = frameTimeBufferMS, frameTimeBufferMS = 0);
      for (;0 <= frameTimeBufferMS; frameTimeBufferMS -= 1000 / frameRate)
        time = frame++ / frameRate, inputUpdate(), b(), pluginUpdateList.forEach((r) => r()), engineObjectsUpdate(), debugUpdate(), c(), inputUpdatePost();
      frameTimeBufferMS += l;
    }
    if (!headlessMode) {
      mainCanvasSize = vec2(mainCanvas.width, mainCanvas.height);
      mainContext.imageSmoothingEnabled = !canvasPixelated;
      glPreRender();
      d();
      engineObjects.sort((r, x) => r.renderOrder - x.renderOrder);
      for (var q of engineObjects)
        q.destroyed || q.render();
      e();
      pluginRenderList.forEach((r) => r());
      touchGamepadRender();
      debugRender();
      glCopyToContext(mainContext);
      showWatermark && (overlayContext.textAlign = "right", overlayContext.textBaseline = "top", overlayContext.font = "1em monospace", overlayContext.fillStyle = "#000", q = engineName + " v" + engineVersion + " / " + drawCount + " / " + engineObjects.length + " / " + averageFPS.toFixed(1) + (glEnable ? " GL" : " 2D"), overlayContext.fillText(q, mainCanvas.width - 3, 3), overlayContext.fillStyle = "#fff", overlayContext.fillText(q, mainCanvas.width - 2, 2), drawCount = 0);
    }
    requestAnimationFrame(k);
  }
  function h() {
    if (!headlessMode) {
      if (canvasFixedSize.x) {
        mainCanvas.width = canvasFixedSize.x;
        mainCanvas.height = canvasFixedSize.y;
        const n = innerWidth / innerHeight, l = mainCanvas.width / mainCanvas.height;
        (glCanvas || mainCanvas).style.width = mainCanvas.style.width = overlayCanvas.style.width = n < l ? "100%" : "";
        (glCanvas || mainCanvas).style.height = mainCanvas.style.height = overlayCanvas.style.height = n < l ? "" : "100%";
      } else
        mainCanvas.width = min(innerWidth, canvasMaxSize.x), mainCanvas.height = min(innerHeight, canvasMaxSize.y);
      overlayCanvas.width = mainCanvas.width;
      overlayCanvas.height = mainCanvas.height;
      mainCanvasSize = vec2(mainCanvas.width, mainCanvas.height);
    }
  }
  function m() {
    new Promise((n) => n(a())).then(k);
  }
  ASSERT(Array.isArray(f), "pass in images as array");
  headlessMode ? m() : (g.style.cssText = "margin:0;overflow:hidden;width:100vw;height:100vh;display:flex;align-items:center;justify-content:center;background:#000;user-select:none;-webkit-user-select:none;" + (touchInputEnable ? "touch-action:none;-webkit-touch-callout:none" : ""), g.appendChild(mainCanvas = document.createElement("canvas")), mainContext = mainCanvas.getContext("2d"), inputInit(), audioInit(), debugInit(), glInit(), g.appendChild(overlayCanvas = document.createElement("canvas")), overlayContext = overlayCanvas.getContext("2d"), mainCanvas.style.cssText = overlayCanvas.style.cssText = "position:absolute", glCanvas && (glCanvas.style.cssText = "position:absolute"), h(), g = f.map((n, l) => new Promise((p) => {
    const q = new Image;
    q.onerror = q.onload = () => {
      textureInfos[l] = new TextureInfo(q);
      p();
    };
    q.src = n;
  })), f.length || g.push(new Promise((n) => {
    textureInfos[0] = new TextureInfo(new Image);
    n();
  })), showSplashScreen && g.push(new Promise((n) => {
    function l() {
      clearInput();
      drawEngineSplashScreen(p += 0.01);
      1 < p ? n() : setTimeout(l, 16);
    }
    let p = 0;
    console.log(`${engineName} Engine v${engineVersion}`);
    l();
  })), Promise.all(g).then(m));
};
var engineObjectsUpdate = function() {
  function a(b) {
    if (!b.destroyed) {
      b.update();
      for (const c of b.children)
        a(c);
    }
  }
  engineObjectsCollide = engineObjects.filter((b) => b.collideSolidObjects);
  for (const b of engineObjects)
    b.parent || (a(b), b.updateTransforms());
  engineObjects = engineObjects.filter((b) => !b.destroyed);
};
var engineObjectsDestroy = function() {
  for (const a of engineObjects)
    a.parent || a.destroy();
  engineObjects = engineObjects.filter((a) => !a.destroyed);
};
var engineObjectsCollect = function(a, b, c = engineObjects) {
  const d = [];
  if (a)
    if (b instanceof Vector2)
      for (const e of c)
        isOverlapping(a, b, e.pos, e.size) && d.push(e);
    else {
      b *= b;
      for (const e of c)
        a.distanceSquared(e.pos) < b && d.push(e);
    }
  else
    for (const e of c)
      d.push(e);
  return d;
};
var engineObjectsCallback = function(a, b, c, d = engineObjects) {
  engineObjectsCollect(a, b, d).forEach((e) => c(e));
};
var engineObjectsRaycast = function(a, b, c = engineObjects) {
  const d = [];
  for (const e of c)
    e.collideRaycast && isIntersecting(a, b, e.pos, e.size) && (debugRaycast && debugRect(e.pos, e.size, "#f00"), d.push(e));
  debugRaycast && debugLine(a, b, d.length ? "#f00" : "#00f", 0.02);
  return d;
};
var drawEngineSplashScreen = function(a) {
  const b = overlayContext;
  var c = overlayCanvas.width = innerWidth, d = overlayCanvas.height = innerHeight, e = percent(a, 1, 0.8), f = percent(a, 0, 0.5), g = b.createRadialGradient(c / 2, d / 2, 0, c / 2, d / 2, 0.7 * Math.hypot(c, d));
  g.addColorStop(0, hsl(0, 0, lerp(f, 0, e / 2), e).toString());
  g.addColorStop(1, hsl(0, 0, 0, e).toString());
  b.save();
  b.fillStyle = g;
  b.fillRect(0, 0, c, d);
  g = (h, m, n, l, p) => {
    b.beginPath();
    b.rect(h, m, n, p ? l * k : l);
    (b.fillStyle = p) ? b.fill() : b.stroke();
  };
  f = (h, m, n, l = 0, p = 2 * PI, q, r) => {
    const x = (l + p) / 2;
    l = k * (p - l) / 2;
    b.beginPath();
    r && b.lineTo(h, m);
    b.arc(h, m, n, x - l, x + l);
    (b.fillStyle = q) ? b.fill() : b.stroke();
  };
  e = (h = 0, m = 0) => hsl([0.98, 0.3, 0.57, 0.14][h % 4] - 10, 0.8, [0, 0.3, 0.5, 0.8, 0.9][m]).toString();
  a = wave(1, 1, a);
  const k = percent(a, 0.1, 0.5);
  b.translate(c / 2, d / 2);
  c = min(6, min(c, d) / 99);
  b.scale(c, c);
  b.translate(-40, -35);
  b.lineJoin = b.lineCap = "round";
  b.lineWidth = 0.1 + 1.9 * k;
  c = percent(a, 0.1, 1);
  b.setLineDash([99 * c, 99]);
  g(7, 16, 18, -8, e(2, 2));
  g(7, 8, 18, 4, e(2, 3));
  g(25, 8, 8, 8, e(2, 1));
  g(25, 8, -18, 8);
  g(25, 8, 8, 8);
  g(25, 16, 7, 23, e());
  g(11, 39, 14, -23, e(1, 1));
  g(11, 16, 14, 18, e(1, 2));
  g(11, 16, 14, 8, e(1, 3));
  g(25, 16, -14, 24);
  g(15, 29, 6, -9, e(2, 2));
  f(15, 21, 5, 0, PI / 2, e(2, 4), 1);
  g(21, 21, -6, 9);
  g(37, 14, 9, 6, e(3, 2));
  g(37, 14, 4.5, 6, e(3, 3));
  g(37, 14, 9, 6);
  g(50, 20, 10, -8, e(0, 1));
  g(50, 20, 6.5, -8, e(0, 2));
  g(50, 20, 3.5, -8, e(0, 3));
  g(50, 20, 10, -8);
  f(55, 2, 11.4, 0.5, PI - 0.5, e(3, 3));
  f(55, 2, 11.4, 0.5, PI / 2, e(3, 2), 1);
  f(55, 2, 11.4, 0.5, PI - 0.5);
  g(45, 7, 20, -7, e(0, 2));
  g(45, -1, 20, 4, e(0, 3));
  g(45, -1, 20, 8);
  for (c = 5;c--; )
    f(60 - 6 * c, 30, 9.9, 0, 2 * PI, e(c + 2, 3)), f(60 - 6 * c, 30, 10, -0.5, PI + 0.5, e(c + 2, 2)), f(60 - 6 * c, 30, 10.1, 0.5, PI - 0.5, e(c + 2, 1));
  f(36, 30, 10, PI / 2, 3 * PI / 2);
  f(48, 30, 10, PI / 2, 3 * PI / 2);
  f(60, 30, 10);
  b.beginPath();
  b.lineTo(36, 20);
  b.lineTo(60, 20);
  b.stroke();
  f(60, 30, 4, PI, 3 * PI, e(3, 2));
  f(60, 30, 4, PI, 2 * PI, e(3, 3));
  f(60, 30, 4, PI, 3 * PI);
  for (c = 6;c--; )
    b.beginPath(), b.lineTo(53, 54), b.lineTo(53, 40), b.lineTo(53 + (1 + 2.9 * c) * k, 40), b.lineTo(53 + (4 + 3.5 * c) * k, 54), b.fillStyle = e(0, c % 2 + 2), b.fill(), c % 2 && b.stroke();
  g(6, 40, 5, 5);
  g(6, 40, 5, 5, e());
  g(15, 54, 38, -14, e());
  for (g = 3;g--; )
    for (c = 2;c--; )
      f(15 * g + 15, 47, c ? 7 : 1, PI, 3 * PI, e(g, 3)), b.stroke(), f(15 * g + 15, 47, c ? 7 : 1, 0, PI, e(g, 2)), b.stroke();
  b.beginPath();
  b.lineTo(6, 40);
  b.lineTo(68, 40);
  b.stroke();
  b.beginPath();
  b.lineTo(77, 54);
  b.lineTo(4, 54);
  b.stroke();
  f = engineName;
  b.font = "900 16px arial";
  b.textAlign = "center";
  b.textBaseline = "top";
  b.lineWidth = 0.1 + 3.9 * k;
  g = 0;
  for (c = 0;c < f.length; ++c)
    g += b.measureText(f[c]).width;
  for (c = 2;c--; )
    for (let h = 0, m = 41 - g / 2;h < f.length; ++h)
      b.fillStyle = e(h, 2), d = b.measureText(f[h]).width, b[c ? "strokeText" : "fillText"](f[h], m + d / 2, 55.5, 17 * k), m += d;
  b.restore();
};
var showWatermark = 0;
var debugKey = "";
var debug = 0;
var debugOverlay = 0;
var debugPhysics = 0;
var debugParticles = 0;
var debugRaycast = 0;
var debugMedals = 0;
var PI = Math.PI;

class RandomGenerator {
  constructor(a) {
    this.seed = a;
  }
  float(a = 1, b = 0) {
    this.seed ^= this.seed << 13;
    this.seed ^= this.seed >>> 17;
    this.seed ^= this.seed << 5;
    return b + (a - b) * abs(this.seed % 1e8) / 1e8;
  }
  int(a, b = 0) {
    return Math.floor(this.float(a, b));
  }
  sign() {
    return 0.5 < this.float() ? 1 : -1;
  }
}

class Vector2 {
  constructor(a = 0, b = 0) {
    this.x = a;
    this.y = b;
    ASSERT(this.isValid());
  }
  set(a = 0, b = 0) {
    this.x = a;
    this.y = b;
    ASSERT(this.isValid());
    return this;
  }
  copy() {
    return new Vector2(this.x, this.y);
  }
  add(a) {
    ASSERT(isVector2(a));
    return new Vector2(this.x + a.x, this.y + a.y);
  }
  subtract(a) {
    ASSERT(isVector2(a));
    return new Vector2(this.x - a.x, this.y - a.y);
  }
  multiply(a) {
    ASSERT(isVector2(a));
    return new Vector2(this.x * a.x, this.y * a.y);
  }
  divide(a) {
    ASSERT(isVector2(a));
    return new Vector2(this.x / a.x, this.y / a.y);
  }
  scale(a) {
    ASSERT(!isVector2(a));
    return new Vector2(this.x * a, this.y * a);
  }
  length() {
    return this.lengthSquared() ** 0.5;
  }
  lengthSquared() {
    return this.x ** 2 + this.y ** 2;
  }
  distance(a) {
    ASSERT(isVector2(a));
    return this.distanceSquared(a) ** 0.5;
  }
  distanceSquared(a) {
    ASSERT(isVector2(a));
    return (this.x - a.x) ** 2 + (this.y - a.y) ** 2;
  }
  normalize(a = 1) {
    const b = this.length();
    return b ? this.scale(a / b) : new Vector2(0, a);
  }
  clampLength(a = 1) {
    const b = this.length();
    return b > a ? this.scale(a / b) : this;
  }
  dot(a) {
    ASSERT(isVector2(a));
    return this.x * a.x + this.y * a.y;
  }
  cross(a) {
    ASSERT(isVector2(a));
    return this.x * a.y - this.y * a.x;
  }
  angle() {
    return Math.atan2(this.x, this.y);
  }
  setAngle(a = 0, b = 1) {
    this.x = b * Math.sin(a);
    this.y = b * Math.cos(a);
    return this;
  }
  rotate(a) {
    const b = Math.cos(a);
    a = Math.sin(a);
    return new Vector2(this.x * b - this.y * a, this.x * a + this.y * b);
  }
  setDirection(a, b = 1) {
    a = mod(a, 4);
    ASSERT(a == 0 || a == 1 || a == 2 || a == 3);
    return vec2(a % 2 ? a - 1 ? -b : b : 0, a % 2 ? 0 : a ? -b : b);
  }
  direction() {
    return abs(this.x) > abs(this.y) ? 0 > this.x ? 3 : 1 : 0 > this.y ? 2 : 0;
  }
  invert() {
    return new Vector2(this.y, -this.x);
  }
  floor() {
    return new Vector2(Math.floor(this.x), Math.floor(this.y));
  }
  area() {
    return abs(this.x * this.y);
  }
  lerp(a, b) {
    ASSERT(isVector2(a));
    return this.add(a.subtract(this).scale(clamp(b)));
  }
  arrayCheck(a) {
    ASSERT(isVector2(a));
    return 0 <= this.x && 0 <= this.y && this.x < a.x && this.y < a.y;
  }
  toString(a = 3) {
    if (debug)
      return `(${(0 > this.x ? "" : " ") + this.x.toFixed(a)},${(0 > this.y ? "" : " ") + this.y.toFixed(a)} )`;
  }
  isValid() {
    return typeof this.x == "number" && !isNaN(this.x) && typeof this.y == "number" && !isNaN(this.y);
  }
}

class Color {
  constructor(a = 1, b = 1, c = 1, d = 1) {
    this.r = a;
    this.g = b;
    this.b = c;
    this.a = d;
    ASSERT(this.isValid());
  }
  set(a = 1, b = 1, c = 1, d = 1) {
    this.r = a;
    this.g = b;
    this.b = c;
    this.a = d;
    ASSERT(this.isValid());
    return this;
  }
  copy() {
    return new Color(this.r, this.g, this.b, this.a);
  }
  add(a) {
    ASSERT(isColor(a));
    return new Color(this.r + a.r, this.g + a.g, this.b + a.b, this.a + a.a);
  }
  subtract(a) {
    ASSERT(isColor(a));
    return new Color(this.r - a.r, this.g - a.g, this.b - a.b, this.a - a.a);
  }
  multiply(a) {
    ASSERT(isColor(a));
    return new Color(this.r * a.r, this.g * a.g, this.b * a.b, this.a * a.a);
  }
  divide(a) {
    ASSERT(isColor(a));
    return new Color(this.r / a.r, this.g / a.g, this.b / a.b, this.a / a.a);
  }
  scale(a, b = a) {
    return new Color(this.r * a, this.g * a, this.b * a, this.a * b);
  }
  clamp() {
    return new Color(clamp(this.r), clamp(this.g), clamp(this.b), clamp(this.a));
  }
  lerp(a, b) {
    ASSERT(isColor(a));
    return this.add(a.subtract(this).scale(clamp(b)));
  }
  setHSLA(a = 0, b = 0, c = 1, d = 1) {
    a = mod(a, 1);
    b = clamp(b);
    c = clamp(c);
    b = 0.5 > c ? c * (1 + b) : c + b - c * b;
    c = 2 * c - b;
    const e = (f, g, k) => 1 > 6 * (k = mod(k, 1)) ? f + 6 * (g - f) * k : 1 > 2 * k ? g : 2 > 3 * k ? f + (g - f) * (4 - 6 * k) : f;
    this.r = e(c, b, a + 1 / 3);
    this.g = e(c, b, a);
    this.b = e(c, b, a - 1 / 3);
    this.a = d;
    ASSERT(this.isValid());
    return this;
  }
  HSLA() {
    const a = clamp(this.r), b = clamp(this.g), c = clamp(this.b), d = clamp(this.a), e = Math.max(a, b, c), f = Math.min(a, b, c), g = (e + f) / 2;
    let k = 0, h = 0;
    if (e != f) {
      let m = e - f;
      h = 0.5 < g ? m / (2 - e - f) : m / (e + f);
      a == e ? k = (b - c) / m + (b < c ? 6 : 0) : b == e ? k = (c - a) / m + 2 : c == e && (k = (a - b) / m + 4);
    }
    return [k / 6, h, g, d];
  }
  mutate(a = 0.05, b = 0) {
    return new Color(this.r + rand(a, -a), this.g + rand(a, -a), this.b + rand(a, -a), this.a + rand(b, -b)).clamp();
  }
  toString(a = true) {
    const b = (c) => (16 > (c = 255 * clamp(c) | 0) ? "0" : "") + c.toString(16);
    return "#" + b(this.r) + b(this.g) + b(this.b) + (a ? b(this.a) : "");
  }
  setHex(a) {
    ASSERT(typeof a == "string" && a[0] == "#");
    ASSERT([4, 5, 7, 9].includes(a.length), "Invalid hex");
    6 > a.length ? (this.r = clamp(parseInt(a[1], 16) / 15), this.g = clamp(parseInt(a[2], 16) / 15), this.b = clamp(parseInt(a[3], 16) / 15), this.a = a.length == 5 ? clamp(parseInt(a[4], 16) / 15) : 1) : (this.r = clamp(parseInt(a.slice(1, 3), 16) / 255), this.g = clamp(parseInt(a.slice(3, 5), 16) / 255), this.b = clamp(parseInt(a.slice(5, 7), 16) / 255), this.a = a.length == 9 ? clamp(parseInt(a.slice(7, 9), 16) / 255) : 1);
    ASSERT(this.isValid());
    return this;
  }
  rgbaInt() {
    const a = 255 * clamp(this.r) | 0, b = 255 * clamp(this.g) << 8, c = 255 * clamp(this.b) << 16, d = 255 * clamp(this.a) << 24;
    return a + b + c + d;
  }
  isValid() {
    return typeof this.r == "number" && !isNaN(this.r) && typeof this.g == "number" && !isNaN(this.g) && typeof this.b == "number" && !isNaN(this.b) && typeof this.a == "number" && !isNaN(this.a);
  }
}
var WHITE = rgb();
var BLACK = rgb(0, 0, 0);
var GRAY = rgb(0.5, 0.5, 0.5);
var RED = rgb(1, 0, 0);
var ORANGE = rgb(1, 0.5, 0);
var YELLOW = rgb(1, 1, 0);
var GREEN = rgb(0, 1, 0);
var CYAN = rgb(0, 1, 1);
var BLUE = rgb(0, 0, 1);
var PURPLE = rgb(0.5, 0, 1);
var MAGENTA = rgb(1, 0, 1);

class Timer {
  constructor(a) {
    this.time = a == undefined ? undefined : time + a;
    this.setTime = a;
  }
  set(a = 0) {
    this.time = time + a;
    this.setTime = a;
  }
  unset() {
    this.time = undefined;
  }
  isSet() {
    return this.time != null;
  }
  active() {
    return time < this.time;
  }
  elapsed() {
    return time >= this.time;
  }
  get() {
    return this.isSet() ? time - this.time : 0;
  }
  getPercent() {
    return this.isSet() ? percent(this.time - time, this.setTime, 0) : 0;
  }
  toString() {
    if (debug)
      return this.isSet() ? Math.abs(this.get()) + " seconds " + (0 > this.get() ? "before" : "after") : "unset";
  }
  valueOf() {
    return this.get();
  }
}
var cameraPos = vec2();
var cameraScale = 32;
var canvasMaxSize = vec2(1920, 1080);
var canvasFixedSize = vec2();
var canvasPixelated = true;
var fontDefault = "arial";
var showSplashScreen = false;
var headlessMode = false;
var glEnable = true;
var glOverlay = true;
var tileSizeDefault = vec2(16);
var tileFixBleedScale = 0;
var enablePhysicsSolver = true;
var objectDefaultMass = 1;
var objectDefaultDamping = 1;
var objectDefaultAngleDamping = 1;
var objectDefaultElasticity = 0;
var objectDefaultFriction = 0.8;
var objectMaxSpeed = 1;
var gravity = 0;
var particleEmitRateScale = 1;
var gamepadsEnable = true;
var gamepadDirectionEmulateStick = true;
var inputWASDEmulateDirection = true;
var touchInputEnable = true;
var touchGamepadEnable = false;
var touchGamepadAnalog = true;
var touchGamepadSize = 99;
var touchGamepadAlpha = 0.3;
var vibrateEnable = true;
var soundEnable = true;
var soundVolume = 0.3;
var soundDefaultRange = 40;
var soundDefaultTaper = 0.7;
var medalDisplayTime = 5;
var medalDisplaySlideTime = 0.5;
var medalDisplaySize = vec2(640, 80);
var medalDisplayIconSize = 50;
var medalsPreventUnlock = false;

class EngineObject {
  constructor(a = vec2(), b = vec2(1), c, d = 0, e = new Color, f = 0) {
    ASSERT(isVector2(a) && isVector2(b), "ensure pos and size are vec2s");
    ASSERT(typeof c !== "number" || !c, "old style tile setup");
    this.pos = a.copy();
    this.size = b;
    this.drawSize = undefined;
    this.tileInfo = c;
    this.angle = d;
    this.color = e;
    this.additiveColor = undefined;
    this.mirror = false;
    this.mass = objectDefaultMass;
    this.damping = objectDefaultDamping;
    this.angleDamping = objectDefaultAngleDamping;
    this.elasticity = objectDefaultElasticity;
    this.friction = objectDefaultFriction;
    this.gravityScale = 1;
    this.renderOrder = f;
    this.velocity = vec2();
    this.angleVelocity = 0;
    this.spawnTime = time;
    this.children = [];
    this.clampSpeedLinear = true;
    this.parent = undefined;
    this.localPos = vec2();
    this.localAngle = 0;
    this.collideRaycast = this.isSolid = this.collideSolidObjects = this.collideTiles = false;
    engineObjects.push(this);
  }
  updateTransforms() {
    const a = this.parent;
    if (a) {
      const b = a.getMirrorSign();
      this.pos = this.localPos.multiply(vec2(b, 1)).rotate(-a.angle).add(a.pos);
      this.angle = b * this.localAngle + a.angle;
    }
    for (const b of this.children)
      b.updateTransforms();
  }
  update() {
    if (!this.parent) {
      if (this.clampSpeedLinear)
        this.velocity.x = clamp(this.velocity.x, -objectMaxSpeed, objectMaxSpeed), this.velocity.y = clamp(this.velocity.y, -objectMaxSpeed, objectMaxSpeed);
      else {
        var a = this.velocity.lengthSquared();
        a > objectMaxSpeed * objectMaxSpeed && (a = objectMaxSpeed / a ** 0.5, this.velocity.x *= a, this.velocity.y *= a);
      }
      a = this.pos.copy();
      this.velocity.x *= this.damping;
      this.velocity.y *= this.damping;
      this.mass && (this.velocity.y += gravity * this.gravityScale);
      this.pos.x += this.velocity.x;
      this.pos.y += this.velocity.y;
      this.angle += this.angleVelocity *= this.angleDamping;
      ASSERT(0 <= this.angleDamping && 1 >= this.angleDamping);
      ASSERT(0 <= this.damping && 1 >= this.damping);
      if (enablePhysicsSolver && this.mass) {
        var b = 0 > this.velocity.y;
        if (this.groundObject) {
          var c = this.groundObject.velocity ? this.groundObject.velocity.x : 0;
          this.velocity.x = c + (this.velocity.x - c) * this.friction;
          this.groundObject = 0;
        }
        if (this.collideSolidObjects)
          for (var d of engineObjectsCollide) {
            if (!this.isSolid && !d.isSolid || d.destroyed || d.parent || d == this)
              continue;
            if (!isOverlapping(this.pos, this.size, d.pos, d.size))
              continue;
            c = this.collideWithObject(d);
            var e = d.collideWithObject(this);
            if (!c || !e)
              continue;
            if (isOverlapping(a, this.size, d.pos, d.size)) {
              c = a.subtract(d.pos);
              e = c.length();
              c = 0.01 > e ? randVector(0.001) : c.scale(0.001 / e);
              this.velocity = this.velocity.add(c);
              d.mass && (d.velocity = d.velocity.subtract(c));
              debugOverlay && debugPhysics && debugOverlap(this.pos, this.size, d.pos, d.size, "#f00");
              continue;
            }
            e = this.size.add(d.size);
            var f = 2 * (a.y - d.pos.y) > e.y + gravity;
            const k = 2 * abs(a.y - d.pos.y) < e.y;
            var g = 2 * abs(a.x - d.pos.x) < e.x;
            c = max(this.elasticity, d.elasticity);
            if (f || g || !k) {
              if (this.pos.y = d.pos.y + (e.y / 2 + 0.001) * sign(a.y - d.pos.y), d.groundObject && b || !d.mass)
                b && (this.groundObject = d), this.velocity.y *= -c;
              else if (d.mass) {
                g = (this.mass * this.velocity.y + d.mass * d.velocity.y) / (this.mass + d.mass);
                const h = d.velocity.y * (d.mass - this.mass) / (this.mass + d.mass) + 2 * this.velocity.y * this.mass / (this.mass + d.mass);
                this.velocity.y = lerp(c, g, this.velocity.y * (this.mass - d.mass) / (this.mass + d.mass) + 2 * d.velocity.y * d.mass / (this.mass + d.mass));
                d.velocity.y = lerp(c, g, h);
              }
            }
            !f && k && (this.pos.x = d.pos.x + (e.x / 2 + 0.001) * sign(a.x - d.pos.x), d.mass ? (e = (this.mass * this.velocity.x + d.mass * d.velocity.x) / (this.mass + d.mass), f = d.velocity.x * (d.mass - this.mass) / (this.mass + d.mass) + 2 * this.velocity.x * this.mass / (this.mass + d.mass), this.velocity.x = lerp(c, e, this.velocity.x * (this.mass - d.mass) / (this.mass + d.mass) + 2 * d.velocity.x * d.mass / (this.mass + d.mass)), d.velocity.x = lerp(c, e, f)) : this.velocity.x *= -c);
            debugOverlay && debugPhysics && debugOverlap(this.pos, this.size, d.pos, d.size, "#f0f");
          }
        if (this.collideTiles && tileCollisionTest(this.pos, this.size, this) && !tileCollisionTest(a, this.size, this)) {
          d = tileCollisionTest(vec2(a.x, this.pos.y), this.size, this);
          c = tileCollisionTest(vec2(this.pos.x, a.y), this.size, this);
          if (d || !c)
            this.velocity.y *= -this.elasticity, (this.groundObject = b) ? this.pos.y = (a.y - this.size.y / 2 | 0) + this.size.y / 2 + 0.0001 : this.pos.y = a.y;
          c && (this.pos.x = a.x, this.velocity.x *= -this.elasticity);
          debugOverlay && debugPhysics && debugRect(this.pos, this.size, "#f00");
        }
      }
    }
  }
  render() {
    drawTile(this.pos, this.drawSize || this.size, this.tileInfo, this.color, this.angle, this.mirror, this.additiveColor);
  }
  destroy() {
    if (!this.destroyed) {
      this.destroyed = 1;
      this.parent && this.parent.removeChild(this);
      for (const a of this.children)
        a.destroy(a.parent = 0);
    }
  }
  localToWorld(a) {
    return this.pos.add(a.rotate(-this.angle));
  }
  worldToLocal(a) {
    return a.subtract(this.pos).rotate(this.angle);
  }
  localToWorldVector(a) {
    return a.rotate(this.angle);
  }
  worldToLocalVector(a) {
    return a.rotate(-this.angle);
  }
  collideWithTile(a, b) {
    return 0 < a;
  }
  collideWithObject(a) {
    return true;
  }
  getAliveTime() {
    return time - this.spawnTime;
  }
  applyAcceleration(a) {
    this.mass && (this.velocity = this.velocity.add(a));
  }
  applyForce(a) {
    this.applyAcceleration(a.scale(1 / this.mass));
  }
  getMirrorSign() {
    return this.mirror ? -1 : 1;
  }
  addChild(a, b = vec2(), c = 0) {
    ASSERT(!a.parent && !this.children.includes(a));
    this.children.push(a);
    a.parent = this;
    a.localPos = b.copy();
    a.localAngle = c;
  }
  removeChild(a) {
    ASSERT(a.parent == this && this.children.includes(a));
    this.children.splice(this.children.indexOf(a), 1);
    a.parent = 0;
  }
  setCollision(a = true, b = true, c = true, d = true) {
    ASSERT(a || !b, "solid objects must be set to collide");
    this.collideSolidObjects = a;
    this.isSolid = b;
    this.collideTiles = c;
    this.collideRaycast = d;
  }
  toString() {
    if (debug) {
      let a = "type = " + this.constructor.name;
      if (this.pos.x || this.pos.y)
        a += "\npos = " + this.pos;
      if (this.velocity.x || this.velocity.y)
        a += "\nvelocity = " + this.velocity;
      if (this.size.x || this.size.y)
        a += "\nsize = " + this.size;
      this.angle && (a += "\nangle = " + this.angle.toFixed(3));
      this.color && (a += "\ncolor = " + this.color);
      return a;
    }
  }
  renderDebugInfo() {
    if (debug) {
      const a = vec2(max(this.size.x, 0.2), max(this.size.y, 0.2)), b = rgb(this.collideTiles ? 1 : 0, this.collideSolidObjects ? 1 : 0, this.isSolid ? 1 : 0, this.parent ? 0.2 : 0.5), c = this.parent ? rgb(1, 1, 1, 0.5) : rgb(0, 0, 0, 0.8);
      drawRect(this.pos, a, b, this.angle, false);
      drawRect(this.pos, a.scale(0.8), c, this.angle, false);
      this.parent && drawLine(this.pos, this.parent.pos, 0.1, rgb(0, 0, 1, 0.5), false);
    }
  }
}
var mainCanvas;
var mainContext;
var overlayCanvas;
var overlayContext;
var mainCanvasSize = vec2();
var textureInfos = [];
var drawCount;

class TileInfo {
  constructor(a = vec2(), b = tileSizeDefault, c = 0, d = 0) {
    this.pos = a.copy();
    this.size = b.copy();
    this.textureIndex = c;
    this.padding = d;
  }
  offset(a) {
    return new TileInfo(this.pos.add(a), this.size, this.textureIndex);
  }
  frame(a) {
    ASSERT(typeof a == "number");
    return this.offset(vec2(a * (this.size.x + 2 * this.padding), 0));
  }
  getTextureInfo() {
    return textureInfos[this.textureIndex];
  }
}

class TextureInfo {
  constructor(a) {
    this.image = a;
    this.size = vec2(a.width, a.height);
    this.glTexture = glEnable && glCreateTexture(a);
  }
}
var engineFontImage;

class FontImage {
  constructor(a, b = vec2(8), c = vec2(0, 1), d = overlayContext) {
    engineFontImage || ((engineFontImage = new Image).src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAYAQAAAAA9+x6JAAAAAnRSTlMAAHaTzTgAAAGiSURBVHjaZZABhxxBEIUf6ECLBdFY+Q0PMNgf0yCgsSAGZcT9sgIPtBWwIA5wgAPEoHUyJeeSlW+gjK+fegWwtROWpVQEyWh2npdpBmTUFVhb29RINgLIukoXr5LIAvYQ5ve+1FqWEMqNKTX3FAJHyQDRZvmKWubAACcv5z5Gtg2oyCWE+Yk/8JZQX1jTTCpKAFGIgza+dJCNBF2UskRlsgwitHbSV0QLgt9sTPtsRlvJjEr8C/FARWA2bJ/TtJ7lko34dNDn6usJUMzuErP89UUBJbWeozrwLLncXczd508deAjLWipLO4Q5XGPcJvPu92cNDaN0P5G1FL0nSOzddZOrJ6rNhbXGmeDvO3TF7DeJWl4bvaYQTNHCTeuqKZmbjHaSOFes+IX/+IhHrnAkXOAsfn24EM68XieIECoccD4KZLk/odiwzeo2rovYdhvb2HYFgyznJyDpYJdYOmfXgVdJTaUi4xA2uWYNYec9BLeqdl9EsoTw582mSFDX2DxVLbNt9U3YYoeatBad1c2Tj8t2akrjaIGJNywKB/7h75/gN3vCMSaadIUTAAAAAElFTkSuQmCC");
    this.image = a || engineFontImage;
    this.tileSize = b;
    this.paddingSize = c;
    this.context = d;
  }
  drawText(a, b, c = 1, d) {
    this.drawTextScreen(a, worldToScreen(b).floor(), c * cameraScale | 0, d);
  }
  drawTextScreen(a, b, c = 4, d) {
    const e = this.context;
    e.save();
    e.imageSmoothingEnabled = !canvasPixelated;
    const f = this.tileSize, g = f.add(this.paddingSize).scale(c), k = this.image.width / this.tileSize.x | 0;
    (a + "").split("\n").forEach((h, m) => {
      const n = d ? h.length * f.x * c / 2 | 0 : 0;
      for (let q = h.length;q--; ) {
        var l = h[q].charCodeAt(0);
        if (32 > l || 127 < l)
          l = 127;
        var p = l - 32;
        l = p % k;
        p = p / k | 0;
        const r = b.add(vec2(q, m).multiply(g));
        e.drawImage(this.image, l * f.x, p * f.y, f.x, f.y, r.x - n, r.y, f.x * c, f.y * c);
      }
    });
    e.restore();
  }
}
var mouseIsDown = keyIsDown;
var mouseWasPressed = keyWasPressed;
var mouseWasReleased = keyWasReleased;
var mousePos = vec2();
var mousePosScreen = vec2();
var mouseWheel = 0;
var isUsingGamepad = false;
var preventDefaultInput = false;
var inputData = [[]];
var gamepadStickData = [];
var isTouchDevice = window.ontouchstart !== undefined;
var touchGamepadTimer = new Timer;
var touchGamepadButtons;
var touchGamepadStick;
var audioContext = new AudioContext;
var audioGainNode;

class Sound {
  constructor(a, b = soundDefaultRange, c = soundDefaultTaper) {
    soundEnable && !headlessMode && (this.range = b, this.taper = c, this.randomness = 0, this.gainNode = audioContext.createGain(), a && (this.randomness = a[1] != null ? a[1] : 0.05, a[1] = 0, this.sampleChannels = [zzfxG(...a)], this.sampleRate = zzfxR));
  }
  play(a, b = 1, c = 1, d = 1, e = false) {
    if (soundEnable && !headlessMode && this.sampleChannels) {
      var f;
      if (a) {
        if (f = this.range) {
          const g = cameraPos.distanceSquared(a);
          if (g > f * f)
            return;
          b *= percent(g ** 0.5, f, f * this.taper);
        }
        f = 2 * worldToScreen(a).x / mainCanvas.width - 1;
      }
      a = c + c * this.randomness * d * rand(-1, 1);
      return this.source = playSamples(this.sampleChannels, b, a, f, e, this.sampleRate, this.gainNode);
    }
  }
  setVolume(a = 1) {
    this.gainNode.gain.value = a;
  }
  stop() {
    this.source && this.source.stop();
    this.source = undefined;
  }
  getSource() {
    return this.source;
  }
  playNote(a, b, c) {
    return this.play(b, c, 2 ** (a / 12), 0);
  }
  getDuration() {
    return this.sampleChannels && this.sampleChannels[0].length / this.sampleRate;
  }
  isLoading() {
    return !this.sampleChannels;
  }
}

class SoundWave extends Sound {
  constructor(a, b = 0, c, d, e) {
    super(undefined, c, d);
    soundEnable && !headlessMode && (this.randomness = b, fetch(a).then((f) => f.arrayBuffer()).then((f) => audioContext.decodeAudioData(f)).then((f) => {
      this.sampleChannels = [];
      for (let g = f.numberOfChannels;g--; )
        this.sampleChannels[g] = Array.from(f.getChannelData(g));
      this.sampleRate = f.sampleRate;
    }).then(() => e && e(this)));
  }
}

class Music extends Sound {
  constructor(a) {
    super(undefined);
    soundEnable && !headlessMode && (this.randomness = 0, this.sampleChannels = zzfxM(...a), this.sampleRate = zzfxR);
  }
  playMusic(a, b = false) {
    return super.play(undefined, a, 1, 1, b);
  }
}
var zzfxR = 44100;
var tileCollision = [];
var tileCollisionSize = vec2();

class TileLayerData {
  constructor(a, b = 0, c = false, d = new Color) {
    this.tile = a;
    this.direction = b;
    this.mirror = c;
    this.color = d;
  }
  clear() {
    this.tile = this.direction = 0;
    this.mirror = false;
    this.color = new Color;
  }
}

class TileLayer extends EngineObject {
  constructor(a, b = tileCollisionSize, c = tile(), d = vec2(1), e = 0) {
    super(a, b, c, 0, undefined, e);
    this.canvas = document.createElement("canvas");
    this.context = this.canvas.getContext("2d");
    this.scale = d;
    this.isOverlay = false;
    this.data = [];
    for (a = this.size.area();a--; )
      this.data.push(new TileLayerData);
    headlessMode && (this.redraw = () => {
    }, this.render = () => {
    }, this.redrawStart = () => {
    }, this.redrawEnd = () => {
    }, this.drawTileData = () => {
    }, this.drawCanvas2D = () => {
    });
  }
  setData(a, b, c = false) {
    a.arrayCheck(this.size) && (this.data[(a.y | 0) * this.size.x + a.x | 0] = b, c && this.drawTileData(a));
  }
  getData(a) {
    return a.arrayCheck(this.size) && this.data[(a.y | 0) * this.size.x + a.x | 0];
  }
  update() {
  }
  render() {
    ASSERT(mainContext != this.context, "must call redrawEnd() after drawing tiles");
    glOverlay || this.isOverlay || glCopyToContext(mainContext);
    const a = worldToScreen(this.pos.add(vec2(0, this.size.y * this.scale.y)));
    (this.isOverlay ? overlayContext : mainContext).drawImage(this.canvas, a.x, a.y, cameraScale * this.size.x * this.scale.x, cameraScale * this.size.y * this.scale.y);
  }
  redraw() {
    this.redrawStart(true);
    for (let a = this.size.x;a--; )
      for (let b = this.size.y;b--; )
        this.drawTileData(vec2(a, b), false);
    this.redrawEnd();
  }
  redrawStart(a = false) {
    this.savedRenderSettings = [mainCanvas, mainContext, mainCanvasSize, cameraPos, cameraScale];
    mainCanvas = this.canvas;
    mainContext = this.context;
    mainCanvasSize = this.size.multiply(this.tileInfo.size);
    cameraPos = this.size.scale(0.5);
    cameraScale = this.tileInfo.size.x;
    a && (mainCanvas.width = mainCanvasSize.x, mainCanvas.height = mainCanvasSize.y);
    this.context.imageSmoothingEnabled = !canvasPixelated;
    glPreRender();
  }
  redrawEnd() {
    ASSERT(mainContext == this.context, "must call redrawStart() before drawing tiles");
    glCopyToContext(mainContext, true);
    [mainCanvas, mainContext, mainCanvasSize, cameraPos, cameraScale] = this.savedRenderSettings;
  }
  drawTileData(a, b = true) {
    var c = this.tileInfo.size;
    b && (b = a.multiply(c), this.context.clearRect(b.x, this.canvas.height - b.y, c.x, -c.y));
    b = this.getData(a);
    b.tile != null && (ASSERT(mainContext == this.context, "must call redrawStart() before drawing tiles"), a = a.add(vec2(0.5)), c = tile(b.tile, c, this.tileInfo.textureIndex), drawTile(a, vec2(1), c, b.color, b.direction * PI / 2, b.mirror));
  }
  drawCanvas2D(a, b, c, d, e) {
    const f = this.context;
    f.save();
    a = a.subtract(this.pos).multiply(this.tileInfo.size);
    b = b.multiply(this.tileInfo.size);
    f.translate(a.x, this.canvas.height - a.y);
    f.rotate(c);
    f.scale(d ? -b.x : b.x, b.y);
    e(f);
    f.restore();
  }
  drawTile(a, b = vec2(1), c, d = new Color, e, f) {
    this.drawCanvas2D(a, b, e, f, (g) => {
      const k = c && c.getTextureInfo();
      k ? (g.globalAlpha = d.a, g.drawImage(k.image, c.pos.x, c.pos.y, c.size.x, c.size.y, -0.5, -0.5, 1, 1), g.globalAlpha = 1) : (g.fillStyle = d, g.fillRect(-0.5, -0.5, 1, 1));
    });
  }
  drawRect(a, b, c, d) {
    this.drawTile(a, b, undefined, c, d);
  }
}

class ParticleEmitter extends EngineObject {
  constructor(a, b, c = 0, d = 0, e = 100, f = PI, g, k = new Color, h = new Color, m = new Color(1, 1, 1, 0), n = new Color(1, 1, 1, 0), l = 0.5, p = 0.1, q = 1, r = 0.1, x = 0.05, v = 1, D = 1, z = 0, E = PI, A = 0.1, w = 0.2, t = false, F = false, C = true, y = F ? 1e9 : 0, G = false) {
    super(a, vec2(), g, b, undefined, y);
    this.emitSize = c;
    this.emitTime = d;
    this.emitRate = e;
    this.emitConeAngle = f;
    this.colorStartA = k;
    this.colorStartB = h;
    this.colorEndA = m;
    this.colorEndB = n;
    this.randomColorLinear = C;
    this.particleTime = l;
    this.sizeStart = p;
    this.sizeEnd = q;
    this.speed = r;
    this.angleSpeed = x;
    this.damping = v;
    this.angleDamping = D;
    this.gravityScale = z;
    this.particleConeAngle = E;
    this.fadeRate = A;
    this.randomness = w;
    this.collideTiles = t;
    this.additive = F;
    this.localSpace = G;
    this.trailScale = 0;
    this.particleCreateCallback = this.particleDestroyCallback = undefined;
    this.emitTimeBuffer = 0;
  }
  update() {
    this.parent && super.update();
    if (!this.emitTime || this.getAliveTime() <= this.emitTime) {
      if (this.emitRate * particleEmitRateScale) {
        const a = 1 / this.emitRate / particleEmitRateScale;
        for (this.emitTimeBuffer += timeDelta;0 < this.emitTimeBuffer; this.emitTimeBuffer -= a)
          this.emitParticle();
      }
    } else
      this.destroy();
    debugParticles && debugRect(this.pos, vec2(this.emitSize), "#0f0", 0, this.angle);
  }
  emitParticle() {
    var a = typeof this.emitSize === "number" ? randInCircle(this.emitSize / 2) : vec2(rand(-0.5, 0.5), rand(-0.5, 0.5)).multiply(this.emitSize).rotate(this.angle);
    let b = rand(this.particleConeAngle, -this.particleConeAngle);
    this.localSpace || (a = this.pos.add(a), b += this.angle);
    const c = this.randomness;
    var d = (l) => l + l * rand(c, -c);
    const e = d(this.particleTime), f = d(this.sizeStart), g = d(this.sizeEnd), k = d(this.speed);
    d = d(this.angleSpeed) * randSign();
    var h = rand(this.emitConeAngle, -this.emitConeAngle);
    const m = randColor(this.colorStartA, this.colorStartB, this.randomColorLinear), n = randColor(this.colorEndA, this.colorEndB, this.randomColorLinear);
    h = this.localSpace ? h : this.angle + h;
    a = new Particle(a, this.tileInfo, b, m, n, e, f, g, this.fadeRate, this.additive, this.trailScale, this.localSpace && this, this.particleDestroyCallback);
    a.velocity = vec2().setAngle(h, k);
    a.angleVelocity = d;
    a.fadeRate = this.fadeRate;
    a.damping = this.damping;
    a.angleDamping = this.angleDamping;
    a.elasticity = this.elasticity;
    a.friction = this.friction;
    a.gravityScale = this.gravityScale;
    a.collideTiles = this.collideTiles;
    a.renderOrder = this.renderOrder;
    a.mirror = !!randInt(2);
    this.particleCreateCallback && this.particleCreateCallback(a);
    return a;
  }
  render() {
  }
}

class Particle extends EngineObject {
  constructor(a, b, c, d, e, f, g, k, h, m, n, l, p) {
    super(a, vec2(), b, c);
    this.colorStart = d;
    this.colorEndDelta = e.subtract(d);
    this.lifeTime = f;
    this.sizeStart = g;
    this.sizeEndDelta = k - g;
    this.fadeRate = h;
    this.additive = m;
    this.trailScale = n;
    this.localSpaceEmitter = l;
    this.destroyCallback = p;
    this.clampSpeedLinear = false;
  }
  render() {
    const a = min((time - this.spawnTime) / this.lifeTime, 1), b = vec2(this.sizeStart + a * this.sizeEndDelta);
    var c = this.fadeRate / 2;
    c = new Color(this.colorStart.r + a * this.colorEndDelta.r, this.colorStart.g + a * this.colorEndDelta.g, this.colorStart.b + a * this.colorEndDelta.b, (this.colorStart.a + a * this.colorEndDelta.a) * (a < c ? a / c : a > 1 - c ? (1 - a) / c : 1));
    this.additive && setBlendMode(true);
    let d = this.pos, e = this.angle;
    this.localSpaceEmitter && (d = this.localSpaceEmitter.pos.add(d.rotate(-this.localSpaceEmitter.angle)), e += this.localSpaceEmitter.angle);
    if (this.trailScale) {
      var f = this.velocity;
      this.localSpaceEmitter && (f = f.rotate(-this.localSpaceEmitter.angle));
      var g = f.length();
      g && (f = f.scale(1 / g), g *= this.trailScale, b.y = max(b.x, g), e = f.angle(), drawTile(d.add(f.multiply(vec2(0, -g / 2))), b, this.tileInfo, c, e, this.mirror));
    } else
      drawTile(d, b, this.tileInfo, c, e, this.mirror);
    this.additive && setBlendMode();
    debugParticles && debugRect(d, b, "#f005", 0, e);
    a == 1 && (this.color = c, this.size = b, this.destroyCallback && this.destroyCallback(this), this.destroyed = 1);
  }
}
var medals = {};
var medalsDisplayQueue = [];
var medalsSaveName;
var medalsDisplayTimeLast;

class Medal {
  constructor(a, b, c = "", d = "\uD83C\uDFC6", e) {
    ASSERT(0 <= a && !medals[a]);
    this.id = a;
    this.name = b;
    this.description = c;
    this.icon = d;
    this.unlocked = false;
    e && ((this.image = new Image).src = e);
    medals[a] = this;
  }
  unlock() {
    medalsPreventUnlock || this.unlocked || (ASSERT(medalsSaveName, "save name must be set"), localStorage[this.storageKey()] = this.unlocked = true, medalsDisplayQueue.push(this));
  }
  render(a = 0) {
    const b = overlayContext;
    var c = min(medalDisplaySize.x, mainCanvas.width);
    const d = overlayCanvas.width - c;
    a *= -medalDisplaySize.y;
    b.save();
    b.beginPath();
    b.fillStyle = new Color(0.9, 0.9, 0.9).toString();
    b.strokeStyle = new Color(0, 0, 0).toString();
    b.lineWidth = 3;
    b.rect(d, a, c, medalDisplaySize.y);
    b.fill();
    b.stroke();
    b.clip();
    this.renderIcon(vec2(d + 15 + medalDisplayIconSize / 2, a + medalDisplaySize.y / 2));
    c = vec2(d + medalDisplayIconSize + 30, a + 28);
    drawTextScreen(this.name, c, 38, new Color(0, 0, 0), 0, undefined, "left");
    c.y += 32;
    drawTextScreen(this.description, c, 24, new Color(0, 0, 0), 0, undefined, "left");
    b.restore();
  }
  renderIcon(a, b = medalDisplayIconSize) {
    this.image ? overlayContext.drawImage(this.image, a.x - b / 2, a.y - b / 2, b, b) : drawTextScreen(this.icon, a, 0.7 * b, new Color(0, 0, 0));
  }
  storageKey() {
    return medalsSaveName + "_" + this.id;
  }
}
var glCanvas;
var glContext;
var glAntialias = true;
var glShader;
var glActiveTexture;
var glArrayBuffer;
var glGeometryBuffer;
var glPositionData;
var glColorData;
var glInstanceCount;
var glAdditive;
var glBatchAdditive;
var gl_ONE = 1;
var gl_TRIANGLE_STRIP = 5;
var gl_SRC_ALPHA = 770;
var gl_ONE_MINUS_SRC_ALPHA = 771;
var gl_BLEND = 3042;
var gl_TEXTURE_2D = 3553;
var gl_UNSIGNED_BYTE = 5121;
var gl_FLOAT = 5126;
var gl_RGBA = 6408;
var gl_NEAREST = 9728;
var gl_LINEAR = 9729;
var gl_TEXTURE_MAG_FILTER = 10240;
var gl_TEXTURE_MIN_FILTER = 10241;
var gl_COLOR_BUFFER_BIT = 16384;
var gl_TEXTURE0 = 33984;
var gl_ARRAY_BUFFER = 34962;
var gl_STATIC_DRAW = 35044;
var gl_DYNAMIC_DRAW = 35048;
var gl_FRAGMENT_SHADER = 35632;
var gl_VERTEX_SHADER = 35633;
var gl_COMPILE_STATUS = 35713;
var gl_LINK_STATUS = 35714;
var gl_INDICIES_PER_INSTANCE = 11;
var gl_MAX_INSTANCES = 1e4;
var gl_INSTANCE_BYTE_STRIDE = 4 * gl_INDICIES_PER_INSTANCE;
var gl_INSTANCE_BUFFER_SIZE = gl_MAX_INSTANCES * gl_INSTANCE_BYTE_STRIDE;
var engineName = "LittleJS";
var engineVersion = "1.10.7";
var frameRate = 60;
var timeDelta = 1 / frameRate;
var engineObjects = [];
var engineObjectsCollide = [];
var frame = 0;
var time = 0;
var timeReal = 0;
var paused = false;
var frameTimeLastMS = 0;
var frameTimeBufferMS = 0;
var averageFPS = 0;
var pluginUpdateList = [];
var pluginRenderList = [];
// src/lib/littlejs.ts
setShowSplashScreen(true);
setEnablePhysicsSolver(false);
setGamepadsEnable(false);

// src/animation/animation-manager.ts
class AnimationManager {
  animationInfos = {};
  imageSources = [];
  constructor(animations) {
    this.saveImageSource(animations);
    this.registerAnimations(animations);
    this.registerTileInfos(animations);
    this.updateExtra(animations);
  }
  saveImageSource(animations) {
    animations?.forEach((animation) => {
      if (animation.imageSource && !this.imageSources.includes(animation.imageSource)) {
        this.imageSources.push(animation.imageSource);
      }
    });
  }
  ensureAnimationInfos(name) {
    if (!this.animationInfos[name]) {
      this.animationInfos[name] = {
        animation: undefined,
        tileInfos: []
      };
    }
    return this.animationInfos[name];
  }
  registerTileInfos(animations) {
    animations.forEach((animation) => {
      const animInfo = this.ensureAnimationInfos(animation.name);
      const imgSource = animation.imageSource;
      if (imgSource) {
        const size = vec2(animation.spriteSize?.[0] ?? 0, animation.spriteSize?.[1] ?? 0);
        animation.frames?.forEach((frame2) => {
          const mul = animation.mul ?? 1;
          const cols = 30;
          for (let i = 0;i < mul; i++) {
            animInfo.tileInfos.push(new TileInfo(undefined, size, this.imageSources.indexOf(imgSource), 2).frame(frame2 % cols).offset(vec2(0, Math.floor(frame2 / cols) * (size.y + 4))));
          }
        });
      }
    });
    animations.forEach((animation) => {
      const animInfo = this.ensureAnimationInfos(animation.name);
      animation.children?.forEach((child) => {
        const childAnimInfo = this.getInfo(child);
        animInfo.tileInfos.push(...childAnimInfo.tileInfos);
      });
    });
  }
  registerAnimations(animations) {
    animations?.forEach((animation) => {
      const animInfo = this.ensureAnimationInfos(animation.name);
      animInfo.animation = animation;
    });
  }
  updateExtra(animations) {
    animations.forEach((animation) => {
      const animInfo = this.ensureAnimationInfos(animation.name);
      if (animation.airFrames?.length) {
        let count = 0;
        animInfo.airFramesSet = new Set;
        animation.frames?.forEach((frame2) => {
          const mul = animation.mul ?? 1;
          for (let i = 0;i < mul; i++) {
            if (animation.airFrames?.includes(frame2)) {
              animInfo.airFramesSet?.add(count);
            }
            count++;
          }
        });
      }
    });
  }
  getInfo(name) {
    return this.animationInfos[name];
  }
}

// src/core/objects/decor.ts
class DecorObject extends EngineObject {
  initialPos;
  bornTime;
  doomTime;
  motionX = Math.random();
  motionY = Math.random();
  constructor(parent, x, y) {
    super();
    parent.addChild(this, vec2(x, y));
    this.initialPos = vec2(x, y);
    this.bornTime = Date.now() - Math.random() * 1e5;
  }
}

// src/core/objects/move-option.ts
class MoveOption extends EngineObject {
  px;
  py;
  from;
  canReveal;
  movePoints;
  distanceTravelled;
  canLand;
  animation;
  constructor(px, py, from, canReveal, movePoints, distanceTravelled, canLand) {
    super();
    this.px = px;
    this.py = py;
    this.from = from;
    this.canReveal = canReveal;
    this.movePoints = movePoints;
    this.distanceTravelled = distanceTravelled;
    this.canLand = canLand;
  }
}

// src/core/objects/attack-option.ts
class AttackOption extends EngineObject {
  px;
  py;
  animation;
  constructor(px, py) {
    super();
    this.px = px;
    this.py = py;
  }
}

// src/core/projectile.ts
class Projectile extends EngineObject {
  target;
  speed;
  constructor(start, target, speed) {
    super();
    this.target = target;
    this.speed = speed;
    this.pos.set(start.x, start.y);
    this.size.set(0.5, 0.5);
    this.renderOrder = 1e7;
  }
  move() {
    const dx = this.target.x - this.pos.x;
    const dy = this.target.y - this.pos.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < this.speed) {
      this.pos.set(this.target.x, this.target.y);
      return true;
    }
    this.pos.set(this.pos.x + dx / dist * this.speed, this.pos.y + dy / dist * this.speed);
    this.angle += 0.2;
  }
  landed() {
    return this.pos.x === this.target.x && this.pos.y === this.target.y;
  }
}

// src/core/objects/game-object.ts
class GameObject extends EngineObject {
  manager;
  gridShift;
  animationInfo;
  hoveredAnimationInfo;
  selectedAnimationInfo;
  moveAnimationInfo;
  attackAnimationInfo;
  harvestAnimationInfo;
  shadowAnimationInfo;
  frameRate = 60;
  mouseFollower;
  px = 0;
  py = 0;
  positionDetached;
  onHoverHideCursor;
  visible = true;
  elem;
  hovered = false;
  decors = [];
  shadow;
  labels = [];
  updated = false;
  moveOptions;
  attackOptions;
  clearedCloud;
  bornTime = Date.now() - Math.random() * 1e4;
  moveQueue = [];
  resources = [];
  floatResources;
  resourceBars = [];
  moving;
  talkingTime;
  attackTarget;
  attackOrigin;
  retaliationDamage;
  onDone;
  hasPendingActions;
  damageTime;
  retaliating;
  projectile;
  unitsSupported = new Set;
  constructor(manager, gridShift = vec2(0, 0)) {
    super();
    this.manager = manager;
    this.gridShift = gridShift;
  }
  getColor(color) {
    if (color === "random") {
      return randColor();
    } else {
      return new Color().setHex(color);
    }
  }
  async refresh(elem) {
    if (!this.elem) {
      const definition = this.manager.scene.definitions.find((def) => def.name === elem.definition);
      if (definition) {
        this.elem = JSON.parse(JSON.stringify(definition));
      } else {
        this.elem = elem.copy ? JSON.parse(JSON.stringify(elem)) : elem;
      }
      this.manager.defineElem(this.elem);
    }
    elem = this.elem;
    const config = elem.gameObject;
    if (config) {
      this.visible = !config.hidden;
      if (this.home) {
        this.home.unitsSupported.add(this);
      }
      if (elem.owner === undefined) {
        elem.owner = 0;
      }
      if (elem.type === "cursor") {
        this.manager.cursor = this;
      }
      if (!this.positionDetached) {
        const px = this.gridShift.x + (config.pos?.[0] ?? 0);
        const py = this.gridShift.y + (config.pos?.[1] ?? 0);
        this.setPosition(px, py, true);
        const offset = this.elem?.gameObject?.offset ?? [0, 0];
        this.pos.set(px + offset[0], py + offset[1]);
      }
      this.updateSize(1);
      if (config.rotation) {
        this.angle = config.rotation;
      }
      if (config.color) {
        this.color = this.getColor(config.color);
      }
      if (elem.animation) {
        this.animationInfo = this.manager.animation.getInfo(elem.animation.name);
      }
      if (elem.onHover) {
        if (elem.onHover.animation) {
          this.hoveredAnimationInfo = this.manager.animation.getInfo(elem.onHover.animation);
        }
        this.onHoverHideCursor = elem.onHover.hideCursor;
      }
      if (elem.selected?.animation) {
        this.selectedAnimationInfo = this.manager.animation.getInfo(elem.selected.animation);
      }
      if (elem.move?.animation) {
        this.moveAnimationInfo = this.manager.animation.getInfo(elem.move.animation);
      }
      if (elem?.attack?.animation) {
        this.attackAnimationInfo = this.manager.animation.getInfo(elem.attack.animation);
      }
      if (elem.harvest?.animation) {
        this.harvestAnimationInfo = this.manager.animation.getInfo(elem.harvest.animation);
      }
      if (elem.shadow) {
        if (elem.shadow.animation) {
          this.shadowAnimationInfo = this.manager.animation.getInfo(elem.shadow.animation);
          if (!this.shadow) {
            this.shadow = new EngineObject;
            this.shadow.size.set(this.size.x, this.size.y);
            this.shadow.tileInfo = this.getTileInfoAnimate(this.shadowAnimationInfo);
            const offset = this.elem?.gameObject?.offset ?? [0, 0];
            this.addChild(this.shadow, vec2(-offset[0], -offset[1]));
          }
        }
      }
      if (elem.mouseFollower) {
        this.mouseFollower = {
          offset: vec2(elem.mouseFollower.offset?.[0] ?? 0, elem.mouseFollower.offset?.[1] ?? 0),
          snap: elem.mouseFollower.snap
        };
      }
      if (elem.spread) {
        const { animation, count, radius, color, size } = elem.spread;
        const animInfo = this.manager.animation.getInfo(animation);
        const actualCount = count[0] + Math.floor(Math.random() * (count[1] - count[0]));
        for (let i = 0;i < actualCount; i++) {
          const x = (Math.random() - 0.5) * (size ?? 1);
          const y = (Math.random() - 0.5) * (size ?? 1);
          if (radius && x * x + y * y > radius * radius) {
            continue;
          }
          const decor2 = new DecorObject(this, x, y);
          decor2.tileInfo = this.getTileInfoAnimate(animInfo);
          if (color) {
            decor2.color = this.getColor(color);
          }
          this.decors.push(decor2);
        }
        if (elem.branchOut && Math.random() <= (elem.branchOut.chance ?? 1)) {
          const { count: count2, element } = elem.branchOut;
          const actualCount2 = count2[0] + Math.floor(Math.random() * (count2[1] - count2[0]));
          const pos = vec2(this.pos.x, this.pos.y);
          const directions = [[-1, 0], [0, -1], [1, 0], [0, 1]];
          let lastDir;
          for (let i = 0;i < actualCount2; i++) {
            const el = this.manager.defineElem(JSON.parse(JSON.stringify(element)));
            const oppositeDirIndex = lastDir ? (directions.indexOf(lastDir) + 2) % 4 : undefined;
            const filteredDirections = directions.filter((_dir, index) => index !== oppositeDirIndex);
            const dir = filteredDirections[Math.floor(Math.random() * filteredDirections.length)];
            pos.set(pos.x + dir[0], pos.y + dir[1]);
            if (this.manager.grid[`road_${pos.x}_${pos.y}`]) {
              break;
            }
            const rot = Math.atan2(-dir[1], dir[0]);
            if (!el.gameObject) {
              el.gameObject = {};
            }
            if (!el.gameObject.noRotation) {
              el.gameObject.rotation = rot;
            }
            el.gameObject.pos = [pos.x, pos.y];
            this.manager.scene.elems.push(el);
            lastDir = dir;
          }
        }
      }
      if (elem.selfSelect) {
        elem.selfSelect = false;
        setTimeout(() => {
          this.manager.setSelection(this);
        }, 300);
      }
      await this.refreshLabel();
      this.refreshBars();
      this.refreshAlpha();
    } else {
      if (this.manager.grid[this.getTag()] === this) {
        delete this.manager.grid[this.getTag()];
      }
      if (this.manager.selected === this) {
        this.manager.setSelection(undefined);
      }
      this.destroy();
    }
  }
  hideBars() {
    this.resourceBars.forEach((bar) => bar.destroy());
    this.resourceBars.length = 0;
  }
  refreshBars() {
    this.hideBars();
    if (!this.elem?.resourcesAccumulated) {
      return;
    }
    const [offX, offY] = this.elem?.gameObject?.offset ?? [0, 0];
    let count = 0;
    Object.entries(this.elem.resourcesAccumulated).forEach(([key, value]) => {
      const res = key;
      if (this.manager.scene.resources[res]?.global) {
        return;
      }
      if (!value) {
        return;
      }
      const backBar = new EngineObject(vec2(0, 0), vec2(1, 0.3));
      backBar.color = new Color(0, 0, 0, 0.3);
      this.addChild(backBar, vec2(0 - offX, count * 0.3 - offY - 0.3));
      this.resourceBars.push(backBar);
      const numValuesToShow = Math.min(10, value);
      const spacing = Math.min(0.2, 1 / numValuesToShow);
      for (let j = 0;j < numValuesToShow; j++) {
        const barIcon = new EngineObject(vec2(0, 0), vec2(0.5, 0.5));
        barIcon.tileInfo = this.getTileInfoAnimate(this.manager.animation.getInfo(key));
        this.addChild(barIcon, vec2(-0.4 + j * spacing - offX + Math.floor(j / 5) * 0.1 - Math.floor((numValuesToShow - 1) / 5) * 0.05, count * 0.3 - offY - 0.3));
        this.resourceBars.push(barIcon);
      }
      if (value > 10) {
        const color = value >= this.resourceCapacity(res) ? new Color(1, 0.7, 0.7, 1) : new Color(1, 1, 1, 1);
        const digits = this.generateEngineObjectsForDigit(value, 0.4, 0.16, vec2(0.5 - offX, count * 0.3 - offY - 0.3), color);
        this.resourceBars.push(...digits);
      }
      count++;
    });
    this.updated = false;
  }
  isRevealed() {
    return this.manager.isRevealed(this.px, this.py);
  }
  async refreshLabel() {
    this.labels.forEach((label) => label.destroy());
    this.labels.length = 0;
    if (this.elem?.harvesting && !this.elem?.level) {
      return;
    }
    if (!this.isRevealed()) {
      return;
    }
    let numToShow = this.elem?.level ?? this.elem?.hitpoints;
    if (!numToShow) {
      return;
    }
    const size = this.elem?.level ? 0.5 : 0.3;
    const offset = this.elem?.level ? vec2(0, 0.25) : vec2(-0.5, 0.2);
    const charSize = this.elem?.level ? 0.2 : 0.15;
    const labelAlpha = await this.canAct() ? 1 : 0.5;
    const isOwnedByPlayer = this.elem?.owner === this.manager.getPlayer();
    const color = !this.elem?.owner ? new Color(1, 0.5, 0.5, labelAlpha) : !isOwnedByPlayer ? new Color(0.5, 0.5, 0.5, labelAlpha) : this.elem?.hitpoints ? this.elem.hitpoints < (this.elem.maxHitPoints ?? 0) ? new Color(1, 1, 0, labelAlpha) : new Color(0, 1, 0, labelAlpha) : await this.canAffordMoreHarvester() ? new Color(1, 0.9, 0, labelAlpha) : new Color(1, 1, 1, labelAlpha);
    if (!this.labels) {
      this.labels = [];
    }
    const digits = this.generateEngineObjectsForDigit(numToShow, size, charSize, offset, color);
    this.labels.push(...digits);
    this.labels.forEach((label) => label.renderOrder = this.renderOrder + 0.2);
  }
  async canAffordMoreHarvester() {
    return (await this.findNearby((obj) => !!obj?.elem?.harvesting)).size < (this.elem?.level ?? 0);
  }
  resourceMaxedOut() {
    return Object.entries(this.elem?.resourcesAccumulated ?? {}).some(([resource, value]) => {
      const res = resource;
      if (this.manager.scene.resources[res]?.global || this.manager.scene.resources[res]?.forGrowth) {
        return;
      }
      return value >= this.resourceCapacity(resource);
    });
  }
  generateDigits(num) {
    const digits = [];
    let l = Math.max(0, num);
    while (l > 0) {
      const d = l % 10;
      digits.push(d);
      l = Math.floor(l / 10);
    }
    return digits;
  }
  generateEngineObjectsForDigit(num, size, charSize, offset, color) {
    const digits = this.generateDigits(num);
    return digits.map((d, i) => {
      const digit = new EngineObject(vec2(0, 0), vec2(size, size));
      digit.tileInfo = this.getTileInfoAnimate(this.manager.animation.getInfo(`num_${d}`));
      digit.color = color;
      this.addChild(digit, offset.add(vec2(-i * charSize, 0)));
      return digit;
    });
  }
  hideResources() {
    this.resources.forEach((resource) => resource.destroy());
    this.resources.length = 0;
  }
  showResources(x, y, owner, floatResources = false, res) {
    const resources = res ?? this.manager.getResources(x, y);
    if (!resources) {
      return;
    }
    const rand2 = floatResources ? (Math.random() - 0.5) * 0.5 : 0;
    const resourceSpacing = 0.15;
    const offset = this.elem?.gameObject?.offset ?? [0, 0];
    const offX = x - this.px - offset[0] + rand2, offY = y - this.py - offset[1];
    const RESOURCES = ["wheat", "wood", "trade", "gold", "brain"];
    let total = 0;
    RESOURCES.forEach((resource) => {
      for (let i = 0;i < (resources[resource] ?? 0); i++) {
        total++;
      }
    });
    let count = 0;
    RESOURCES.forEach((resource) => {
      const value = resources[resource] ?? 0;
      if (!value) {
        return;
      }
      const MAX_ROW = 8;
      for (let i = 0;i < value; i++) {
        const indic = new EngineObject(vec2(0, 0), vec2(0.5, 0.5));
        indic.tileInfo = this.getTileInfoAnimate(this.manager.animation.getInfo(resource));
        indic.color = new Color(1, 1, 1, 1);
        const col = count % MAX_ROW;
        const row = Math.floor(count / MAX_ROW);
        this.addChild(indic, vec2(offX + (col - (Math.min(total, MAX_ROW) - 1) / 2) * resourceSpacing + rand2, offY + (row - Math.floor(total / MAX_ROW) / 2) * resourceSpacing + rand2));
        this.resources.push(indic);
        count++;
      }
    });
    let harvesting = floatResources;
    if (!floatResources) {
      this.manager.iterateGridCell(x, y, async (elem) => {
        if (elem.elem?.owner === owner && elem.elem?.harvesting) {
          harvesting = true;
        }
      });
    }
    if (!floatResources) {
      const indic = new EngineObject(vec2(0, 0), vec2(count * resourceSpacing + 0.2, 0.3));
      indic.color = harvesting ? new Color(1, 0.5, 1, 0.8) : new Color(0.5, 0.5, 0.5, 0.8);
      this.addChild(indic, vec2(offX, offY));
      this.resources.push(indic);
    }
    this.updated = false;
    if (floatResources) {
      this.floatResources = Date.now();
    }
  }
  setHarvesting(value) {
    if (this.elem) {
      if (this.elem.harvesting !== value) {
        this.elem.harvesting = value;
        this.home?.refreshLabel();
        if (this.elem.harvesting) {
          this.spendActions();
        } else {
          this.manager.setSelection(this);
        }
      }
    }
  }
  getTag() {
    return GameObject.getTag(this.elem?.type, this.px, this.py);
  }
  static getTag(type, px, py) {
    return `${type}_${px}_${py}`;
  }
  updateSize(s) {
    const age = Date.now() - this.bornTime;
    const scale = s ?? Math.min(1, age / 200);
    const config = this.elem?.gameObject;
    this.size.set(scale * (this.visible ? config?.size?.[0] ?? 0 : 0) * (this.elem?.gameObject?.lastDx ?? 1), scale * (this.visible ? config?.size?.[1] ?? 0 : 0));
  }
  clearMoves() {
    if (this.elem?.turn) {
      this.elem.turn.moves = 0;
      this.elem.turn.attacks = 0;
      this.elem.turn.actions = 0;
    }
  }
  hasMove() {
    return this.elem?.turn?.moves;
  }
  hasAttack() {
    return this.elem?.turn?.attacks;
  }
  hasAction() {
    return this.elem?.turn?.actions;
  }
  async canAttack() {
    if (!this.elem?.attack || this.elem.attack.disabled) {
      return false;
    }
    if (!this.elem.turn?.attacks) {
      return false;
    }
    if (!this.elem?.turn.moves && !this.elem.attack.attackAfterMove) {
      return false;
    }
    const foes = await this.findNearbyFoe(this.elem.attack.range);
    if (!foes.size) {
      return false;
    }
    let hasFoeToAttack = false;
    foes.forEach((foe) => {
      if (this.canAttackAt(foe.px, foe.py)) {
        hasFoeToAttack = true;
      }
    });
    if (!hasFoeToAttack) {
      return false;
    }
    return true;
  }
  spendAttack() {
    const elem = this.elem;
    if (elem && elem.turn?.attacks) {
      elem.turn.attacks = this.elem?.attack?.attackAfterAttack ? 1 : 0;
      elem.turn.moves = this.elem?.attack?.moveAfterAttack ? 1 : 0;
    }
  }
  spendMove() {
    if (this.elem?.endlessMove) {
      this.doneMoving();
      return;
    }
    const elem = this.elem;
    if (elem && elem.turn?.moves) {
      elem.turn.moves--;
      this.doneMoving();
    }
  }
  doneMoving() {
    if (this.hasPendingActions) {
      return;
    }
    this.afterDoneMoving();
  }
  async afterDoneMoving() {
    this.refreshAlpha();
    this.refreshLabel();
    await this.manager.unlockRewards(this);
    this.manager.checkForAnyMove();
    if (this.manager.isAiPlayer(this.elem?.owner)) {
      await this.manager.selectNext();
    } else if (!this.canAct() || this.elem?.harvesting || this.elem?.waiting) {
      await this.manager.selectNext();
    } else if (this.manager.selected === this) {
      if (this.elem?.settler || this.elem?.worker) {
        this.showResourcesNearby();
      }
      await this.showActionOptions();
      this.manager.hud.showSelected(this);
    }
  }
  spendActions() {
    const elem = this.elem;
    if (elem && elem.turn?.actions) {
      elem.turn.actions--;
      this.doneMoving();
    }
  }
  async canAct() {
    return this.hasMove() || this.hasAttack() && await this.canAttack() || this.hasAction();
  }
  refreshAlpha() {
    if (this.elem?.turn && this.elem?.type === "unit") {
      if (!this.canAct() || this.elem?.waiting) {
        this.color = new Color(1, 1, 1, 0.5);
      } else {
        this.color = new Color(1, 1, 1, 1);
      }
    }
  }
  async giveTurn() {
    const elem = this.elem;
    if (elem?.turn) {
      elem.turn.moves = elem.turn.attacks = 1;
      if (elem.worker) {
        elem.turn.actions = 1;
      }
      if (this.elem?.harvesting || this.elem?.waiting) {
        const foes = await this.findNearbyFoe();
        if (foes.size) {
          this.elem.harvesting = false;
          this.elem.waiting = false;
          this.updated = false;
        }
      }
      this.refreshAlpha();
      this.refreshLabel();
    }
  }
  attackTowards(px, py) {
    console.log(this.elem?.name, "Attack towards", px, py);
    const dx = px - this.px;
    const dy = py - this.py;
    const dist = Math.max(Math.abs(dx), Math.abs(dy));
    if (dist === 0) {
      return;
    }
    if (dist > 1) {
      const x = Math.sign(dx);
      const y = Math.sign(dy);
      this.simpleMoveTo(this.px + x, this.py + y);
      console.log("move by", x, y);
    }
    this.moveQueue.push(vec2(px, py));
  }
  simpleMoveTo(px, py) {
    this.moveQueue = [vec2(px, py)];
    this.hideResources();
    this.hideMoveOptions();
    this.manager.hud.showSelected(undefined);
  }
  attackAt(px, py) {
    const dx = px - this.px;
    const dy = py - this.py;
    if (!this.elem?.attack?.range) {
      this.moveQueue.push(vec2(px, py));
      this.hideResources();
      this.hideMoveOptions();
      this.manager.hud.showSelected(undefined);
    } else {
      const unit = this.manager.unitAt(px, py);
      if (unit) {
        this.attackRange(unit);
      }
    }
  }
  moveTo(px, py) {
    this.positionDetached = true;
    const moveOption = this.moveOptions?.[`${px}_${py}`];
    if (!moveOption) {
      if (this.moveQueue)
        this.moveQueue.length = 0;
      return;
    }
    if (!this.moveQueue) {
      this.moveQueue = [];
    }
    this.moveQueue.push(vec2(px, py));
    const from = moveOption.from;
    if (from.x !== this.px || from.y !== this.py) {
      this.moveTo(from.x, from.y);
      return;
    }
    this.hideResources();
    this.hideMoveOptions();
    this.manager.hud.showSelected(undefined);
  }
  talkTo(gameObject) {
    if (!this.elem?.gameObject) {
      return;
    }
    const dx = gameObject.px - this.px;
    if (this.elem.gameObject.lastDx !== Math.sign(dx)) {
      this.elem.gameObject.lastDx = Math.sign(dx);
      this.updateSize();
    }
    this.talkingTime = Date.now() + Math.random() * 3000;
  }
  async moveUnitTo(px, py) {
    this.talkingTime = undefined;
    const target = this.manager.unitAt(px, py);
    if (target) {
      if (this.elem?.owner === target.elem?.owner) {
        this.talkTo(target);
        target.talkTo(this);
        return;
      }
      if (this.elem?.owner !== target.elem?.owner && await this.canAttack()) {
        this.attack(target);
        return;
      }
    } else {
      this.setPosition(px, py);
    }
  }
  setPosition(px, py, force) {
    if (this.px === px && this.py === py && !force)
      return;
    if (this.manager.grid[this.getTag()] === this) {
      delete this.manager.grid[this.getTag()];
    }
    if (this.px !== px && this.elem?.gameObject) {
      this.elem.gameObject.lastDx = Math.sign(px - this.px);
      this.updateSize();
    }
    this.px = px;
    this.py = py;
    if (this.manager.grid[this.getTag()] !== this) {
      this.manager.grid[this.getTag()]?.destroy();
      this.manager.grid[this.getTag()] = this;
    }
    if (this.elem?.type === "cursor") {
      this.manager.onCursorMove(px, py);
    }
    if (this.elem?.type === "cloud") {
      this.manager.revealed.delete(`${px}_${py}`);
    }
    this.clearedCloud = false;
    this.updated = false;
  }
  hasMoveOptionToLandOn(x, y) {
    return this.moveOptions?.[`${x}_${y}`]?.canLand;
  }
  hasAttackOptionOn(x, y) {
    return this.attackOptions?.[`${x}_${y}`];
  }
  canLandOn(px, py) {
    if (!this.canMoveTo(px, py)) {
      return false;
    }
    return true;
  }
  canAttackAt(px, py) {
    const elem = this.elem;
    if (!elem) {
      return false;
    }
    if (this.elem?.owner && !this.manager.isRevealed(px, py)) {
      return false;
    }
    const dx = px - this.px;
    const dy = py - this.py;
    const distance = Math.max(Math.abs(dx), Math.abs(dy));
    if (distance > (elem.attack?.range ?? 1)) {
      return false;
    }
    const targetUnit = this.manager.unitAt(px, py);
    if (targetUnit) {
      return targetUnit.elem?.owner !== elem.owner;
    }
    return false;
  }
  canMoveTo(px, py) {
    const elem = this.elem;
    if (!elem) {
      return false;
    }
    if (this.px === px && this.py === py) {
      return false;
    }
    if (!this.elem?.turn?.moves) {
      return false;
    }
    if (elem.type !== "unit") {
      return false;
    }
    if (!this.manager.grid[`tile_${px}_${py}`]) {
      return false;
    }
    if (!this.manager.isRevealed(px, py)) {
      if (!this.manager.isAiPlayer(this.elem.owner) && !this.elem.team) {
        return false;
      }
    }
    const decor2 = this.manager.grid[`decor_${px}_${py}`];
    if (decor2) {
      if (!elem?.canCrossTerrains?.includes(decor2.elem?.name ?? "")) {
        return false;
      }
    }
    const tile_overlay = this.manager.grid[`tile_overlay_${px}_${py}`];
    if (tile_overlay?.elem?.water) {
      if (!elem?.canCrossTerrains?.includes(tile_overlay?.elem?.name ?? "")) {
        return false;
      }
    }
    if (this.elem?.closeToHome && this.home) {
      const home = this.home;
      const dx = px - home.px;
      const dy = py - home.py;
      if (this.manager.isResearched("expansion", this.manager.getPlayer())) {
        if (Math.abs(dx * dy) >= 4) {
          return false;
        }
      } else {
        if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
          return false;
        }
      }
    }
    const targetUnit = this.manager.unitAt(px, py);
    if (targetUnit) {
      return false;
    }
    return true;
  }
  hide() {
    if (this.visible) {
      this.visible = false;
      this.size.set(0, 0);
    }
  }
  show() {
    if (!this.visible) {
      this.visible = true;
      this.updateSize();
    }
  }
  hoverIndic;
  onHoverChange() {
    if (this.manager.shifting) {
      return;
    }
    if (this.onHoverHideCursor) {
      if (this.manager.hovering(this)) {
        this.manager.setHovered(this);
        if (this.elem?.onHover?.indic && !this.hoverIndic) {
          this.hoverIndic = new EngineObject;
          const scale = this.elem.onHover.indic.scale ?? 1;
          this.hoverIndic.size.set(this.size.x * scale, this.size.y * scale);
          this.hoverIndic.tileInfo = this.manager.animation.getInfo(this.elem.onHover.indic.animation).tileInfos[0];
          this.hoverIndic.pos.set(this.px, this.py);
          const offset = this.elem?.gameObject?.offset ?? [0, 0];
          this.addChild(this.hoverIndic, vec2(-offset[0], -offset[1]));
          this.updated = false;
        }
      } else {
        this.manager.setHovered(undefined);
        if (this.elem?.onHover?.indic && this.hoverIndic) {
          this.removeChild(this.hoverIndic);
          this.hoverIndic.destroy();
          this.hoverIndic = undefined;
        }
      }
    }
  }
  selectIndic;
  showResourcesNearby() {
    const home = this.elem?.settler ? this : this.elem?.worker ? this.home : this;
    if (home) {
      const range = this.manager.isResearched("expansion", this.elem?.owner ?? 0) ? 2 : 1;
      for (let y = -range;y <= range; y++) {
        for (let x = -range;x <= range; x++) {
          if (Math.abs(x * y) < 4) {
            if (this.elem?.building || home.px + x === this.px && home.py + y === this.py || this.canMoveTo(home.px + x, home.py + y)) {
              this.showResources(home.px + x, home.py + y, this.elem?.owner);
            }
          }
        }
      }
      home?.hideBars();
    }
  }
  async onSelectChange() {
    if (this.manager.selected === this) {
      if (this.elem?.selected?.indic && !this.selectIndic) {
        this.selectIndic = new EngineObject;
        const scale = this.elem.selected.indic.scale ?? 1;
        this.selectIndic.size.set(this.size.x * scale, this.size.y * scale);
        this.selectIndic.renderOrder = this.renderOrder - 0.1;
        this.selectIndic.tileInfo = this.manager.animation.getInfo(this.elem.selected.indic.animation).tileInfos[0];
        const offset = this.elem?.gameObject?.offset ?? [0, 0];
        this.addChild(this.selectIndic, vec2(-offset[0], -offset[1]));
        this.selectIndic.pos.set(this.px, this.py);
        if (!this.elem?.owner) {
          this.selectIndic.color = new Color(1, 0, 0, 1);
        }
        if (this.manager.isAiPlayer(this.elem?.owner)) {
          if (await this.canAct() && this.manager.isRevealed(this.px, this.py)) {
            this.manager.thinker?.think(this);
          }
          return;
        }
        this.showActionOptions();
        if (!this.moving) {
          const resourcesFloating = Date.now() - (this.floatResources ?? 0) < 2000;
          if ((this.elem?.settler || this.elem?.worker) && !resourcesFloating) {
            if (!this.elem?.building && this.elem?.harvesting) {
              this.showResources(this.px, this.py, this.elem?.owner);
            } else {
              this.showResourcesNearby();
            }
          }
        }
        this.hideBars();
      }
    } else {
      if (this.elem?.selected?.indic && this.selectIndic) {
        this.selectIndic.destroy();
        this.selectIndic = undefined;
      }
      this.hideMoveOptions();
      if (this.elem?.animation) {
        this.hideResources();
      }
      this.refreshBars();
    }
  }
  async showActionOptions() {
    if (this.hasMove() && !await this.manager.checkCondition(this.elem?.move?.disabled, this)) {
      this.addMoveOptions(this.elem?.move?.distance ?? 1, vec2(this.px, this.py));
    }
    if (this.hasAttack() && await this.canAttack()) {
      this.addAttackOptions(this.elem?.attack?.range ?? 1);
    }
  }
  hideMoveOptions() {
    if (this.moveOptions) {
      Object.values(this.moveOptions).forEach((moveOption) => moveOption.destroy());
      delete this.moveOptions;
    }
    if (this.attackOptions) {
      Object.values(this.attackOptions).forEach((attackOption) => attackOption.destroy());
      delete this.attackOptions;
    }
  }
  addMoveOptions(movePoints, from, revealPotential = 0, distanceTravelled = 0) {
    if (!movePoints) {
      return;
    }
    const DIRECTIONS = [
      [-1, 0],
      [0, -1],
      [1, 0],
      [0, 1],
      [-1, -1],
      [1, -1],
      [-1, 1],
      [1, 1]
    ];
    const froms = [];
    DIRECTIONS.forEach(([dx, dy]) => {
      if (!this.canMoveTo(from.x + dx, from.y + dy)) {
        return;
      }
      const newDistanceTravelled = distanceTravelled + Math.sqrt(dx * dx + dy * dy);
      const existingMoveOption = this.moveOptions?.[`${from.x + dx}_${from.y + dy}`];
      if (existingMoveOption) {
        const canReveal = revealPotential + this.manager.countRevealPotential(from.x + dx, from.y + dy);
        let shouldReplace = false;
        if (existingMoveOption.movePoints < movePoints) {
          shouldReplace = true;
        } else if (existingMoveOption.movePoints === movePoints) {
          if (existingMoveOption.distanceTravelled > newDistanceTravelled) {
            shouldReplace = true;
          } else if (existingMoveOption.distanceTravelled === newDistanceTravelled && existingMoveOption.canReveal < canReveal) {
            shouldReplace = true;
          }
        }
        if (shouldReplace) {
          existingMoveOption.canReveal = canReveal;
          existingMoveOption.from = from;
          existingMoveOption.movePoints = movePoints;
          existingMoveOption.distanceTravelled = newDistanceTravelled;
          froms.push([vec2(from.x + dx, from.y + dy), canReveal, newDistanceTravelled]);
        }
        return;
      }
      const obj = new MoveOption(from.x + dx, from.y + dy, from, revealPotential + this.manager.countRevealPotential(from.x + dx, from.y + dy), movePoints, newDistanceTravelled, this.canLandOn(from.x + dx, from.y + dy));
      obj.size.set(this.size.x, this.size.y);
      if (this.elem?.selected?.moveIndic) {
        obj.tileInfo = this.getTileInfoAnimate(this.manager.animation.getInfo(this.elem.selected.moveIndic.animation));
      } else {
        obj.color = new Color(0, 0, 0, 0.3);
        obj.tileInfo = this.tileInfo;
      }
      if (!obj.canLand) {
        obj.color = new Color(0, 0, 0, 0);
      }
      const unit = this.manager.unitAt(from.x + dx, from.y + dy);
      if (unit) {
        obj.color = new Color(1, 0, 0, 0.5);
      }
      const offset = this.elem?.gameObject?.offset ?? [0, 0];
      this.addChild(obj, vec2(from.x + dx - this.px - offset[0], from.y + dy - this.py - offset[1]));
      if (!this.moveOptions) {
        this.moveOptions = {};
      }
      this.moveOptions[`${from.x + dx}_${from.y + dy}`] = obj;
      froms.push([vec2(from.x + dx, from.y + dy), obj.canReveal, obj.distanceTravelled]);
      this.updated = false;
    });
    froms.forEach(([from2, revealing, newDistanceTravelled]) => this.addMoveOptions(movePoints - 1, from2, revealing, newDistanceTravelled));
  }
  addAttackOptions(range) {
    if (!range) {
      return;
    }
    for (let y = -range;y <= range; y++) {
      for (let x = -range;x <= range; x++) {
        if (this.canAttackAt(this.px + x, this.py + y)) {
          const obj = new AttackOption(this.px + x, this.py + y);
          obj.size.set(this.size.x, this.size.y);
          if (this.elem?.selected?.moveIndic) {
            obj.tileInfo = this.getTileInfoAnimate(this.manager.animation.getInfo(this.elem.selected.moveIndic.animation));
          } else {
            obj.color = new Color(0, 0, 0, 0.3);
            obj.tileInfo = this.tileInfo;
          }
          const unit = this.manager.unitAt(this.px + x, this.py + y);
          if (unit) {
            obj.color = new Color(1, 0, 0, 0.5);
          }
          this.addChild(obj, vec2(x, y));
          if (!this.attackOptions) {
            this.attackOptions = {};
          }
          this.attackOptions[`${this.px + x}_${this.py + y}`] = obj;
          this.updated = false;
        }
      }
    }
  }
  getFrame(animInfo) {
    if (!animInfo) {
      return 0;
    }
    const timeOffset = this.talkingTime ?? this.bornTime;
    const globalFrame = Math.floor((Date.now() + timeOffset) / (1000 / this.frameRate));
    return animInfo?.animation?.once ? Math.min(globalFrame, animInfo.tileInfos.length - 1) : globalFrame % animInfo.tileInfos.length;
  }
  getTileInfoAnimate(animInfo) {
    const t = this.getFrame(animInfo);
    return animInfo?.tileInfos?.[t];
  }
  checkResourceCaps() {
    const elem = this.elem;
    if (!elem?.resourcesAccumulated) {
      return;
    }
    Object.entries(elem.resourcesAccumulated).forEach(([key, value]) => {
      const k = key;
      const maxCapacity = this.resourceCapacity(k);
      if (value > maxCapacity) {
        if (!elem.resourcesCapped) {
          elem.resourcesCapped = {};
        }
        elem.resourcesCapped[k] = value;
      }
    });
  }
  calculateUnitResourcesRevenue() {
    const resources = {
      wheat: 0,
      wood: 0,
      trade: 0,
      gold: 0,
      brain: 0
    };
    this.unitsSupported.forEach((unit) => {
      const res = unit.calculateUnitResourcesRevenue();
      Object.entries(res).forEach(([key, value]) => {
        resources[key] += value;
      });
    });
    Object.entries(resources).forEach(([key, value]) => {
      const k = key;
      if (this.manager.scene.resources[k]?.global) {
        return;
      }
      resources[k] += value;
    });
    return resources;
  }
  accumulateResources(resources) {
    if (this.doomed) {
      return;
    }
    if (this.home) {
      this.home.accumulateResources(resources);
      return;
    }
    const elem = this.elem;
    if (!elem) {
      return;
    }
    Object.entries(resources).forEach(([key, value]) => {
      const k = key;
      if (this.manager.scene.resources[k]?.global) {
        return;
      }
      if (!elem.resourcesAccumulated) {
        elem.resourcesAccumulated = {};
      }
      if (!elem.resourcesCapped?.[k]) {
        elem.resourcesAccumulated[k] = (elem.resourcesAccumulated[k] ?? 0) + value;
      }
    });
    if (elem.type === "house" && elem.resourcesAccumulated) {
      if (this.manager.isResearched("productivity", this.manager.getPlayer())) {
        elem.resourcesAccumulated.wood = (elem.resourcesAccumulated.wood ?? 0) + 1;
      }
      if ((elem.resourcesAccumulated.wheat ?? 0) >= this.nextLevelCost() && this.canUpdateLevel()) {
        elem.resourcesAccumulated.wheat = (elem.resourcesAccumulated.wheat ?? 0) - this.nextLevelCost();
        this.updateLevel((elem.level ?? 0) + 1);
        this.updated = false;
      }
    }
  }
  updateResource(resource, value) {
    if (!this.elem) {
      return;
    }
    if (!this.elem.resourcesAccumulated) {
      this.elem.resourcesAccumulated = {};
    }
    const resObj = this.manager.getResourceType(resource);
    const previousVal = resObj?.global ? this.manager.getPlayerResource(resource, this.elem.owner ?? 0) : this.elem.resourcesAccumulated[resource] ?? 0;
    const val = typeof value === "function" ? value(previousVal) : value;
    if (resObj?.global) {
      if (this.elem.owner) {
        this.manager.updateResource(resource, val, this.elem.owner);
      }
      return;
    }
    this.elem.resourcesAccumulated[resource] = val;
    if (this.elem.resourcesCapped && val < this.resourceCapacity(resource)) {
      this.elem.resourcesCapped[resource] = 0;
    }
    this.updated = false;
  }
  async fixCows() {
    const cows = await this.countUnitSupport("cow");
    const maxCows = this.elem?.level ?? 0;
    if (cows > maxCows) {
      let toRemove = cows - maxCows;
      await this.manager.iterateRevealedCells(async (obj) => {
        if (toRemove <= 0) {
          return;
        }
        if (obj.elem?.name === "cow" && obj.home === this) {
          obj.doom(true);
          toRemove--;
        }
      });
    }
  }
  canUpdateLevel() {
    return this.elem?.type === "house" && (this.elem?.level ?? 0) < (this.elem?.maxLevel ?? 999);
  }
  async updateLevel(level) {
    if (this.elem?.type === "house") {
      this.elem.level = level;
      await this.fixCows();
      await this.refreshLabel();
      this.updated = false;
    }
  }
  nextLevelCost() {
    return this.resourceCapacity("wheat");
  }
  resourceCapacity(resource) {
    const capacity = (this.elem?.level ?? 0) + 1;
    return capacity * 10;
  }
  async countUnitSupport(unit) {
    let count = 0;
    await this.manager.iterateRevealedCells(async (obj) => {
      if (obj.elem?.name === unit && obj.home === this) {
        count++;
      }
    });
    return count;
  }
  update() {
    super.update();
    if (this.updated && !this.elem?.dynamic && !this.elem?.spread?.moving && !this.doomed && Date.now() - this.bornTime < 1000 && !this.floatResources) {
      return;
    }
    const nowHoverered = this.manager.hovering(this);
    if (this.hovered !== nowHoverered) {
      this.hovered = nowHoverered;
      this.onHoverChange();
    }
    if (this.hoverIndic && this.elem?.onHover?.indic) {
      this.hoverIndic.tileInfo = this.getTileInfoAnimate(this.manager.animation.getInfo(this.elem.onHover.indic.animation));
    }
    if (this.selectIndic && this.elem?.selected?.indic) {
      this.selectIndic.tileInfo = this.getTileInfoAnimate(this.manager.animation.getInfo(this.elem.selected.indic.animation));
    }
    Object.values(this.moveOptions ?? {}).forEach((moveOption) => {
      if (moveOption.animation) {
        moveOption.tileInfo = this.getTileInfoAnimate(moveOption.animation);
      }
    });
    Object.values(this.attackOptions ?? {}).forEach((option) => {
      if (option.animation) {
        option.tileInfo = this.getTileInfoAnimate(option.animation);
      }
    });
    if (this.mouseFollower) {
      let px = mousePos.x + this.mouseFollower.offset.x;
      let py = mousePos.y + this.mouseFollower.offset.y;
      if (this.mouseFollower.snap) {
        px = Math.round(px / this.mouseFollower.snap) * this.mouseFollower.snap;
        py = Math.round(py / this.mouseFollower.snap) * this.mouseFollower.snap;
      }
      this.setPosition(px, py);
    }
    const offset = this.elem?.gameObject?.offset ?? [0, 0];
    const dx = this.px + offset[0] - this.pos.x;
    const dy = this.py + offset[1] - this.pos.y;
    const talking = this.talkingTime && Date.now() < this.talkingTime;
    const animInfo = this.attackAnimationInfo && this.attackTarget ? this.attackAnimationInfo : this.harvestAnimationInfo && this.elem?.harvesting ? this.harvestAnimationInfo : this.moveAnimationInfo && (dx || dy) ? this.moveAnimationInfo : this.selectedAnimationInfo && this.isRevealed() && (this.manager.selected === this || talking) ? this.selectedAnimationInfo : this.hoveredAnimationInfo && this.manager.hovering(this) ? this.hoveredAnimationInfo : this.animationInfo;
    if (animInfo === this.animationInfo) {
      if (Math.random() < 0.005) {
        this.talkingTime = Date.now() + Math.random() * 3000;
      }
    }
    if (animInfo) {
      this.tileInfo = this.getTileInfoAnimate(animInfo);
    }
    if (dx || dy) {
      const doMove = this.attackTarget || !animInfo?.airFramesSet || animInfo.airFramesSet?.has(this.getFrame(animInfo));
      if (doMove) {
        const immediate = !this.manager.isRevealed(this.px, this.py) && !this.manager.isRevealed(this.px + dx, this.py + dy);
        this.moving = true;
        if (dx * dx + dy * dy > 0.01) {
          const dist = this.elem?.gameObject?.speed ? Math.sqrt(dx * dx + dy * dy) : 1;
          const speed = immediate ? dist : Math.min(dist, this.attackTarget ? 0.2 : this.elem?.gameObject?.speed ?? 0.5);
          this.pos.set(this.pos.x + dx / dist * speed, this.pos.y + dy / dist * speed);
        } else {
          this.pos.set(this.px + offset[0], this.py + offset[1]);
        }
      }
    } else {
      if (this.attackTarget) {
        if (this.projectile) {
          this.projectile.move();
          if (this.projectile.landed()) {
            const projectile2 = this.projectile;
            this.projectile = undefined;
            projectile2.destroy();
            this.finishAttack(this.attackTarget, true);
          }
        } else {
          this.finishAttack(this.attackTarget);
        }
      } else if (this.moveQueue?.length) {
        const dest = this.moveQueue.pop();
        this.moveUnitTo(dest.x, dest.y);
      } else if (this.moving) {
        this.moving = false;
        if (this.onDone) {
          const onDone = this.onDone;
          this.onDone = undefined;
          onDone(this);
        } else if (!this.hasPendingActions) {
          if (!this.retaliating) {
            this.spendMove();
          } else {
            this.retaliating = false;
          }
        }
      }
    }
    if (this.elem?.type === "cursor") {
      if (mouseWasReleased(0)) {
        this.manager.mousePosDown = undefined;
        this.manager.onTap(this.px, this.py, mousePos.x, mousePos.y);
      }
    }
    const coLayers = this.manager.scene?.colayers;
    let renderOrder = Math.round(-this.py) + (this.manager.scene.layers?.[this.elem?.type ?? ""] ?? 100) * 1e4 + (coLayers?.[this.elem?.type ?? ""] ?? 0) * 0.001;
    if (this.renderOrder !== renderOrder || !this.updated) {
      this.renderOrder = renderOrder;
      this.decors.forEach((decor2) => {
        decor2.renderOrder = this.renderOrder + (this.elem?.spread?.behind ? -0.1 : 0.1);
      });
      if (this.moveOptions) {
        Object.values(this.moveOptions).forEach((moveOption) => moveOption.renderOrder = this.renderOrder - 0.1);
      }
      if (this.attackOptions) {
        Object.values(this.attackOptions).forEach((option) => option.renderOrder = this.renderOrder - 0.1);
      }
      if (this.projectile) {
        this.projectile.renderOrder = this.renderOrder + 0.1;
      }
      if (this.shadow) {
        this.shadow.renderOrder = this.renderOrder - 0.1;
      }
      if (this.hoverIndic) {
        this.hoverIndic.renderOrder = this.renderOrder - 0.1;
      }
      this.labels?.forEach((label) => label.renderOrder = this.renderOrder + 0.2);
      this.resources.forEach((resource) => resource.renderOrder = 1e5 + (resource.tileInfo ? 0.1 : -0.1));
      this.resourceBars.forEach((resource) => resource.renderOrder = 1e5 + (resource.tileInfo ? 0.1 : -0.1));
    }
    if (this.elem?.spread?.moving && Math.random() < this.elem.spread.moving) {
      this.decors.forEach((decor2) => {
        const time2 = Date.now() - decor2.bornTime;
        const dx2 = Math.sin(time2 / 5000 * decor2.motionX) * 0.2;
        const dy2 = Math.cos(time2 / 5000 * decor2.motionY) * 0.2;
        decor2.localPos.set(decor2.initialPos.x + dx2, decor2.initialPos.y + dy2);
      });
    }
    if (this.elem?.clearCloud && !this.clearedCloud) {
      const expansion = this.elem?.type === "house" && this.manager.isResearched("expansion", this.elem?.owner ?? 0);
      const SIZE = expansion ? 2 : 1, LIMIT = 2;
      for (let y = -SIZE;y <= SIZE; y++) {
        for (let x = -SIZE;x <= SIZE; x++) {
          if (Math.abs(x * y) < LIMIT * LIMIT) {
            this.manager.clearCloud(this.px + x, this.py + y);
          }
        }
      }
      this.clearedCloud = true;
    }
    this.updated = true;
    if (this.elem?.dynamic && Date.now() - this.bornTime < 1000) {
      this.updateSize();
    }
    if (this.doomed) {
      this.decors.forEach((decor2) => {
        const time2 = Date.now() - decor2.doomTime;
        if (time2 > 0) {
          decor2.size.set(decor2.size.x * 0.9, decor2.size.y * 0.9);
        }
      });
    }
    if (this.floatResources) {
      if (Date.now() - this.floatResources > 2000) {
        this.floatResources = undefined;
        this.hideResources();
        if (this.manager.selected === this) {
          this.showResourcesNearby();
        }
      } else {
        this.resources.forEach((res) => res.localPos.y += 0.005);
      }
    }
    if (this.damageTime) {
      const timeLeft = this.damageTime - Date.now();
      if (timeLeft >= 0) {
        this.angle = Math.sin(Date.now() / 10) * timeLeft / 5000;
        this.color = new Color(2, 0, 0, timeLeft / 1000);
      } else {
        this.damageTime = undefined;
        this.angle = 0;
        this.color = new Color(1, 1, 1, 1);
      }
    }
  }
  get home() {
    if (this.elem?.home && !this.elem?.building) {
      return this.manager.grid[GameObject.getTag("house", this.elem.home[0], this.elem.home[1])] ?? undefined;
    }
    return;
  }
  doomed = false;
  doom(immediate) {
    if (this.doomed) {
      return;
    }
    this.doomed = true;
    if (this.home) {
      this.home.unitsSupported.delete(this);
    }
    this.size.set(0, 0);
    const destroy = () => {
      if (this.manager.grid[this.getTag()] === this) {
        delete this.manager.grid[this.getTag()];
      }
      this.decors.forEach((decor2) => {
        decor2.destroy();
      });
      this.labels?.forEach((label) => label.destroy());
      this.resources.forEach((resource) => resource.destroy());
      this.resourceBars.forEach((bar) => bar.destroy());
      if (this.shadow) {
        this.shadow.destroy();
      }
      this.destroy();
    };
    const DURATION = immediate ? 10 : 300;
    setTimeout(destroy, DURATION * 2);
    if (!immediate) {
      this.decors.forEach((decor2) => {
        decor2.doomTime = Date.now() + DURATION * Math.random();
      });
    }
  }
  updateLabel(showLabel) {
    if (showLabel) {
      this.refreshLabel();
      this.refreshBars();
      this.refreshAlpha();
    } else {
      this.labels.forEach((label) => label.destroy());
      this.labels.length = 0;
      this.resourceBars.forEach((bar) => bar.destroy());
      this.resourceBars.length = 0;
      this.color = new Color(1, 1, 1, 1);
    }
  }
  getSurroundingCells(vectorCondition) {
    const set = new Set;
    for (let y = -1;y <= 1; y++) {
      for (let x = -1;x <= 1; x++) {
        const vec = vec2(this.px + x, this.py + y);
        if (vectorCondition(vec)) {
          set.add(vec);
        }
      }
    }
    return set;
  }
  findNearbyFoe(distance = 1) {
    return this.findNearby((cell) => {
      return cell.elem?.type === "unit" && cell.elem?.owner !== this.elem?.owner;
    }, distance);
  }
  async findNearby(cellCondition, distance = 1) {
    const set = new Set;
    for (let y = -distance;y <= distance; y++) {
      for (let x = -distance;x <= distance; x++) {
        if (x === 0 && y === 0) {
          continue;
        }
        await this.manager.iterateGridCell(this.px + x, this.py + y, async (cell) => {
          if (cellCondition(cell)) {
            set.add(cell);
          }
        });
      }
    }
    return set;
  }
  finalDestination() {
    return this.moveQueue?.[0] ?? vec2(this.px, this.py);
  }
  canAfford(resources) {
    if (!resources) {
      return true;
    }
    return Object.entries(resources).every(([key, value]) => {
      const res = this.manager.getResourceType(key);
      if (res?.global) {
        return this.manager.getPlayerResource(key, this.elem?.owner ?? 0) >= value;
      } else {
        return (this.elem?.resourcesAccumulated?.[key] ?? 0) >= value;
      }
    });
  }
  turnAround() {
    if (!this.elem?.gameObject) {
      return;
    }
    this.elem.gameObject.lastDx = -(this.elem.gameObject.lastDx ?? 1);
    this.updateSize();
  }
  spend(resources) {
    if (!resources) {
      return;
    }
    const resourcesAccumulated = this.elem?.resourcesAccumulated;
    Object.entries(resources).forEach(([key, value]) => {
      const k = key;
      const res = this.manager.getResourceType(k);
      if (res?.global) {
        this.manager.updateResource(k, (amount) => Math.max(0, amount - value), this.elem?.owner ?? 0);
      } else {
        if (resourcesAccumulated?.[k]) {
          resourcesAccumulated[k] = Math.max(0, resourcesAccumulated[k] - value);
        }
      }
    });
  }
  attack(target, retaliationDamage) {
    if (!target || target.elem?.owner === this.elem?.owner) {
      return;
    }
    this.attackTarget = target;
    this.attackOrigin = vec2(this.px, this.py);
    this.px = target.px;
    this.py = target.py;
    this.retaliationDamage = retaliationDamage;
  }
  attackRange(target, retaliationDamage) {
    if (!target || target.elem?.owner === this.elem?.owner) {
      return;
    }
    this.attackTarget = target;
    this.attackOrigin = vec2(this.px, this.py);
    this.retaliationDamage = this.retaliationDamage;
    if (this.projectile) {
      this.projectile.destroy();
    }
    this.projectile = new Projectile(this.pos, target.pos, 0.05);
    if (this.elem?.attack?.projectile) {
      this.projectile.tileInfo = this.getTileInfoAnimate(this.manager.animation.getInfo(this.elem.attack.projectile));
    }
  }
  finishAttack(target, done = false) {
    const { px: targetX, py: targetY } = target;
    const { retaliation, death } = !this.retaliating ? target.takeDamageAndCheckDeath(this.elem?.attack?.damage ?? 1, this) : target.takeDirectDamageAndCheckDeath(this.retaliationDamage);
    this.px = this.attackOrigin?.x ?? this.px;
    this.py = this.attackOrigin?.y ?? this.py;
    this.attackTarget = undefined;
    this.attackOrigin = undefined;
    if (!this.retaliating) {
      this.spendAttack();
      if (death) {
        if (!this.elem?.attack?.range) {
          this.setPosition(targetX, targetY);
        }
        this.doneMoving();
      } else {
        const dx = this.px - targetX;
        const dy = this.py - targetY;
        const distance = Math.max(Math.abs(dx), Math.abs(dy));
        if (distance <= (target?.elem?.attack?.range ?? 1)) {
          this.hasPendingActions = true;
          this.onDone = (self) => {
            setTimeout(() => {
              target.retaliating = true;
              target.onDone = (target2) => {
                target2.retaliating = false;
                self.hasPendingActions = false;
                self.doneMoving();
              };
              const rangedAttack = target?.elem?.attack?.range;
              if (rangedAttack) {
                target.attackRange(self, retaliation);
              } else {
                target.attack(self, retaliation);
              }
            }, 1000);
          };
          if (done) {
            const onDone = this.onDone;
            this.onDone = undefined;
            onDone(this);
          }
        } else {
          this.doneMoving();
        }
      }
    } else {
      target.doneMoving();
    }
  }
  getDefenseBonus() {
    let bonus = 1;
    this.manager.iterateGridCell(this.px, this.py, async (cell) => {
      if (cell.elem?.defenseBonus) {
        bonus *= cell.elem.defenseBonus;
      }
    });
    return bonus;
  }
  healthPercent() {
    return this.elem?.hitpoints ? this.elem.hitpoints / (this.elem.maxHitPoints ?? 1) : 1;
  }
  getDefense() {
    return this.elem?.attack?.defense ?? 1;
  }
  takeDirectDamageAndCheckDeath(damage = 0) {
    if (this.elem) {
      this.damageTime = Date.now() + damage * 100;
      this.elem.hitpoints = (this.elem.hitpoints ?? 1) - damage;
      if (this.elem.hitpoints > 0) {
        this.refreshLabel();
      } else {
        this.doom(true);
        return { retaliation: 0, death: true };
      }
    }
    return { retaliation: 0, death: false };
  }
  takeDamageAndCheckDeath(attack, attacker) {
    if (this.elem) {
      const attackForce = attack * attacker.healthPercent();
      const defenseForce = this.getDefense() * this.healthPercent() * this.getDefenseBonus();
      const totalDamage = attackForce + defenseForce;
      const attackResult = Math.ceil(attackForce / totalDamage * attack * 4.5);
      const defenseResult = Math.ceil(defenseForce / totalDamage * this.getDefense() * 4.5);
      this.damageTime = Date.now() + attackResult * 100;
      this.elem.hitpoints = (this.elem.hitpoints ?? 1) - attackResult;
      if (this.elem.hitpoints > 0) {
        this.refreshLabel();
        return { retaliation: defenseResult, death: false };
      } else {
        this.doom(true);
        return { retaliation: 0, death: true };
      }
    }
    return { retaliation: 0, death: false };
  }
}

// src/content/constant.ts
var SIZE = 30;
var DEBUG = window.location.search.includes("debug");
var READY = true;

// src/ui/hud.ts
var SPRITESHEET_COLS = 30;
speechSynthesis.getVoices();

class Hud {
  manager;
  ui = document.createElement("div");
  bg = document.createElement("div");
  buttonsOverlay = document.createElement("div");
  quickActionOverlay = document.createElement("div");
  resourceOverlay = document.createElement("div");
  blocker = document.createElement("div");
  dialog = document.createElement("div");
  cat = document.createElement("img");
  itemsToDestroy = new Set;
  nextButton = document.createElement("button");
  endButton = document.createElement("button");
  researchList = document.createElement("div");
  researchInfoDiv = document.createElement("div");
  researchPopup = document.createElement("div");
  spaceshipPopup = document.createElement("div");
  music = document.createElement("audio");
  updated = false;
  onKnob = false;
  constructor(manager) {
    this.manager = manager;
  }
  initialize() {
    this.ui.id = "hud";
    this.ui.classList.add("hud");
    document.body.appendChild(this.ui);
    this.ui.addEventListener("mouseover", (e) => {
      this.manager.inUI = true;
      this.manager.cursor?.hide();
    });
    this.ui.addEventListener("mouseout", (e) => {
      this.manager.inUI = false;
      this.manager.refreshCursor();
    });
    this.ui.style.display = "none";
    this.bg.style.width = "100%";
    this.bg.style.height = "100px";
    this.bg.style.position = "absolute";
    this.bg.style.zIndex = "100";
    this.bg.style.bottom = "-100px";
    this.bg.style.left = "0";
    this.bg.style.background = "rgba(0, 0, 0, 1)";
    this.bg.style.transition = "bottom 0.2s";
    this.bg.style.display = "flex";
    this.bg.style.color = "snow";
    this.bg.style.flexDirection = "row";
    this.ui.appendChild(this.bg);
    this.quickActionOverlay.style.position = "absolute";
    this.quickActionOverlay.style.zIndex = "100";
    this.quickActionOverlay.style.left = "0";
    this.quickActionOverlay.style.bottom = "-100px";
    this.quickActionOverlay.style.display = "flex";
    this.quickActionOverlay.style.flexDirection = "row";
    this.quickActionOverlay.style.transition = "bottom 0.2s";
    this.ui.appendChild(this.quickActionOverlay);
    this.buttonsOverlay.style.bottom = "0";
    this.buttonsOverlay.style.right = "0";
    this.buttonsOverlay.style.zIndex = "100";
    this.buttonsOverlay.style.position = "absolute";
    this.buttonsOverlay.style.display = "flex";
    this.buttonsOverlay.style.flexDirection = "column";
    this.buttonsOverlay.style.justifyContent = "right";
    this.buttonsOverlay.style.gap = "10px";
    this.buttonsOverlay.style.padding = "10px";
    this.buttonsOverlay.style.transition = "right 0.2s";
    this.buttonsOverlay.style.display = "none";
    this.ui.appendChild(this.buttonsOverlay);
    this.setHudButtons();
    this.resourceOverlay.style.position = "absolute";
    this.resourceOverlay.style.top = "0";
    this.resourceOverlay.style.left = "0";
    this.resourceOverlay.style.zIndex = "100";
    this.resourceOverlay.style.display = "none";
    this.ui.appendChild(this.resourceOverlay);
    this.blocker.style.width = "100%";
    this.blocker.style.height = "100%";
    this.blocker.style.position = "absolute";
    this.blocker.style.zIndex = "100";
    this.blocker.style.top = "0";
    this.blocker.style.left = "0";
    this.blocker.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
    this.blocker.style.display = "none";
    this.ui.appendChild(this.blocker);
    this.dialog.style.position = "absolute";
    this.dialog.style.zIndex = "100";
    this.dialog.style.bottom = "10px";
    this.dialog.style.left = "50%";
    this.dialog.style.transform = "translate(-50%, 0)";
    this.dialog.style.width = "80%";
    this.dialog.style.height = "200px";
    this.dialog.style.backgroundColor = "rgba(0, 0, 0, .7)";
    this.dialog.style.color = "snow";
    this.dialog.style.flexDirection = "column";
    this.dialog.style.justifyContent = "center";
    this.dialog.style.alignItems = "center";
    this.dialog.style.textAlign = "center";
    this.dialog.style.textTransform = "uppercase";
    this.dialog.style.whiteSpace = "pre-wrap";
    this.dialog.style.display = "none";
    this.dialog.style.pointerEvents = "none";
    this.ui.appendChild(this.dialog);
    this.cat.style.position = "absolute";
    this.cat.style.bottom = "0";
    this.cat.style.left = "0";
    this.cat.src = "./assets/cat.png";
    this.cat.style.display = "none";
    this.cat.style.zIndex = "100";
    this.ui.appendChild(this.cat);
    this.researchList.style.position = "absolute";
    this.researchList.style.zIndex = "100";
    this.researchList.style.top = "50%";
    this.researchList.style.left = "50%";
    this.researchList.style.transform = "translate(-50%, -50%)";
    this.researchList.style.width = "400px";
    this.researchList.style.height = "200px";
    this.researchList.style.backgroundColor = "rgba(0, 0, 0, .7)";
    this.researchList.style.color = "snow";
    this.researchList.style.flexDirection = "column";
    this.researchList.style.justifyContent = "center";
    this.researchList.style.alignItems = "center";
    this.researchList.style.textAlign = "center";
    this.researchList.style.textTransform = "uppercase";
    this.researchList.style.cursor = "pointer";
    this.researchList.style.display = "none";
    this.ui.appendChild(this.researchList);
    this.researchInfoDiv.style.position = "absolute";
    this.researchInfoDiv.style.zIndex = "100";
    this.researchInfoDiv.style.top = "10px";
    this.researchInfoDiv.style.right = "10px";
    this.researchInfoDiv.style.width = "200px";
    this.researchInfoDiv.style.height = "60px";
    this.researchInfoDiv.style.backgroundColor = "rgba(0, 0, 0, .7)";
    this.researchInfoDiv.style.color = "snow";
    this.researchInfoDiv.style.flexDirection = "column";
    this.researchInfoDiv.style.justifyContent = "center";
    this.researchInfoDiv.style.alignItems = "center";
    this.researchInfoDiv.style.textAlign = "center";
    this.researchInfoDiv.style.textTransform = "uppercase";
    this.researchInfoDiv.style.display = "none";
    this.ui.appendChild(this.researchInfoDiv);
    this.researchPopup.style.position = "absolute";
    this.researchPopup.style.zIndex = "100";
    this.researchPopup.style.top = "50%";
    this.researchPopup.style.left = "50%";
    this.researchPopup.style.transform = "translate(-50%, -50%)";
    this.researchPopup.style.width = "800px";
    this.researchPopup.style.height = "600px";
    this.researchPopup.style.backgroundImage = "url(./assets/researched.png)";
    this.researchPopup.style.backgroundSize = "cover";
    this.researchPopup.style.pointerEvents = "none";
    this.researchPopup.style.opacity = "0";
    this.researchPopup.style.transition = "opacity .2s";
    this.researchPopup.style.display = "none";
    this.spaceshipPopup.style.position = "absolute";
    this.spaceshipPopup.style.zIndex = "100";
    this.spaceshipPopup.style.top = "50%";
    this.spaceshipPopup.style.left = "50%";
    this.spaceshipPopup.style.transform = "translate(-50%, -50%)";
    this.spaceshipPopup.style.width = "800px";
    this.spaceshipPopup.style.height = "600px";
    this.spaceshipPopup.style.backgroundImage = "url(./assets/spaceship.png)";
    this.spaceshipPopup.style.backgroundSize = "cover";
    this.spaceshipPopup.style.pointerEvents = "none";
    this.spaceshipPopup.style.opacity = "0";
    this.spaceshipPopup.style.transition = "opacity .2s";
    this.spaceshipPopup.style.display = "none";
    const researchImage = this.researchPopup.appendChild(document.createElement("div"));
    researchImage.id = "researchImage";
    researchImage.style.position = "absolute";
    researchImage.style.top = "30%";
    researchImage.style.left = "50%";
    researchImage.style.transform = "translate(-50%, -50%) scale(3)";
    researchImage.style.transition = "opacity 3s";
    researchImage.style.opacity = "0";
    this.ui.appendChild(this.researchPopup);
    const researchText = this.researchPopup.appendChild(document.createElement("div"));
    researchText.id = "researchText";
    researchText.style.position = "absolute";
    researchText.style.bottom = "10px";
    researchText.style.left = "50%";
    researchText.style.transform = "translate(-50%, 0)";
    researchText.style.width = "80%";
    researchText.style.height = "100px";
    researchText.style.backgroundColor = "rgba(0, 0, 0, .7)";
    researchText.style.color = "snow";
    researchText.style.flexDirection = "column";
    researchText.style.justifyContent = "center";
    researchText.style.alignItems = "center";
    researchText.style.textAlign = "center";
    researchText.style.textTransform = "uppercase";
    researchText.style.display = "flex";
    researchText.style.pointerEvents = "none";
    const spaceshipText = this.spaceshipPopup.appendChild(document.createElement("div"));
    spaceshipText.id = "spaceshipText";
    spaceshipText.style.position = "absolute";
    spaceshipText.style.bottom = "10px";
    spaceshipText.style.left = "50%";
    spaceshipText.style.transform = "translate(-50%, 0)";
    spaceshipText.style.width = "80%";
    spaceshipText.style.height = "100px";
    spaceshipText.style.backgroundColor = "rgba(0, 0, 0, .7)";
    spaceshipText.style.color = "snow";
    spaceshipText.style.flexDirection = "column";
    spaceshipText.style.justifyContent = "center";
    spaceshipText.style.alignItems = "center";
    spaceshipText.style.textAlign = "center";
    spaceshipText.style.textTransform = "uppercase";
    spaceshipText.style.display = "flex";
    spaceshipText.style.pointerEvents = "none";
    spaceshipText.style.whiteSpace = "pre-wrap";
    this.ui.appendChild(this.spaceshipPopup);
    this.setupShortcutKeys();
    this.initializeErrorBanner();
    this.setupMusic();
    this.setupQuickActions();
  }
  setupMusic() {
    this.music.src = "./assets/animal-anthem.mp3";
    this.music.loop = true;
    this.music.preload = "auto";
  }
  setupShortcutKeys() {
    document.addEventListener("keyup", (e) => {
      if (e.code === "KeyE") {
        this.endButton.click();
      }
      if (e.code === "KeyN") {
        this.nextButton.click();
      }
      if (e.code === "Escape") {
        this.manager.setSelection(undefined);
      }
    });
  }
  async refresh() {
    if (this.updated) {
      return;
    }
    if (this.manager.getPlayer()) {
      this.endButton.innerHTML = `<u style='color: blue'>E</u>nd turn ${this.manager.getTurn()}`;
      this.refreshResources();
      this.refreshTax();
      this.refreshButtons();
      this.refreshResearchInfo();
      this.ui.style.display = "block";
      this.updated = true;
    }
  }
  refreshButtons() {
    const player = this.manager.getPlayer();
    this.nextButton.style.display = this.manager.getUnits(player).size > 1 ? "block" : "none";
  }
  async refreshTax() {
    const player = this.manager.getPlayer();
    const RESOURCES = this.manager.getAllGlobalResources();
    const revenuePerResource = await this.manager.calculateResourceRevenue(player);
    const hasRevenue = Object.values(revenuePerResource).some((value) => value > 0);
    RESOURCES.forEach((resource, index) => {
      let taxValue = this.manager.getTaxValue(this.manager.getPlayer());
      if (index === 0) {
        taxValue = 100 - taxValue;
      }
      let revenueValue = revenuePerResource[resource];
      const taxText = document.getElementById(`${resource}-tax`);
      if (taxText) {
        taxText.textContent = `${revenueValue >= 0 ? "+" : ""}${revenueValue} (${taxValue}%)`;
      }
    });
    let taxKnob = document.getElementById("tax");
    if (!taxKnob) {
      taxKnob = this.resourceOverlay.appendChild(document.createElement("input"));
      taxKnob.id = "tax";
      taxKnob.type = "range";
      taxKnob.min = "0";
      taxKnob.max = "100";
      taxKnob.step = "5";
      taxKnob.value = `${this.manager.getTaxValue(this.manager.getPlayer())}`;
      taxKnob.style.width = "60px";
      taxKnob.style.marginTop = "20px";
      taxKnob.addEventListener("input", (e) => {
        this.manager.updateTaxValue(player, parseInt(taxKnob.value));
        this.refreshTax();
        this.refreshResearchInfo();
      });
      taxKnob.addEventListener("mouseover", (e) => {
        this.onKnob = true;
      });
      taxKnob.addEventListener("mouseout", (e) => {
        this.onKnob = false;
      });
    }
    taxKnob.style.display = hasRevenue ? "block" : "none";
  }
  async refreshResources() {
    const RESOURCES = this.manager.getAllGlobalResources();
    RESOURCES.forEach((resource, index) => {
      const resourceData = this.manager.getResourceType(resource);
      if (!resourceData) {
        return;
      }
      const { imageSource, spriteSize, frames, padding } = resourceData.icon;
      const spriteWidth = spriteSize[0] + (padding?.[0] ?? 2) * 2;
      const spriteHeight = spriteSize[1] + (padding?.[1] ?? 2) * 2;
      let icon = document.getElementById(resource);
      if (!icon) {
        icon = this.resourceOverlay.appendChild(document.createElement("div"));
        icon.id = resource;
        icon.style.backgroundImage = `url(${imageSource})`;
        icon.style.width = `${spriteWidth}px`;
        icon.style.height = `${spriteHeight}px`;
        icon.classList.add("resource-icon");
        icon.style.backgroundPosition = `${-spriteWidth * (frames[0] % 30) + (padding?.[0] ?? 2) / 2}px ${-spriteHeight * Math.floor(frames[0] / 30) + (padding?.[1] ?? 2) / 2}px`;
        icon.textContent = "0";
        this.resourceOverlay.appendChild(icon);
      }
      let taxValue = this.manager.getTaxValue(this.manager.getPlayer());
      if (index === 0) {
        taxValue = 100 - taxValue;
      }
      const newText = `${this.manager.getPlayerResource(resource, this.manager.getPlayer())}`;
      if (icon.textContent !== newText) {
        icon.textContent = newText;
        icon.style.backgroundColor = "rgba(255, 50, 255, 0.5)";
        setTimeout(() => {
          icon.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
        }, 1500);
      }
      const taxText = document.getElementById(`${resource}-tax`) ?? this.resourceOverlay.appendChild(document.createElement("div"));
      taxText.id = `${resource}-tax`;
      taxText.style.color = "white";
      taxText.style.width = "100%";
      taxText.style.marginTop = "-20px";
      taxText.style.textAlign = "center";
      taxText.style.fontSize = "8pt";
    });
    const revenuePerResource = await this.manager.calculateResourceRevenue(this.manager.getPlayer());
    const hasRevenue = Object.values(revenuePerResource).some((value) => value > 0);
    const hasResource = RESOURCES.some((resource) => this.manager.getPlayerResource(resource, this.manager.getPlayer()) > 0);
    this.resourceOverlay.style.display = hasRevenue || hasResource ? "block" : "none";
  }
  flashEndTurn(temp = false) {
    this.buttonsOverlay.style.display = "block";
    document.getElementById("endButton")?.classList.add(temp ? "flash-temp" : "flash");
    if (temp) {
      this.stopFlashEndTurn();
      setTimeout(() => {
        document.getElementById("endButton")?.classList.remove("flash-temp");
      }, 1000);
    }
  }
  stopFlashEndTurn() {
    document.getElementById("endButton")?.classList.remove("flash");
  }
  setupQuickActions() {
    const quickActions = this.manager.quickActions();
    quickActions.forEach((action) => {
      const { imageSource, spriteSize, frames, padding } = action.icon;
      const icon = this.quickActionOverlay.appendChild(document.createElement("div"));
      icon.style.backgroundImage = `url(${imageSource})`;
      icon.style.width = `${spriteSize[0]}px`;
      icon.style.height = `${spriteSize[1]}px`;
      icon.title = action.description;
      const spriteWidth = spriteSize[0] + (padding?.[0] ?? 2) * 2;
      const spriteHeight = spriteSize[1] + (padding?.[1] ?? 2) * 2;
      icon.style.backgroundPosition = `${-spriteWidth * (frames[0] % SPRITESHEET_COLS)}px ${-spriteHeight * Math.floor(frames[0] / SPRITESHEET_COLS)}px`;
      icon.style.cursor = "pointer";
      icon.style.backgroundColor = "rgb(50, 50, 50, .3)";
      icon.addEventListener("mouseover", (e) => {
        icon.style.backgroundColor = "rgb(200, 200, 0, .7)";
      });
      icon.addEventListener("mouseout", (e) => {
        icon.style.backgroundColor = "rgb(50, 50, 50, .3)";
      });
      icon.addEventListener("click", (e) => {
        this.manager.performQuickAction(action);
      });
    });
  }
  setHudButtons() {
    const nextButton = this.buttonsOverlay.appendChild(this.nextButton);
    nextButton.innerHTML = "<u style='color: blue'>N</u>ext unit";
    nextButton.id = "nextButton";
    nextButton.style.width = "150px";
    nextButton.addEventListener("click", (e) => {
      this.manager.selectNext();
    });
    nextButton.style.display = "none";
    const endButton = this.buttonsOverlay.appendChild(this.endButton);
    endButton.style.width = "150px";
    endButton.id = "endButton";
    endButton.addEventListener("click", (e) => {
      this.stopFlashEndTurn();
      this.manager.gotoNextTurn();
    });
    endButton.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
    endButton.addEventListener("mouseup", (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
    const autoEndGroup = this.buttonsOverlay.appendChild(document.createElement("div"));
    const autoEndLabel = autoEndGroup.appendChild(document.createElement("label"));
    autoEndLabel.textContent = "auto-end turn";
    autoEndLabel.htmlFor = "autoEndCheckbox";
    autoEndLabel.title = "Automatically end turn when no more moves are available";
    const autoEndCheckbox = autoEndGroup.appendChild(document.createElement("input"));
    autoEndCheckbox.id = "autoEndCheckbox";
    autoEndCheckbox.type = "checkbox";
    autoEndCheckbox.checked = this.manager.autoEndTurn;
    autoEndCheckbox.addEventListener("change", (e) => {
      this.manager.autoEndTurn = autoEndCheckbox.checked;
      if (this.manager.autoEndTurn) {
        this.stopFlashEndTurn();
        this.manager.checkForAnyMove();
      }
    });
    const zoomGroup = this.buttonsOverlay.appendChild(document.createElement("div"));
    zoomGroup.style.display = "flex";
    zoomGroup.style.flexDirection = "row";
    zoomGroup.style.justifyContent = "center";
    zoomGroup.style.alignItems = "center";
    zoomGroup.style.gap = "10px";
    const zoomLabel = zoomGroup.appendChild(document.createElement("label"));
    zoomLabel.textContent = "zoom";
    zoomLabel.htmlFor = "zoom";
    const zoomKnob = zoomGroup.appendChild(document.createElement("input"));
    zoomKnob.id = "zoom";
    zoomKnob.type = "range";
    zoomKnob.min = "40";
    zoomKnob.max = "200";
    zoomKnob.step = "5";
    zoomKnob.value = "80";
    zoomKnob.style.width = "100px";
    zoomKnob.style.marginTop = "20px";
    zoomKnob.addEventListener("input", (e) => {
      setCameraScale(parseInt(zoomKnob.value));
    });
    zoomKnob.addEventListener("mouseover", (e) => {
      this.onKnob = true;
    });
    zoomKnob.addEventListener("mouseout", (e) => {
      this.onKnob = false;
    });
  }
  clear() {
    this.itemsToDestroy.forEach((item) => item());
    this.itemsToDestroy.clear();
  }
  async showSelected(obj) {
    const menu = this.manager.getMenu(obj?.elem?.name);
    this.bg.style.bottom = menu?.items.length ? "0" : "-400px";
    this.quickActionOverlay.style.bottom = obj?.elem?.type !== "unit" || obj?.elem?.disableQuickActions ? "-100px" : menu?.items.length ? "100px" : "0";
    this.buttonsOverlay.style.right = menu?.items.length ? "-200px" : "0";
    this.bg.innerHTML = "";
    this.clear();
    if (!menu?.items.length) {
      return;
    }
    if (!obj) {
      return;
    }
    {
      const iconDiv = this.bg.appendChild(document.createElement("div"));
      const { imageSource, spriteSize, frames, padding } = menu.icon;
      const icon = iconDiv.appendChild(document.createElement("div"));
      icon.style.backgroundImage = `url(${imageSource})`;
      icon.style.width = `${spriteSize[0]}px`;
      icon.style.height = `${spriteSize[1]}px`;
      const spriteWidth = spriteSize[0] + (padding?.[0] ?? 2) * 2;
      const spriteHeight = spriteSize[1] + (padding?.[1] ?? 2) * 2;
      let animationFrame;
      const animateIcon = () => {
        animationFrame = requestAnimationFrame(animateIcon);
        const frame2 = frames[Math.floor(performance.now() / 100) % frames.length];
        icon.style.backgroundPosition = `${-spriteWidth * (frame2 % SPRITESHEET_COLS)}px ${-spriteHeight * Math.floor(frame2 / SPRITESHEET_COLS)}px`;
      };
      animateIcon();
      this.itemsToDestroy.add(() => cancelAnimationFrame(animationFrame));
      const label = iconDiv.appendChild(document.createElement("div"));
      label.innerText = menu.name;
      label.style.textAlign = "center";
      label.style.fontSize = "10pt";
      label.style.color = "silver";
      label.style.pointerEvents = "none";
      const descDiv = this.bg.appendChild(document.createElement("div"));
      const desc = descDiv.appendChild(document.createElement("div"));
      desc.style.margin = "20px 20px";
      desc.style.color = "silver";
      desc.style.width = "0px";
      const descContent = desc.appendChild(document.createElement("div"));
      descContent.style.position = "absolute";
      descContent.style.maxWidth = "200px";
      descContent.style.pointerEvents = "none";
      descContent.textContent = menu.description ?? "";
      const healthDiv = descDiv.appendChild(document.createElement("div"));
      healthDiv.style.position = "absolute";
      healthDiv.style.right = "0";
      healthDiv.style.top = "0";
      if (obj.elem?.type === "house") {
        const resourcesRevenue = obj.calculateUnitResourcesRevenue();
        {
          const wheat = healthDiv.appendChild(document.createElement("div"));
          wheat.style.display = "flex";
          wheat.style.flexDirection = "row";
          wheat.style.alignItems = "center";
          wheat.style.justifyContent = "left";
          wheat.style.margin = "3px 10px";
          wheat.style.height = "16px";
          const wheatResourceType = this.manager.getResourceType("wheat");
          if (wheatResourceType) {
            const { imageSource: imageSource2, spriteSize: spriteSize2, frames: frames2, padding: padding2 } = wheatResourceType.icon;
            const icon2 = wheat.appendChild(document.createElement("div"));
            icon2.style.backgroundImage = `url(${imageSource2})`;
            icon2.style.width = `${spriteSize2[0]}px`;
            icon2.style.height = `${spriteSize2[1]}px`;
            icon2.style.transform = "scale(.5)";
            const spriteWidth2 = spriteSize2[0] + (padding2?.[0] ?? 2) * 2;
            const spriteHeight2 = spriteSize2[1] + (padding2?.[1] ?? 2) * 2;
            icon2.style.backgroundPosition = `${-spriteWidth2 * (frames2[0] % SPRITESHEET_COLS)}px ${-spriteHeight2 * Math.floor(frames2[0] / SPRITESHEET_COLS)}px`;
          }
          const cost = obj.nextLevelCost();
          const label2 = wheat.appendChild(document.createElement("div"));
          label2.style.fontSize = "10pt";
          label2.style.color = "gold";
          label2.textContent = `(+${resourcesRevenue["wheat"]}) ${obj.elem.resourcesAccumulated?.wheat ?? 0} / ${cost}`;
        }
        {
          const wood = healthDiv.appendChild(document.createElement("div"));
          wood.style.display = "flex";
          wood.style.flexDirection = "row";
          wood.style.alignItems = "center";
          wood.style.justifyContent = "left";
          wood.style.margin = "3px 10px";
          wood.style.height = "16px";
          const woodResourceType = this.manager.getResourceType("wood");
          if (woodResourceType) {
            const { imageSource: imageSource2, spriteSize: spriteSize2, frames: frames2, padding: padding2 } = woodResourceType.icon;
            const icon2 = wood.appendChild(document.createElement("div"));
            icon2.style.backgroundImage = `url(${imageSource2})`;
            icon2.style.width = `${spriteSize2[0]}px`;
            icon2.style.height = `${spriteSize2[1]}px`;
            icon2.style.transform = "scale(.5)";
            const spriteWidth2 = spriteSize2[0] + (padding2?.[0] ?? 2) * 2;
            const spriteHeight2 = spriteSize2[1] + (padding2?.[1] ?? 2) * 2;
            icon2.style.backgroundPosition = `${-spriteWidth2 * (frames2[0] % SPRITESHEET_COLS)}px ${-spriteHeight2 * Math.floor(frames2[0] / SPRITESHEET_COLS)}px`;
          }
          const label2 = wood.appendChild(document.createElement("div"));
          label2.style.fontSize = "10pt";
          label2.style.color = "orange";
          const capacity = obj.resourceCapacity("wood");
          label2.textContent = `(+${resourcesRevenue["wood"]}) ${obj.elem.resourcesAccumulated?.wood ?? 0} / ${capacity}`;
        }
        {
          const trade = healthDiv.appendChild(document.createElement("div"));
          trade.style.display = "flex";
          trade.style.flexDirection = "row";
          trade.style.alignItems = "center";
          trade.style.justifyContent = "left";
          trade.style.margin = "3px 10px";
          trade.style.height = "16px";
          const tradeResourceType = this.manager.getResourceType("trade");
          if (tradeResourceType) {
            const { imageSource: imageSource2, spriteSize: spriteSize2, frames: frames2, padding: padding2 } = tradeResourceType.icon;
            const icon2 = trade.appendChild(document.createElement("div"));
            icon2.style.backgroundImage = `url(${imageSource2})`;
            icon2.style.width = `${spriteSize2[0]}px`;
            icon2.style.height = `${spriteSize2[1]}px`;
            icon2.style.transform = "scale(.5)";
            const spriteWidth2 = spriteSize2[0] + (padding2?.[0] ?? 2) * 2;
            const spriteHeight2 = spriteSize2[1] + (padding2?.[1] ?? 2) * 2;
            icon2.style.backgroundPosition = `${-spriteWidth2 * (frames2[0] % SPRITESHEET_COLS)}px ${-spriteHeight2 * Math.floor(frames2[0] / SPRITESHEET_COLS)}px`;
          }
          const label2 = trade.appendChild(document.createElement("div"));
          label2.style.fontSize = "10pt";
          label2.style.color = "teal";
          label2.textContent = `(+${resourcesRevenue["trade"]})`;
        }
      }
    }
    {
      const menuDiv = this.bg.appendChild(document.createElement("div"));
      menuDiv.style.display = "flex";
      menuDiv.style.flexDirection = "row";
      menuDiv.style.justifyContent = "center";
      menuDiv.style.alignItems = "center";
      menuDiv.style.flexGrow = "1";
      menuDiv.style.margin = "0 10px";
      menuDiv.style.marginLeft = "-100px";
      menuDiv.style.gap = "10px";
      for (const item of menu.items) {
        if (item.debug && !DEBUG) {
          continue;
        }
        if (await this.manager.checkCondition(item.hidden, obj)) {
          continue;
        }
        const researched = !item.researchNeeded?.length || item.researchNeeded?.every((research) => this.manager.isResearched(research, this.manager.getPlayer()));
        if (!researched) {
          continue;
        }
        const disabled = (!researched ? `Research\n${item.researchNeeded?.join(", ")}` : undefined) || await this.manager.checkCondition(item.disabled, obj) || (obj.canAfford(item.resourceCost) ? null : "not enough\nresources");
        const menuItemDiv = menuDiv.appendChild(document.createElement("div"));
        if (item.resourceCost && researched) {
          const resourceDiv = menuItemDiv.appendChild(document.createElement("div"));
          resourceDiv.style.display = "flex";
          resourceDiv.style.flexDirection = "row";
          resourceDiv.style.marginTop = "-55px";
          resourceDiv.style.marginLeft = "-60px";
          resourceDiv.style.position = "absolute";
          const cost = item.resourceCost;
          Object.entries(cost ?? {}).forEach(([key, amount]) => {
            const resource = key;
            const resourceData = this.manager.getResourceType(resource);
            if (!resourceData) {
              return;
            }
            const { imageSource: imageSource2, spriteSize: spriteSize2, frames: frames2, padding: padding2 } = resourceData.icon;
            const icon2 = resourceDiv.appendChild(document.createElement("div"));
            icon2.style.backgroundImage = `url(${imageSource2})`;
            icon2.style.width = `${spriteSize2[0]}px`;
            icon2.style.height = `${spriteSize2[1]}px`;
            icon2.style.transform = "scale(.5)";
            icon2.style.marginTop = "-25px";
            const spriteWidth2 = spriteSize2[0] + (padding2?.[0] ?? 2) * 2;
            const spriteHeight2 = spriteSize2[1] + (padding2?.[1] ?? 2) * 2;
            icon2.style.backgroundPosition = `${-spriteWidth2 * (frames2[0] % SPRITESHEET_COLS)}px ${-spriteHeight2 * Math.floor(frames2[0] / SPRITESHEET_COLS)}px`;
            const label2 = resourceDiv.appendChild(document.createElement("div"));
            label2.style.fontSize = "10pt";
            label2.style.marginLeft = "-20px";
            label2.style.color = "gold";
            label2.textContent = `${amount}`;
          });
        } else {
          const text = menuItemDiv.appendChild(document.createElement("div"));
          text.textContent = item.label ?? item.name;
          text.style.position = "absolute";
          text.style.top = "0";
          text.style.fontSize = "10pt";
          text.style.color = "red";
          text.style.display = disabled ? "block" : "none";
        }
        menuItemDiv.style.cursor = "pointer";
        menuItemDiv.style.display = "flex";
        menuItemDiv.style.alignItems = "center";
        menuItemDiv.style.justifyContent = "center";
        menuItemDiv.style.flexDirection = "column";
        const { imageSource, spriteSize, frames, padding } = item;
        const icon = menuItemDiv.appendChild(document.createElement("div"));
        icon.style.backgroundImage = `url(${imageSource})`;
        icon.style.width = `${spriteSize[0]}px`;
        icon.style.height = `${spriteSize[1]}px`;
        const cols = 30;
        const spriteWidth = spriteSize[0] + (padding?.[0] ?? 2) * 2;
        const spriteHeight = spriteSize[1] + (padding?.[1] ?? 2) * 2;
        let animationFrame;
        const animateIcon = () => {
          animationFrame = requestAnimationFrame(animateIcon);
          const frame2 = frames[Math.floor(performance.now() / 100) % frames.length];
          icon.style.backgroundPosition = `${-spriteWidth * (frame2 % cols)}px ${-spriteHeight * Math.floor(frame2 / SPRITESHEET_COLS)}px`;
        };
        animateIcon();
        this.itemsToDestroy.add(() => cancelAnimationFrame(animationFrame));
        const label = menuItemDiv.appendChild(document.createElement("div"));
        label.innerText = disabled ?? item?.label ?? item.name;
        label.style.textAlign = "center";
        label.style.fontSize = "10pt";
        menuItemDiv.style.backgroundColor = "rgba(100, 100, 100, 0.5)";
        if (!disabled) {
          menuItemDiv.addEventListener("mouseover", () => {
            menuItemDiv.style.backgroundColor = "rgba(100, 100, 100, 1)";
          });
          menuItemDiv.addEventListener("mouseout", () => {
            menuItemDiv.style.backgroundColor = "rgba(100, 100, 100, 0.5)";
          });
          menuItemDiv.addEventListener("mousedown", (e) => {
            menuItemDiv.style.backgroundColor = "rgba(250, 250, 150, .5)";
            e.preventDefault();
            e.stopPropagation();
          });
          menuItemDiv.addEventListener("click", async (e) => {
            menuItemDiv.style.backgroundColor = "rgba(100, 100, 100, 0.5)";
            if (disabled) {
              return;
            }
            obj.spend(item.resourceCost);
            const actions = item.actions ?? [];
            for (const action of actions) {
              await this.manager.performAction(action, obj);
            }
            obj.refreshLabel();
            this.updated = false;
            obj.refreshBars();
            e.preventDefault();
            e.stopPropagation();
          });
        }
        if (disabled) {
          icon.style.filter = "grayscale(100%)";
          icon.style.opacity = "0.5";
          menuItemDiv.style.cursor = "not-allowed";
        } else {
          icon.style.filter = "";
          icon.style.opacity = "";
          menuItemDiv.style.cursor = "pointer";
        }
      }
    }
  }
  showBlocker(clickable) {
    this.blocker.style.display = "block";
    this.blocker.style.cursor = clickable ? "pointer" : "default";
  }
  hideBlocker() {
    this.blocker.style.display = "none";
  }
  async showSpaceshipDialog() {
    this.spaceshipPopup.style.display = "flex";
    await new Promise((resolve) => setTimeout(resolve, 100));
    return new Promise(async (resolve) => {
      this.spaceshipPopup.style.opacity = "1";
      this.showBlocker(true);
      const spaceshipText = this.spaceshipPopup.querySelector("#spaceshipText");
      spaceshipText.textContent = `Good news, great leader! We have built the spaceship!\nWe can now travel accross the galaxy,\nand leave those poor humans behind!\nTHE END`;
      const animalsSaved = [];
      await this.manager.iterateRevealedCells(async (cell) => {
        if (cell.elem?.owner === this.manager.getPlayer() && cell.elem?.type === "unit") {
          animalsSaved.push(cell.elem);
        }
      });
      const overlay = this.spaceshipPopup.appendChild(document.createElement("div"));
      overlay.style.position = "absolute";
      overlay.style.top = "50%";
      overlay.style.left = "50%";
      overlay.style.transform = `translate(-50%, -50%)`;
      overlay.style.width = "100%";
      overlay.style.height = "100%";
      overlay.style.pointerEvents = "none";
      overlay.style.display = "flex";
      overlay.style.flexDirection = "row";
      overlay.style.justifyContent = "center";
      overlay.style.alignItems = "center";
      overlay.style.gap = "10px";
      overlay.style.flexWrap = "wrap";
      overlay.style.overflow = "auto";
      overlay.style.maxHeight = "80%";
      for (const animal of animalsSaved) {
        const anim = animal.selected?.animation ?? animal.animation;
        if (!anim) {
          continue;
        }
        const animObj = this.manager.scene.animations.find((animObj2) => animObj2.name === anim);
        if (!animObj) {
          continue;
        }
        const { imageSource, spriteSize, frames, padding } = animObj;
        const icon = this.spaceshipPopup.appendChild(document.createElement("div"));
        icon.style.backgroundImage = `url(${imageSource})`;
        icon.style.width = `${spriteSize[0]}px`;
        icon.style.height = `${spriteSize[1]}px`;
        icon.style.position = "absolute";
        icon.style.top = "50%";
        icon.style.left = "50%";
        icon.style.transform = `translate(-50%, -50%)`;
        icon.style.pointerEvents = "none";
        const cols = 30;
        const spriteWidth = spriteSize[0] + (padding?.[0] ?? 2) * 2;
        const spriteHeight = spriteSize[1] + (padding?.[1] ?? 2) * 2;
        const x = 50 + (Math.random() - 0.5) * 50;
        const y = 50 + (Math.random() - 0.5) * 30;
        icon.style.left = `${x}%`;
        icon.style.top = `${y}%`;
        let animationFrame;
        const animateIcon = () => {
          animationFrame = requestAnimationFrame(animateIcon);
          const frame2 = frames[Math.floor(performance.now() / 100) % frames.length];
          icon.style.backgroundPosition = `${-spriteWidth * (frame2 % cols)}px ${-spriteHeight * Math.floor(frame2 / SPRITESHEET_COLS)}px`;
        };
        animateIcon();
        this.itemsToDestroy.add(() => cancelAnimationFrame(animationFrame));
      }
      this.playMusic();
      const utterance = new SpeechSynthesisUtterance(spaceshipText.textContent);
      const voices = speechSynthesis.getVoices();
      const voice = voices.find((voice2) => voice2.name.indexOf("Daniel") >= 0);
      if (voice) {
        utterance.voice = voice;
      }
      speechSynthesis.speak(utterance);
      setTimeout(() => {
        this.blocker.addEventListener("click", () => {
          overlay.parentNode?.removeChild(overlay);
          speechSynthesis.cancel();
          this.fadeMusicOut();
          this.clear();
          this.spaceshipPopup.style.opacity = "0";
          this.hideBlocker();
          resolve();
          setTimeout(() => {
            this.spaceshipPopup.style.display = "none";
          }, 300);
        }, { once: true });
      }, 1000);
    });
  }
  async showResearchDialog(research) {
    this.researchPopup.style.display = "flex";
    await new Promise((resolve) => setTimeout(resolve, 100));
    return new Promise((resolve) => {
      this.showBlocker(true);
      this.researchPopup.style.opacity = "1";
      const { imageSource, spriteSize, frames, padding } = research.waitIcon ?? research.icon;
      const researchImage = this.researchPopup.querySelector("#researchImage");
      researchImage.style.backgroundImage = `url(${imageSource})`;
      researchImage.style.width = `${spriteSize[0]}px`;
      researchImage.style.height = `${spriteSize[1]}px`;
      researchImage.style.opacity = "1";
      const cols = 30;
      const spriteWidth = spriteSize[0] + (padding?.[0] ?? 2) * 2;
      const spriteHeight = spriteSize[1] + (padding?.[1] ?? 2) * 2;
      let animationFrame;
      const animateIcon = () => {
        animationFrame = requestAnimationFrame(animateIcon);
        const frame2 = frames[Math.floor(performance.now() / 100) % frames.length];
        researchImage.style.backgroundPosition = `${-spriteWidth * (frame2 % cols)}px ${-spriteHeight * Math.floor(frame2 / SPRITESHEET_COLS)}px`;
      };
      animateIcon();
      this.itemsToDestroy.add(() => cancelAnimationFrame(animationFrame));
      const researchText = this.researchPopup.querySelector("#researchText");
      researchText.textContent = `Good news, great leader!\n\nWe have discovered ${research.name}!\n${research.description ?? ""}`;
      this.playMusic();
      const utterance = new SpeechSynthesisUtterance(researchText.textContent);
      const voices = speechSynthesis.getVoices();
      const voice = voices.find((voice2) => voice2.name.indexOf("Daniel") >= 0);
      if (voice) {
        utterance.voice = voice;
      }
      speechSynthesis.speak(utterance);
      setTimeout(() => {
        this.blocker.addEventListener("click", () => {
          speechSynthesis.cancel();
          this.fadeMusicOut();
          this.clear();
          this.researchPopup.style.opacity = "0";
          this.hideBlocker();
          resolve();
          researchImage.style.opacity = "0";
          setTimeout(() => {
            this.researchPopup.style.display = "none";
          }, 300);
        }, { once: true });
      }, 1000);
    });
  }
  musicFader = 0;
  fadeMusicOut() {
    let volume = this.music.volume;
    const fade = () => {
      volume -= 0.005;
      if (volume > 0) {
        this.music.volume = volume;
        this.musicFader = requestAnimationFrame(fade);
      } else {
        this.music.pause();
      }
    };
    fade();
  }
  playMusic() {
    cancelAnimationFrame(this.musicFader);
    this.music.play();
    this.music.volume = 1;
    this.music.currentTime = 0;
  }
  async showDialog(text, music = false, voiceName) {
    this.showBlocker(true);
    this.dialog.style.display = "flex";
    this.cat.style.display = "block";
    this.dialog.textContent = text;
    const utterance = new SpeechSynthesisUtterance(text);
    const voices = speechSynthesis.getVoices();
    const voice = voiceName ? voices.find((voice2) => voice2.name.indexOf(voiceName) >= 0) : undefined;
    if (voice) {
      utterance.voice = voice;
    }
    speechSynthesis.speak(utterance);
    if (music) {
      this.playMusic();
    }
    return new Promise((resolve) => {
      this.blocker.addEventListener("click", () => {
        speechSynthesis.cancel();
        if (!READY) {
          window.index = window.index ?? 0;
          const NOTREADYS = [
            "Not ready yet, please be patient",
            "I'm not ready yet, please wait",
            "I'm still working on it, please wait",
            "Can you wait a little longer? Jesus!",
            "Hold your horses, we're almost there!",
            "Patience is a virtue... that you clearly lack!",
            "Good things come to those who wait. Great things take a bit longer.",
            "Rome wasn't built in a day, and neither is this!",
            "Keep calm and wait a moment.",
            "Loading... just like your patience.",
            "If you keep clicking, it won't go any faster!",
            "Almost there... just kidding, still working on it!",
            "Why the rush? Enjoy the moment!",
            "Your impatience is noted. Still not ready.",
            "Take a deep breath, we're almost there.",
            "You can't rush perfection!",
            "Good things take time. Great things take even longer.",
            "Patience, young grasshopper.",
            "We're on it! Just a few more seconds.",
            "Loading... because magic takes time.",
            "Hang tight, we're almost there!",
            "If you wait a bit longer, you might get a cookie!",
            "Almost done... just kidding, still working on it!",
            "Your impatience is adorable. Still not ready.",
            "Hold on, we're making it awesome!",
            "Good things come to those who wait. Great things take a bit longer.",
            "Keep calm and wait a moment.",
            "Loading... just like your patience.",
            "If you keep clicking, it won't go any faster!",
            "Almost there... just kidding, still working on it!",
            "Why the rush? Enjoy the moment!",
            "Your impatience is noted. Still not ready.",
            "Take a deep breath, we're almost there.",
            "You can't rush perfection!",
            "Good things take time. Great things take even longer.",
            "Patience, young grasshopper.",
            "We're on it! Just a few more seconds.",
            "Loading... because magic takes time.",
            "Hang tight, we're almost there!",
            "If you wait a bit longer, you might get a cookie!",
            "Almost done... just kidding, still working on it!",
            "Your impatience is adorable. Still not ready.",
            "Hold on, we're making it awesome!"
          ];
          const msg = NOTREADYS[window.index];
          window.index = (window.index + 1) % NOTREADYS.length;
          this.clear();
          resolve();
          this.showDialog(msg);
          return;
        }
        if (music) {
          this.fadeMusicOut();
        }
        this.dialog.style.display = "none";
        this.cat.style.display = "none";
        this.hideBlocker();
        this.clear();
        setTimeout(() => {
          resolve();
        }, 10);
      }, { once: true });
    });
  }
  closeDialog() {
    this.dialog.style.display = "none";
    this.hideBlocker();
  }
  initializeErrorBanner() {
    window.addEventListener("error", (event) => {
      const errorDiv = document.body.appendChild(document.createElement("div"));
      errorDiv.style.position = "absolute";
      errorDiv.style.zIndex = "1000";
      errorDiv.style.top = "0";
      errorDiv.style.left = "0";
      errorDiv.style.width = "100%";
      errorDiv.style.height = "100px";
      errorDiv.style.backgroundColor = "rgba(255, 0, 0, 0.5)";
      errorDiv.style.color = "white";
      errorDiv.style.textAlign = "center";
      errorDiv.style.fontSize = "20pt";
      errorDiv.textContent = event.message;
      errorDiv.addEventListener("click", () => {
        errorDiv.remove();
      });
    }, { once: true });
  }
  async promptForResearch(inventions, brainsPerTurn, currentBrains) {
    if (!inventions.length) {
      return;
    }
    return new Promise((resolve) => {
      this.showBlocker();
      const inv = [...inventions];
      inv.sort((a, b) => {
        if (DEBUG) {
          if (a.forceInDebug !== b.forceInDebug) {
            return a.forceInDebug ? -1 : 1;
          }
        }
        if (a.cost !== b.cost) {
          return a.cost - b.cost;
        }
        return Math.random() - 0.5;
      });
      while (inv.length > 4) {
        inv.pop();
      }
      inv.sort((a, b) => {
        const recA = a.recommended ?? 1e4;
        const recB = b.recommended ?? 1e4;
        if (recA !== recB) {
          return recA - recB;
        }
        return Math.random() - 0.5;
      });
      this.researchList.style.display = "flex";
      this.researchList.style.height = `${inv.length * 100}px`;
      this.researchList.innerHTML = "";
      inv.forEach((invention, index) => {
        const researchDiv = this.researchList.appendChild(document.createElement("div"));
        researchDiv.style.display = "flex";
        researchDiv.style.flexDirection = "row";
        researchDiv.style.justifyContent = "flex-start";
        researchDiv.style.alignItems = "center";
        researchDiv.style.flexGrow = "1";
        researchDiv.style.margin = "0 10px";
        researchDiv.style.gap = "10px";
        const { imageSource, spriteSize, frames, padding } = invention.icon;
        const icon = researchDiv.appendChild(document.createElement("div"));
        icon.style.backgroundImage = `url(${imageSource})`;
        icon.style.width = `${spriteSize[0]}px`;
        icon.style.height = `${spriteSize[1]}px`;
        const cols = 30;
        const spriteWidth = spriteSize[0] + (padding?.[0] ?? 2) * 2;
        const spriteHeight = spriteSize[1] + (padding?.[1] ?? 2) * 2;
        let animationFrame;
        const animateIcon = () => {
          animationFrame = requestAnimationFrame(animateIcon);
          const frame2 = frames[Math.floor(performance.now() / 100) % frames.length];
          icon.style.backgroundPosition = `${-spriteWidth * (frame2 % cols)}px ${-spriteHeight * Math.floor(frame2 / SPRITESHEET_COLS)}px`;
        };
        animateIcon();
        this.itemsToDestroy.add(() => cancelAnimationFrame(animationFrame));
        const midGroup = researchDiv.appendChild(document.createElement("div"));
        midGroup.style.display = "flex";
        midGroup.style.flexDirection = "column";
        midGroup.style.justifyContent = "flex-start";
        midGroup.style.alignItems = "flex-start";
        midGroup.style.flexGrow = "1";
        midGroup.style.margin = "0 10px";
        midGroup.style.gap = "5px";
        const labelGroup = midGroup.appendChild(document.createElement("div"));
        labelGroup.style.display = "flex";
        labelGroup.style.flexDirection = "row";
        const label = labelGroup.appendChild(document.createElement("div"));
        label.innerText = invention.name;
        label.style.textAlign = "left";
        label.style.fontSize = "10pt";
        if (index === 0) {
          const rec = labelGroup.appendChild(document.createElement("div"));
          rec.innerText = "recommended";
          rec.style.textAlign = "left";
          rec.style.fontSize = "8pt";
          rec.style.color = "gold";
          rec.style.marginLeft = "10px";
          researchDiv.style.backgroundColor = "rgba(70, 60, 0, 1)";
        }
        const desc = midGroup.appendChild(document.createElement("div"));
        desc.innerText = invention.description ?? "";
        desc.style.textAlign = "left";
        desc.style.fontSize = "8pt";
        desc.style.color = "silver";
        const costDiv = researchDiv.appendChild(document.createElement("div"));
        costDiv.style.display = "flex";
        costDiv.style.flexDirection = "row";
        costDiv.style.alignItems = "flex-end";
        costDiv.style.justifyContent = "center";
        costDiv.style.position = "absolute";
        costDiv.style.right = "10px";
        costDiv.style.marginTop = "-40px";
        costDiv.style.color = "silver";
        const numTurns = Math.max(0, Math.ceil((invention.cost - currentBrains) / brainsPerTurn));
        costDiv.textContent = `${numTurns} turns`;
        researchDiv.style.cursor = "pointer";
        researchDiv.style.width = "100%";
        researchDiv.addEventListener("mouseover", () => {
          researchDiv.style.backgroundColor = index === 0 ? "rgba(120, 100, 0, 1)" : "rgba(100, 100, 100, 1)";
        });
        researchDiv.addEventListener("mouseout", () => {
          researchDiv.style.backgroundColor = index === 0 ? "rgba(70, 60, 0, 1)" : "";
        });
        researchDiv.addEventListener("click", () => {
          this.manager.research(invention.name, this.manager.getPlayer());
          this.researchList.style.display = "none";
          this.hideBlocker();
          this.updated = false;
          resolve();
        });
      });
    });
  }
  async refreshResearchInfo() {
    const player = this.manager.getPlayer();
    const research = this.manager.getResearchInfo(player);
    this.researchInfoDiv.innerHTML = "";
    if (!research) {
      this.researchInfoDiv.style.display = "none";
      return;
    }
    const researched = this.manager.isResearched(research.name, player);
    this.researchInfoDiv.style.display = "block";
    const { imageSource, spriteSize, frames, padding } = research.icon;
    const icon = this.researchInfoDiv.appendChild(document.createElement("div"));
    icon.style.backgroundImage = `url(${imageSource})`;
    icon.style.width = `${spriteSize[0]}px`;
    icon.style.height = `${spriteSize[1]}px`;
    const cols = 30;
    const spriteWidth = spriteSize[0] + (padding?.[0] ?? 2) * 2;
    const spriteHeight = spriteSize[1] + (padding?.[1] ?? 2) * 2;
    let animationFrame;
    const animateIcon = () => {
      animationFrame = requestAnimationFrame(animateIcon);
      const frame2 = frames[Math.floor(performance.now() / 100) % frames.length];
      icon.style.backgroundPosition = `${-spriteWidth * (frame2 % cols)}px ${-spriteHeight * Math.floor(frame2 / SPRITESHEET_COLS)}px`;
    };
    animateIcon();
    this.itemsToDestroy.add(() => cancelAnimationFrame(animationFrame));
    const label = this.researchInfoDiv.appendChild(document.createElement("div"));
    label.innerText = research.name;
    label.style.marginTop = "-30px";
    label.style.textAlign = "center";
    label.style.fontSize = "10pt";
    label.style.color = "white";
    const turnDiv = this.researchInfoDiv.appendChild(document.createElement("div"));
    const globalResources = await this.manager.calculateResourceRevenue(this.manager.getPlayer());
    const brainsPerTurn = globalResources.brain;
    turnDiv.style.position = "absolute";
    turnDiv.style.top = "10px";
    turnDiv.style.right = "10px";
    turnDiv.style.color = researched ? "#00ffff" : !brainsPerTurn ? "#ff0000" : "silver";
    turnDiv.style.fontSize = "8pt";
    const currentBrains = this.manager.getPlayerResource("brain", this.manager.getPlayer());
    const numTurns = Math.max(0, Math.ceil((research.cost - currentBrains) / brainsPerTurn));
    turnDiv.textContent = researched ? `researched` : !brainsPerTurn ? "research halted" : `${numTurns} turns`;
  }
}

// src/ai/thinker.ts
class Thinker {
  manager;
  constructor(manager) {
    this.manager = manager;
  }
  async think(gameObject) {
    const actions = await this.prepareScript(gameObject);
    await this.executeScript(gameObject, actions);
    gameObject.clearMoves();
    gameObject.doneMoving();
  }
  async prepareScript(gameObject) {
    const actions = [];
    const preys = await gameObject.findNearby((obj) => {
      if (obj.elem?.owner !== gameObject.elem?.owner) {
        return true;
      }
      return false;
    }, 2);
    const friends = await gameObject.findNearby((obj) => {
      if (obj !== gameObject && obj.elem?.type === "unit" && obj.elem?.owner === gameObject.elem?.owner) {
        return true;
      }
      return false;
    }, 3);
    console.log(preys, friends);
    const nextActionTime = preys.size || friends.size ? 0 : 1000;
    if (nextActionTime) {
      for (let i = 0;i < 4; i++) {
        actions.push({ time: nextActionTime / 4 * i, turnAround: true });
      }
    }
    let didMove = false;
    if (preys.size && (gameObject?.elem?.attack?.range ?? 1) === 2) {
      let target = { obj: undefined, distance: 0 };
      preys.forEach((obj) => {
        const dx = obj.px - gameObject.px;
        const dy = obj.py - gameObject.py;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (!target || distance > target.distance) {
          target = { obj, distance };
        }
      });
      const targetObj = target.obj;
      if (targetObj) {
        actions.push({
          time: nextActionTime,
          attack: [targetObj.px ?? 0, targetObj.py ?? 0]
        });
        didMove = true;
      }
    } else if (preys.size && (gameObject?.elem?.attack?.range ?? 1) < 2) {
      let target = { obj: undefined, distance: 0 };
      preys.forEach((obj) => {
        const dx = obj.px - gameObject.px;
        const dy = obj.py - gameObject.py;
        const distance = Math.max(Math.abs(dx), Math.abs(dy));
        if (!target || distance > target.distance) {
          target = { obj, distance };
        }
      });
      if (target.obj) {
        const dx = Math.sign(target.obj.px - gameObject.px) || Math.floor(Math.random() * 3) - 1;
        const dy = Math.sign(target.obj.py - gameObject.py) || Math.floor(Math.random() * 3) - 1;
        if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1 || this.manager.isEmptySpot(gameObject.px + dx, gameObject.py + dy)) {
          actions.push({
            time: nextActionTime,
            attack: [gameObject.px + dx, gameObject.py + dy]
          });
          didMove = true;
        }
      }
    } else if (friends.size) {
      let target = { obj: undefined, distance: 1 };
      friends.forEach((obj) => {
        if (obj === gameObject) {
          return;
        }
        const dx = obj.px - gameObject.px;
        const dy = obj.px - gameObject.py;
        const distance = Math.max(Math.abs(dx), Math.abs(dy));
        if (!target || distance > target.distance) {
          target = { obj, distance };
        }
      });
      if (target.obj) {
        const dx = Math.sign(target.obj.px - gameObject.py) || Math.floor(Math.random() * 3) - 1;
        const dy = Math.sign(target.obj.py - gameObject.py) || Math.floor(Math.random() * 3) - 1;
        if (this.manager.isEmptySpot(gameObject.px + dx, gameObject.py + dy)) {
          actions.push({
            time: nextActionTime,
            moveTo: [gameObject.px + dx, gameObject.py + dy]
          });
          didMove = true;
        }
      }
    }
    if (!didMove) {
      const spots = this.manager.findEmptySpotsAround(gameObject.px, gameObject.py);
      if (spots.length) {
        const spot = spots[Math.floor(Math.random() * spots.length)];
        actions.push({
          time: nextActionTime,
          moveTo: [spot.x, spot.y]
        });
      }
    }
    return actions;
  }
  async executeScript(gameObject, actions) {
    actions.sort((a, b) => b.time - a.time);
    return new Promise((resolve) => {
      const startTime = Date.now();
      const loop = () => {
        if (!actions.length) {
          if (!gameObject.moving) {
            resolve();
          }
          return;
        }
        const time2 = Date.now() - startTime;
        if (time2 < actions[actions.length - 1].time) {
          requestAnimationFrame(loop);
        } else if (actions.length) {
          const action = actions.pop();
          if (action?.turnAround) {
            gameObject.turnAround();
          } else if (action?.moveTo) {
            gameObject.simpleMoveTo(action.moveTo[0], action.moveTo[1]);
          } else if (action?.attack) {
            gameObject.attackTowards(action.attack[0], action.attack[1]);
          }
          requestAnimationFrame(loop);
        }
      };
      requestAnimationFrame(loop);
    });
  }
}

// src/core/manager.ts
class Manager {
  scene;
  entries = new Map;
  animation;
  grid = {};
  revealed = new Set;
  cursor;
  selected;
  hovered;
  onMoveOption = false;
  mousePosDown;
  camShift = vec2(0, 0);
  shifting = 0;
  doneShifting = 0;
  hud;
  worldChanged = true;
  inUI;
  resourceIcons = [];
  autoEndTurn = true;
  showLabels = true;
  thinker = new Thinker(this);
  lastUnit;
  lastHovered;
  advise = new Set;
  constructor(scene) {
    this.scene = scene;
    this.animation = new AnimationManager(scene.animations);
    this.hud = new Hud(this);
    if (scene.scale) {
      setCameraScale(scene.scale);
    }
    document.addEventListener("wheel", (e) => {
      this.camShift.x += e.deltaX / cameraScale;
      this.camShift.y -= e.deltaY / cameraScale;
      e.preventDefault();
    }, { passive: false });
    this.hud.initialize();
    window.addEventListener("blur", (e) => {
      this.hud.resourceOverlay.classList.add("hidden");
      this.hud.buttonsOverlay.classList.add("hidden");
      this.showLabels = false;
      this.cursor?.hide();
      this.updateLabels();
      exports_littlejs_esm_min.overlayCanvas.style.cursor = "default";
    });
    window.addEventListener("focus", (e) => {
      this.hud.resourceOverlay.classList.remove("hidden");
      this.hud.buttonsOverlay.classList.remove("hidden");
      this.showLabels = true;
      this.refreshCursor();
      this.updateLabels();
      exports_littlejs_esm_min.overlayCanvas.style.cursor = "";
    });
    if (!READY) {
      this.hud.showDialog("This game is almost ready!.");
    }
  }
  updateLabels() {
    this.getAllUnitsOrHouses().forEach((gameObject) => {
      gameObject.updateLabel(this.showLabels);
    });
  }
  refresh() {
    this.scene.elems.forEach((elem) => {
      if (elem.debug && !DEBUG) {
        return;
      }
      this.sanitizeElem(elem);
      this.refreshElem(elem);
    });
    this.shiftCamera();
    if (this.worldChanged) {
      this.fixWorld();
      this.worldChanged = false;
    }
    this.hud.refresh();
  }
  clearFogOfWar() {
    Object.keys(this.grid).forEach((tag) => {
      const gameObject = this.grid[tag];
      if (gameObject.elem?.type === "cloud") {
        this.clearCloud(gameObject.px, gameObject.py);
      }
    });
  }
  async iterateGridCell(x, y, callback) {
    const layers = Object.keys(this.scene.layers);
    for (const layer of layers) {
      const tag = `${layer}_${x}_${y}`;
      const gameObject = this.grid[tag];
      if (gameObject) {
        await callback(gameObject);
      }
    }
  }
  getRevealedCells() {
    const cells = [];
    this.revealed.forEach((tag) => {
      const [x, y] = tag.split("_").map(Number);
      cells.push(vec2(x, y));
    });
    return cells;
  }
  async iterateRevealedCells(callback) {
    const cells = this.getRevealedCells();
    for (const cell of cells) {
      for (const layer of Object.keys(this.scene.layers)) {
        const tag = `${layer}_${cell.x}_${cell.y}`;
        const gameObject = this.grid[tag];
        if (gameObject) {
          await callback(gameObject);
        }
      }
    }
  }
  async fixWorld() {
    if (this.scene.clearFogOfWar) {
      this.clearFogOfWar();
    }
    const entries = Object.entries(this.grid);
    for (const [tag, gameObject] of entries) {
      if (gameObject.elem?.condition) {
        let conditionMet = true;
        if (gameObject.elem.condition.tile) {
          conditionMet = false;
          const tiles = Array.isArray(gameObject.elem.condition.tile) ? gameObject.elem.condition.tile : [gameObject.elem.condition.tile];
          for (const tile2 of tiles) {
            await this.iterateGridCell(gameObject.px, gameObject.py, async (target) => {
              if (target?.elem?.name === tile2) {
                conditionMet = true;
              }
            });
          }
        }
        let violationMet = false;
        if (gameObject.elem.condition.noTile) {
          const tiles = Array.isArray(gameObject.elem.condition.noTile) ? gameObject.elem.condition.noTile : [gameObject.elem.condition.noTile];
          for (const tile2 of tiles) {
            for (const layer of Object.keys(this.scene.layers)) {
              const tag2 = `${layer}_${gameObject.px}_${gameObject.py}`;
              const target = this.grid[tag2];
              if (target?.elem?.name === tile2) {
                violationMet = true;
              }
            }
          }
        }
        if (gameObject.elem.condition.zeroUnit) {
          const tag2 = `unit_${gameObject.px}_${gameObject.py}`;
          const target = this.grid[tag2];
          if (target) {
            violationMet = true;
          }
        }
        if (!conditionMet || violationMet) {
          gameObject.doom(true);
          delete this.grid[tag];
        }
      }
    }
  }
  shiftCamera() {
    if (this.inUI) {
    }
    if (!this.hud.onKnob) {
      if (!this.mousePosDown && mouseWasPressed(0)) {
        this.mousePosDown = vec2(mousePos.x, mousePos.y);
      }
    }
    if (this.mousePosDown && mouseWasReleased(0)) {
      this.mousePosDown = undefined;
      if (!this.selected) {
        this.refreshCursor();
      }
      if (this.shifting) {
        this.shifting = 0;
        this.doneShifting = Date.now();
        this.refreshCursor();
      }
    }
    if (this.mousePosDown) {
      const dx2 = mousePos.x - this.mousePosDown.x;
      const dy2 = mousePos.y - this.mousePosDown.y;
      if (dx2 || dy2) {
        const mul2 = 10;
        this.camShift.set(this.camShift.x - dx2 * mul2, this.camShift.y - dy2 * mul2);
        this.mousePosDown.set(mousePos.x, mousePos.y);
        this.cursor?.hide();
        this.shifting = Date.now();
        this.doneShifting = 0;
      }
    }
    const dx = this.camShift.x - cameraPos.x;
    const dy = this.camShift.y - cameraPos.y;
    const mul = 0.1;
    setCameraPos(cameraPos.set(Math.round((cameraPos.x + dx * mul) * cameraScale) / cameraScale, Math.round((cameraPos.y + dy * mul) * cameraScale) / cameraScale));
  }
  defineElem(elem) {
    if (elem.definition) {
      const definition = this.scene.definitions.find((def) => def.name === elem.definition);
      if (definition) {
        Object.entries(definition).forEach(([key, value]) => {
          const e = elem;
          if (e[key] === undefined) {
            e[key] = JSON.parse(JSON.stringify(value));
          }
        });
        delete elem.definition;
      }
    }
    return elem;
  }
  refreshElem(elem) {
    this.defineElem(elem);
    if (elem.gameObject) {
      const entry = this.ensureElem(elem);
      if (entry.updateTime !== elem.lastUpdate) {
        entry.gameObject?.forEach((gameObject) => {
          gameObject.refresh(elem);
        });
        entry.updateTime = elem.lastUpdate;
      }
    } else {
      const entry = this.entries.get(elem);
      if (entry) {
        entry.gameObject?.forEach((gameObject) => gameObject.refresh(elem));
        entry.gameObject.clear();
        this.entries.delete(elem);
      }
    }
  }
  ensureElem(elem) {
    let entry = this.entries.get(elem);
    if (!entry) {
      entry = {
        gameObject: new Set
      };
      this.entries.set(elem, entry);
      if (elem.gameObject && !entry.gameObject.size) {
        const chance = elem.group?.chance ?? 1;
        const [col, row] = elem.group?.grid ?? [1, 1];
        const farFromCenter = elem.group?.farFromCenter ?? 0;
        for (let x = 0;x < col; x++) {
          for (let y = 0;y < row; y++) {
            if (farFromCenter) {
              const distance = Math.abs(x - Math.floor(col / 2)) + Math.abs(y - Math.floor(row / 2));
              if (distance < farFromCenter) {
                continue;
              }
            }
            if (Math.random() <= chance) {
              const xx = x - Math.floor(col / 2);
              const yy = y - Math.floor(row / 2);
              if ((elem.type === "decor" || elem.water) && Math.abs(xx) <= 1 && Math.abs(yy) <= 1) {
                continue;
              }
              if (elem.type === "cloud" && this.isRevealed(xx, yy)) {
                continue;
              }
              const gameObject = new GameObject(this, vec2(xx, yy));
              entry.gameObject.add(gameObject);
              gameObject.refresh(elem);
            }
          }
        }
      }
    }
    return entry;
  }
  sanitizeElem(elem) {
    if (!elem.lastUpdate) {
      elem.lastUpdate = Date.now();
    }
    if (elem.gameObject) {
      if (!elem.gameObject.pos) {
        elem.gameObject.pos = [0, 0];
      }
      if (!elem.gameObject.size) {
        elem.gameObject.size = [1, 1];
      }
    }
  }
  countRevealPotential(x, y) {
    let count = 0;
    for (let xx = -1;xx <= 1; xx++) {
      for (let yy = -1;yy <= 1; yy++) {
        if (this.grid[`tile_${x + xx}_${y + yy}`] && !this.isRevealed(x + xx, y + yy)) {
          count++;
        }
      }
    }
    return count;
  }
  getResources(x, y) {
    const resources = {};
    Object.keys(this.scene.layers).forEach((layer) => {
      const tag = `${layer}_${x}_${y}`;
      const gameObject = this.grid[tag];
      if (gameObject && !gameObject?.doomed) {
        resources.wheat = (resources.wheat ?? 0) + (gameObject.elem?.resourcesProduced?.wheat ?? 0);
        resources.wood = (resources.wood ?? 0) + (gameObject.elem?.resourcesProduced?.wood ?? 0);
        resources.brain = (resources.brain ?? 0) + (gameObject.elem?.resourcesProduced?.brain ?? 0);
        resources.gold = (resources.gold ?? 0) + (gameObject.elem?.resourcesProduced?.gold ?? 0);
        resources.trade = (resources.trade ?? 0) + (gameObject.elem?.resourcesProduced?.trade ?? 0);
        if (gameObject.elem?.type === "house" && this.isResearched("productivity", this.getPlayer())) {
          resources.wood = (resources.wood ?? 0) + 1;
        }
      }
    });
    return Math.max(resources.wheat ?? 0, 0) + Math.max(resources.wood ?? 0, 0) + Math.max(resources.brain ?? 0, 0) + Math.max(resources.gold ?? 0, 0) + Math.max(resources.trade ?? 0, 0) ? resources : undefined;
  }
  isRevealed(x, y) {
    return this.revealed.has(`${x}_${y}`);
  }
  clearCloud(x, y) {
    if (this.isRevealed(x, y)) {
      return;
    }
    const tag = `${x}_${y}`;
    this.revealed.add(tag);
    const gameObject = this.grid[`cloud_${x}_${y}`];
    if (gameObject) {
      gameObject.doom();
      const elem = gameObject.elem;
      if (elem) {
        const entry = this.entries.get(elem);
        if (entry) {
          entry.gameObject.delete(gameObject);
        }
      }
      delete this.grid[tag];
    }
  }
  checkOnMoveOptions(x, y) {
    this.onMoveOption = false;
    if (!this.selected?.moveOptions) {
      return;
    }
    const selectedAnimation = this.selected.elem?.selected?.moveIndic?.selectedAnimation;
    const moveOptionAnimation = this.selected.elem?.selected?.moveIndic?.animation;
    if (!selectedAnimation || !moveOptionAnimation) {
      return;
    }
    const moveOptions = Object.values(this.selected.moveOptions);
    if (moveOptions.length) {
      let hoveringMoveOption = false;
      moveOptions.forEach((option) => {
        if (option.px === x && option.py === y) {
          hoveringMoveOption = true;
        }
        option.animation = this.animation.getInfo(option.px === x && option.py === y ? selectedAnimation : moveOptionAnimation);
      });
      if (hoveringMoveOption) {
        this.onMoveOption = true;
      }
    }
  }
  checkOnAttackOptions(x, y) {
    this.onMoveOption = false;
    if (!this.selected?.attackOptions) {
      return;
    }
    const selectedAnimation = this.selected.elem?.selected?.moveIndic?.selectedAnimation;
    const moveOptionAnimation = this.selected.elem?.selected?.moveIndic?.animation;
    if (!selectedAnimation || !moveOptionAnimation) {
      return;
    }
    const attackOptions = Object.values(this.selected.attackOptions);
    if (attackOptions.length) {
      let hoveringAttackOption = false;
      attackOptions.forEach((option) => {
        if (option.px === x && option.py === y) {
          hoveringAttackOption = true;
        }
        option.animation = this.animation.getInfo(option.px === x && option.py === y ? selectedAnimation : moveOptionAnimation);
      });
      if (hoveringAttackOption) {
        this.onMoveOption = true;
      }
    }
  }
  onCursorMove(x, y) {
    this.checkOnMoveOptions(x, y);
    this.checkOnAttackOptions(x, y);
    this.refreshCursor();
  }
  async onTap(x, y, mouseX, mouseY) {
    this.onMoveOption = false;
    this.refreshCursor();
    if (Date.now() - this.doneShifting < 100) {
      return;
    }
    if (this.inUI) {
      return;
    }
    if (this.getPlayer() === 0) {
      return;
    }
    if (this.selected?.canMoveTo(x, y) && this.selected.hasMoveOptionToLandOn(x, y)) {
      this.selected.moveTo(x, y);
      return;
    }
    if (this.selected?.canAttackAt(x, y) && this.selected.hasAttackOptionOn(x, y)) {
      this.selected.attackAt(x, y);
      return;
    }
    let unit = this.grid[`unit_${x}_${y}`];
    if (!await unit?.canAct()) {
      unit = undefined;
    }
    const house = this.grid[`house_${x}_${y}`];
    const nextSelection = unit === this.selected ? house : unit;
    this.setSelection(this.selected === nextSelection ? undefined : nextSelection);
  }
  async setSelection(gameObject) {
    if (this.selected === gameObject) {
      return;
    }
    if (gameObject?.elem?.waiting) {
      gameObject.elem.waiting = false;
      gameObject.refreshAlpha();
    }
    const previousSelected = this.selected;
    this.selected = undefined;
    await previousSelected?.onSelectChange();
    await this.hud.showSelected(undefined);
    if (previousSelected?.elem?.adviseOnDeselect && !this.advise.has(previousSelected.elem.adviseOnDeselect.name)) {
      this.advise.add(previousSelected.elem.adviseOnDeselect.name);
      await this.hud.showDialog(previousSelected.elem.adviseOnDeselect.message, previousSelected.elem.adviseOnDeselect.music, previousSelected.elem.adviseOnDeselect.voice);
    }
    if (gameObject?.elem?.advise && !this.advise.has(gameObject.elem.advise.name)) {
      this.advise.add(gameObject.elem.advise.name);
      await this.hud.showDialog(gameObject.elem.advise.message, gameObject.elem.advise.music, gameObject.elem.advise.voice);
    }
    this.selected = gameObject;
    await this.selected?.onSelectChange();
    await this.hud.showSelected(this.selected);
    if (!this.shifting && this.selected) {
      this.makeWithinView(this.selected);
    }
    if (this.selected) {
      this.lastUnit = this.selected;
    } else {
      this.checkForAnyMove(true);
    }
  }
  makeWithinView(gameObject) {
    const finalDestination = gameObject.finalDestination();
    const dx = finalDestination.x - this.camShift.x;
    const dy = finalDestination.y - this.camShift.y;
    const diffX = 4, diffY = 2;
    if (Math.abs(dx) > diffX) {
      this.camShift.set(finalDestination.x, this.camShift.y);
    }
    if (Math.abs(dy) > diffY) {
      this.camShift.set(this.camShift.x, finalDestination.y);
    }
  }
  hovering(gameObject) {
    if (this.inUI) {
      return false;
    }
    return gameObject.px === this.cursor?.px && gameObject.py === this.cursor?.py;
  }
  refreshCursor() {
    if (this.hovered || this.inUI || this.onMoveOption) {
      this.cursor?.hide();
    } else {
      this.cursor?.show();
    }
  }
  setHovered(gameObject) {
    if (this.hovered === gameObject) {
      return;
    }
    this.hovered = gameObject;
    if (this.hovered) {
      this.lastHovered = gameObject;
    }
    this.refreshCursor();
  }
  async checkCondition(condition, obj) {
    if (!condition) {
      return null;
    }
    if (condition.levelBelowEqual && (obj?.elem?.level ?? 0) <= condition.levelBelowEqual[0]) {
      return condition.levelBelowEqual[1] ?? "true";
    }
    if (condition.occupied && obj) {
      const tag = GameObject.getTag(condition.occupied[0], obj?.px, obj?.py);
      if (this.grid[tag]) {
        return condition.occupied[1] ?? "true";
      }
    }
    if (condition.harvesting && obj && obj.elem?.harvesting) {
      return "true";
    }
    if (condition.notHarvesting && obj && !obj.elem?.harvesting) {
      return "true";
    }
    if (obj) {
      let proxyCheck = null;
      const PROXY_CHECK = [condition.proximity, condition.nonProximity];
      for (const check of PROXY_CHECK) {
        if (check && !proxyCheck) {
          const [item, message] = check;
          if (item) {
            const nearby = await obj.findNearby((obj2) => {
              if (obj2.elem?.name === item) {
                return true;
              }
              if (item === "foe" && obj2.elem?.type === "unit" && obj2.elem?.owner !== obj2.elem?.owner) {
                return true;
              }
              return false;
            });
            console.log(item, nearby);
            if (condition.proximity === check && nearby.size) {
              proxyCheck = message ?? "true";
            }
            if (condition.nonProximity === check && !nearby.size) {
              proxyCheck = message ?? "true";
            }
          }
        }
      }
      if (proxyCheck) {
        return proxyCheck;
      }
    }
    if (condition.cannotAct) {
      return !obj?.canAct() ? condition.cannotAct[1] : null;
    }
    if (condition.unitLimit) {
      const level = obj?.elem?.level ?? 0;
      const [unit, message] = condition.unitLimit;
      const support = await obj?.countUnitSupport(unit);
      if (support && support >= level) {
        return message ?? "true";
      }
    }
    return null;
  }
  async gotoNextTurn() {
    if (this.scene.turn) {
      this.setSelection(undefined);
      if (this.scene.turn.player < this.scene.players.length) {
        this.scene.turn.player++;
      } else {
        this.scene.turn.player = 0;
        this.scene.turn.turn++;
      }
      const player = this.getPlayer();
      if (this.scene.turn && player) {
        await this.collectResources(player);
      }
      this.refreshUnitsLabels();
      if (this.getUnits(player).size) {
        await this.giveUnitsTurns(player);
        await this.selectNext();
      } else if (this.isAiPlayer(player)) {
        await this.gotoNextTurn();
      }
      await this.checkForAnyMove(true);
    }
    this.hud.updated = false;
  }
  refreshUnitsLabels() {
    Object.entries(this.grid).forEach(([tag, gameObject]) => {
      if (gameObject.elem?.type === "unit") {
        gameObject.refreshLabel();
      }
    });
  }
  async giveUnitsTurns(player) {
    const units = this.getUnits(player);
    for (const gameObject of units) {
      await gameObject.giveTurn();
    }
  }
  async calculateRevenue(player) {
    const playerResources = this.scene.players[player - 1]?.resources;
    if (!playerResources) {
      return 0;
    }
    let trade = 0;
    const visited = new Set;
    await this.iterateRevealedCells(async (gameObject) => {
      const elem = gameObject.elem;
      if (elem?.owner === player && elem.harvesting) {
        if (!visited.has(`${gameObject.px}_${gameObject.py}`)) {
          visited.add(`${gameObject.px}_${gameObject.py}`);
          const resources = this.getResources(gameObject.px, gameObject.py);
          if (resources) {
            trade += resources.trade ?? 0;
          }
        }
      }
    });
    return trade;
  }
  async collectResources(player) {
    await this.ensureResearch(player);
    const playerResources = this.scene.players[player - 1]?.resources;
    if (!playerResources) {
      return;
    }
    await this.iterateRevealedCells(async (gameObject) => {
      const elem = gameObject.elem;
      if (elem?.owner === player && elem.harvesting) {
        const resources = this.getResources(gameObject.px, gameObject.py);
        if (resources) {
          gameObject.showResources(gameObject.px, gameObject.py, player, true);
          gameObject.accumulateResources(resources);
          delete elem.lastUpdate;
        }
      }
    });
    await this.iterateRevealedCells(async (gameObject) => {
      const elem = gameObject.elem;
      if (elem?.owner === player && elem.harvesting) {
        gameObject.checkResourceCaps();
      }
    });
    const globalResources = await this.calculateResourceRevenue(player);
    Object.entries(globalResources).forEach(([resource, value]) => {
      const r = resource;
      playerResources[r] = (playerResources[r] ?? 0) + value;
    });
    await this.checkResearch(this.getPlayer());
  }
  availableInventionsToDiscover(player) {
    const allInventions = this.scene.research;
    const playerResearch = this.scene.players[player - 1]?.research;
    return allInventions.filter((invention) => {
      if (playerResearch?.[invention.name]) {
        return false;
      }
      if (!invention.forceInDebug && !DEBUG) {
        const dependency = invention.dependency;
        if (dependency && dependency.some((dep) => !playerResearch?.[dep])) {
          return false;
        }
      }
      return true;
    });
  }
  async ensureResearch(player) {
    const globalResources = await this.calculateResourceRevenue(player);
    const brainsPerTurn = globalResources.brain;
    if (brainsPerTurn) {
      const currentResearch = this.getResearchInfo(player);
      if (!currentResearch) {
        await this.hud.showDialog("Use your research points to unlock new inventions.\nThis will help you evolve your animals and buildings.");
        await this.findNextResearch(player);
      }
    }
  }
  async checkResearch(player) {
    const researchPoints = this.scene.players[player - 1]?.resources.brain ?? 0;
    const currentResearchName = this.scene.players[player - 1]?.currentResearch;
    const currentResearch = this.scene.research.find((research) => research.name === currentResearchName);
    if (researchPoints) {
      if (currentResearch) {
        if (researchPoints >= currentResearch.cost) {
          if (researchPoints >= currentResearch.cost) {
            await this.discover(player, currentResearch);
          }
        }
      } else {
        await this.findNextResearch(player);
      }
    }
  }
  async findNextResearch(player) {
    const globalResources = await this.calculateResourceRevenue(player);
    const brainsPerTurn = globalResources.brain;
    const currentBrains = this.getPlayerResource("brain", player);
    await this.hud.promptForResearch(this.availableInventionsToDiscover(player), brainsPerTurn, currentBrains);
  }
  async discover(player, invention) {
    const playerInfo = this.scene.players[player - 1];
    if (!playerInfo.research) {
      playerInfo.research = {};
    }
    playerInfo.research[invention.name] = Date.now();
    this.updateResource("brain", (brains) => Math.max(0, brains - invention.cost), this.getPlayer());
    await this.hud.showResearchDialog(invention);
    if (invention.action) {
      console.log(player, invention.name, playerInfo.research, playerInfo.research[invention.name]);
      await this.performAction(invention.action);
    }
    await this.findNextResearch(player);
  }
  async checkForAnyBuilding() {
    let anyBuilding = undefined;
    await this.iterateRevealedCells(async (gameObject) => {
      if (gameObject.elem?.type === "house" && await gameObject.canAffordMoreHarvester()) {
        anyBuilding = gameObject;
      }
    });
    return anyBuilding;
  }
  async checkForAnyMove(forFlashingOnly) {
    let anyMove = undefined;
    await this.iterateRevealedCells(async (gameObject) => {
      if (gameObject.elem?.owner === this.scene.turn?.player && await gameObject.canAct()) {
        if (gameObject.elem?.type === "unit" && !gameObject.elem?.harvesting) {
          anyMove = gameObject;
        }
      }
    });
    if (!anyMove) {
      if (this.autoEndTurn && !forFlashingOnly) {
        this.hud.flashEndTurn(true);
        setTimeout(() => {
          this.gotoNextTurn();
        }, 500);
      } else {
        this.hud.flashEndTurn();
      }
    }
    this.hud.updated = false;
  }
  getAllGlobalResources() {
    return this.getAllResources().filter((resource) => !this.getResourceType(resource)?.hidden && this.getResourceType(resource)?.global).sort((a, b) => b.localeCompare(a));
  }
  async calculateResourceRevenue(player) {
    const revenue = await this.calculateRevenue(player);
    const RESOURCES = this.getAllGlobalResources();
    const resources = {
      wheat: 0,
      wood: 0,
      gold: 0,
      brain: 0,
      trade: 0
    };
    RESOURCES.forEach((resource, index) => {
      let taxValue = this.getTaxValue(player);
      let revenueValue = Math.round(revenue * taxValue / 100);
      if (index === 0) {
        taxValue = 100 - taxValue;
        revenueValue = revenue - revenueValue;
      }
      resources[resource] = revenueValue;
    });
    return resources;
  }
  getUnits(player) {
    const units = new Set;
    Object.entries(this.grid).forEach(([tag, gameObject]) => {
      if (gameObject.elem?.type === "unit" && (player === undefined || gameObject.elem?.owner === player)) {
        units.add(gameObject);
      }
    });
    return units;
  }
  getAllUnitsOrHouses() {
    const units = new Set;
    Object.entries(this.grid).forEach(([tag, gameObject]) => {
      if (gameObject.elem?.type === "unit" || gameObject.elem?.type === "house") {
        units.add(gameObject);
      }
    });
    return units;
  }
  getAllResources() {
    return Object.keys(this.scene.resources);
  }
  getTaxValue(player) {
    return this.scene.players[(player ?? 0) - 1]?.tax ?? 0;
  }
  updateTaxValue(player, value) {
    if (this.scene.players[player - 1]) {
      this.scene.players[player - 1].tax = value;
    }
  }
  getPlayerResource(resource, player) {
    return this.scene.players[player - 1]?.resources[resource] ?? 0;
  }
  getPlayer() {
    return this.scene.turn?.player ?? 0;
  }
  getTurn() {
    return this.scene.turn?.turn ?? 0;
  }
  getResourceType(resource) {
    return this.scene.resources[resource];
  }
  async getUnitRotation(player) {
    const cellsRotation = [];
    const playerUnits = this.getUnits(player);
    for (const gameObject of playerUnits) {
      let include = false;
      if (this.selected === gameObject) {
        include = true;
      } else if (await gameObject.canAct()) {
        if (gameObject.elem?.type === "unit" && !gameObject.elem?.harvesting && !gameObject.elem?.waiting) {
          include = true;
        }
      }
      if (include) {
        cellsRotation.push(gameObject);
      }
    }
    if (player === 0) {
      cellsRotation.sort((a, b) => this.compareAI(a, b));
    }
    return cellsRotation;
  }
  compareAI(a, b) {
    const px = cameraPos.x, py = cameraPos.y;
    const distA = Math.abs(a.px - px) + Math.abs(a.py - py);
    const distB = Math.abs(b.px - px) + Math.abs(b.py - py);
    return distA - distB;
  }
  async selectNext() {
    const cellsRotation = await this.getUnitRotation(this.getPlayer());
    const currentIndex = this.selected ? cellsRotation.indexOf(this.selected) : -1;
    if (!cellsRotation.length) {
      this.hud.flashEndTurn();
    } else {
      let nextIndex = (currentIndex + 1) % cellsRotation.length;
      this.setSelection(cellsRotation[nextIndex]);
    }
  }
  unitAt(x, y) {
    return this.grid[`unit_${x}_${y}`];
  }
  houseAt(x, y) {
    return this.grid[`house_${x}_${y}`];
  }
  updateResource(resource, value, player) {
    const val = typeof value === "function" ? value(this.scene.players[player - 1].resources[resource] ?? 0) : value;
    this.scene.players[player - 1].resources[resource] = val;
    this.hud.updated = false;
  }
  isEmptySpot(x, y) {
    const unitTag = GameObject.getTag("unit", x, y);
    const houseTag = GameObject.getTag("house", x, y);
    const tileOverlayTag = GameObject.getTag("tile_overlay", x, y);
    if (!this.grid[unitTag] && !this.grid[houseTag] && this.grid[tileOverlayTag]?.elem?.name !== "lake") {
      return true;
    }
    return false;
  }
  findEmptySpotsAround(x, y) {
    const emptySpots = [];
    for (let xx = -1;xx <= 1; xx++) {
      for (let yy = -1;yy <= 1; yy++) {
        if (xx || yy) {
          if (this.isEmptySpot(x + xx, y + yy)) {
            emptySpots.push(vec2(x + xx, y + yy));
          }
        }
      }
    }
    return emptySpots;
  }
  async unlockRewards(obj) {
    await this.iterateGridCell(obj.px, obj.py, async (gameObject) => {
      const rewards = gameObject.elem?.rewards;
      if (rewards) {
        const reward = rewards[Math.floor(Math.random() * rewards.length)];
        if (!reward) {
          return;
        }
        if (reward.gold) {
          const [min2, max2] = reward.gold;
          const gold = Math.floor(Math.random() * (max2 - min2 + 1) + min2);
          obj.updateResource("gold", (g) => g + gold);
          obj.showResources(obj.px, obj.py, obj.elem?.owner, true, {
            gold
          });
          this.hud.updated = false;
          await this.hud.showDialog(`You found ${gold} gold!`);
        }
        if (reward.invention) {
          if (!this.scene.players[this.getPlayer() - 1].research) {
            await this.findNextResearch(this.getPlayer());
          }
          const currentResearch = this.getResearchInfo(this.getPlayer());
          if (currentResearch) {
            await this.discover(this.getPlayer(), currentResearch);
          }
        }
        if (reward.spawnFoes) {
          const emptySpots = this.findEmptySpotsAround(obj.px, obj.py);
          const { count, element } = reward.spawnFoes;
          const actualCount = Math.min(emptySpots.length, Math.floor(Math.random() * (count[1] - count[0] + 1) + count[0]));
          emptySpots.sort(() => Math.random() - 0.5);
          for (let i = 0;i < actualCount; i++) {
            const spot = emptySpots[i];
            const newElem = this.addSceneElemAt(element, spot.x, spot.y, {
              savage: true
            });
            newElem.gameObject.lastDx = Math.sign(obj.px - spot.x) || 1;
          }
          await this.hud.showDialog(`You have been ambushed by ${actualCount} savages!`);
        }
        if (reward.unit) {
          const emptySpots = this.findEmptySpotsAround(obj.px, obj.py);
          if (emptySpots.length) {
            const spot = emptySpots[Math.floor(Math.random() * emptySpots.length)];
            const newElem = this.addSceneElemAt(reward.unit, spot.x, spot.y, {
              owner: obj?.elem?.owner
            });
            newElem.gameObject.lastDx = Math.sign(obj.px - spot.x) || 1;
            await this.hud.showDialog(`A ${reward.unit.name ?? reward.unit.definition} has joined your flock!`);
          }
        }
        gameObject.doom(true);
      }
    });
  }
  addSceneElemAt(elem, x, y, config = {}) {
    const tag = GameObject.getTag(elem.type, x, y);
    if (this.grid[tag]) {
      return;
    }
    const newElem = JSON.parse(JSON.stringify(elem));
    this.defineElem(newElem);
    newElem.gameObject = newElem.gameObject ?? {};
    newElem.gameObject.pos = [x, y];
    Object.assign(newElem, config);
    this.ensureElem(newElem);
    this.scene.elems.push(newElem);
    return newElem;
  }
  getMenu(name) {
    return this.scene.menu?.find((m) => m.name === name);
  }
  isAiPlayer(player) {
    return !player || this.scene.players[player - 1]?.ai;
  }
  isResearched(research, player) {
    return this.scene.players[player - 1]?.research?.[research];
  }
  research(research, player) {
    this.scene.players[player - 1].currentResearch = research;
  }
  getResearchInfo(player) {
    const current = this.scene.players[player - 1]?.currentResearch;
    return this.scene.research.find((research) => research.name === current);
  }
  quickActions() {
    return this.scene.quickActions ?? [];
  }
  async performQuickAction(action) {
    if (!this.selected?.elem) {
      return;
    }
    switch (action.name) {
      case "wait":
        this.selected.elem.waiting = true;
        this.selected.refreshAlpha();
        this.selected.updated = false;
        this.setSelection(undefined);
        await this.selectNext();
        this.hud.updated = false;
        break;
      case "abandon":
        this.selected.doom(true);
        await this.selectNext();
        this.hud.updated = false;
        break;
    }
  }
  async performAction(action, obj) {
    if (action.selfDestroy) {
      obj?.doom(true);
    }
    if (action.destroy && obj) {
      await this.iterateGridCell(obj.px, obj.py, async (cell) => {
        if (cell.elem?.name === action.destroy) {
          cell.doom();
        }
      });
    }
    if (action.create && obj) {
      const elem = JSON.parse(JSON.stringify(action.create));
      this.addSceneElemAt(elem, obj.px, obj.py, {
        owner: obj?.elem?.owner,
        home: [obj.px, obj.py]
      });
    }
    if (action.deselect) {
      this.setSelection(undefined);
    }
    if (action.level && obj?.elem) {
      obj.updateLevel((obj.elem.level ?? 0) + action.level);
      obj.refreshLabel();
    }
    if (action.harvest && obj?.elem) {
      obj.setHarvesting(true);
    }
    if (action.stopHarvest && obj?.elem) {
      obj.setHarvesting(false);
    }
    if (action.clearFogOfWar) {
      this.scene.clearFogOfWar = true;
      this.worldChanged = true;
    }
    if (action.updateHouseCloud) {
      await this.iterateRevealedCells(async (gameObject) => {
        if (gameObject.elem?.type === "house" && gameObject.elem?.owner === this.getPlayer()) {
          gameObject.clearedCloud = false;
          gameObject.updated = false;
        }
      });
    }
    if (action.spaceship) {
      await this.hud.showSpaceshipDialog();
    }
  }
}

// src/content/definitions/cabana.ts
var CABANA_DEFINITION = {
  name: "cabana",
  type: "house",
  gameObject: {
    offset: [0, 0.2],
    size: [2, 2]
  },
  animation: {
    name: "cabana"
  },
  condition: {
    tile: "plain",
    noTile: ["lake", "mountain", "tree"],
    zeroUnit: true
  },
  rewards: [
    { gold: [20, 40] },
    {
      spawnFoes: {
        count: [1, 2],
        element: {
          definition: "hobo"
        }
      }
    },
    {
      unit: {
        definition: "dog",
        turn: {
          moves: 0,
          attacks: 0
        }
      }
    }
  ]
};

// src/content/definitions/cow.ts
var COW_DEFINITION = {
  name: "cow",
  type: "unit",
  hitpoints: 15,
  maxHitPoints: 15,
  gameObject: {
    size: [1.8, 1.8],
    speed: 0.06
  },
  animation: {
    name: "cow"
  },
  onHover: {
    hideCursor: true,
    indic: {
      animation: "hover"
    }
  },
  selected: {
    animation: "cow_wait",
    indic: {
      animation: "indic"
    },
    moveIndic: {
      animation: "blue",
      selectedAnimation: "blue_selected"
    }
  },
  clearCloud: true,
  move: {
    animation: "cow_jump",
    distance: 2,
    disabled: {
      harvesting: true
    }
  },
  harvest: {
    animation: "cow_sleep"
  },
  shadow: {
    animation: "shadow"
  },
  worker: true,
  turn: {
    moves: 1,
    attacks: 0,
    actions: 1
  },
  closeToHome: true,
  endlessMove: true,
  attack: {
    damage: 2,
    defense: 1,
    disabled: true
  },
  advise: {
    name: "cow",
    message: "Your cow must remain close to home.\nUse it to harvest nearby resources.\nYou can also find some buttons on the bottom left for additional actions.\nHover over them to see what they do."
  }
};

// src/content/definitions/dog.ts
var DOG_DEFINITION = {
  name: "dog",
  type: "unit",
  hitpoints: 10,
  maxHitPoints: 10,
  gameObject: {
    size: [1.8, 1.8],
    speed: 0.08
  },
  animation: {
    name: "dog"
  },
  onHover: {
    hideCursor: true,
    indic: {
      animation: "hover"
    }
  },
  selected: {
    animation: "dog_wait",
    indic: {
      animation: "indic"
    },
    moveIndic: {
      animation: "blue",
      selectedAnimation: "blue_selected"
    }
  },
  move: {
    animation: "dog_jump",
    distance: 2
  },
  shadow: {
    animation: "shadow"
  },
  clearCloud: true,
  dynamic: true,
  turn: {
    moves: 1,
    attacks: 1
  },
  attack: {
    damage: 2,
    defense: 1,
    moveAfterAttack: true,
    attackAfterMove: true
  },
  advise: {
    name: "dog",
    message: "Dogs move 2 tiles each turn, and they can move after attacks.\nUse them to explore the world.\nYou can also find some buttons on the bottom left for additional actions.\nHover over them to see what they do."
  }
};

// src/content/definitions/house.ts
var HOUSE_DEFINITION = {
  name: "house",
  type: "house",
  level: 1,
  gameObject: {
    offset: [0, 0.7],
    size: [2, 2]
  },
  animation: {
    name: "house"
  },
  onHover: {
    hideCursor: true,
    indic: {
      animation: "hover"
    }
  },
  selected: {
    animation: "house",
    indic: {
      animation: "indic"
    }
  },
  dynamic: true,
  settler: true,
  harvesting: true,
  building: true,
  turn: {
    moves: 0,
    attacks: 0,
    actions: 1
  },
  resourcesProduced: {
    trade: 1
  },
  rewards: [],
  advise: {
    name: "house",
    message: "Nice house! In this house, you collect resources.\nYou can also spawn new animals once they are researched."
  },
  adviseOnDeselect: {
    name: "house-deselect",
    message: "You can move on to the next turn and collect resources."
  },
  clearCloud: true,
  maxLevel: 6
};

// src/content/definitions/river.ts
var RIVER_DEFINITION = {
  name: "river",
  type: "road",
  resourcesProduced: {
    wheat: 1,
    trade: 1
  },
  gameObject: {
    size: [2, 2]
  },
  animation: {
    name: "river"
  }
};

// src/content/definitions/sheep.ts
var SHEEP_DEFINITION = {
  name: "sheep",
  type: "unit",
  hitpoints: 10,
  maxHitPoints: 10,
  gameObject: {
    size: [1.8, 1.8],
    speed: 0.08
  },
  animation: {
    name: "sheep"
  },
  onHover: {
    hideCursor: true,
    indic: {
      animation: "hover"
    }
  },
  selected: {
    animation: "sheep_wait",
    indic: {
      animation: "indic"
    },
    moveIndic: {
      animation: "blue",
      selectedAnimation: "blue_selected"
    }
  },
  move: {
    animation: "sheep_jump"
  },
  shadow: {
    animation: "shadow"
  },
  clearCloud: true,
  dynamic: true,
  settler: true,
  turn: {
    moves: 1,
    attacks: 1
  },
  attack: {
    damage: 2,
    defense: 1
  },
  advise: {
    name: "sheep",
    message: "Your sheep is the foundation of your animal kingdom.\nUse it to build settlements.\nFind a good spot with plenty of resources.",
    music: true
  }
};

// src/content/animations/bull.ts
var BULL_ANIMATION = {
  name: "bull",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    112
  ]
};
var BULL_WAIT_ANIMATION = {
  name: "bull_wait",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 20,
  frames: [
    112,
    113
  ]
};
var BULL_JUMP_ANIMATION = {
  name: "bull_jump",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 2,
  frames: [
    112,
    113
  ]
};

// src/content/animations/cow.ts
var COW_ANIMATION = {
  name: "cow",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    51
  ]
};
var COW_WAIT_ANIMATION = {
  name: "cow_wait",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 20,
  frames: [
    51,
    52,
    51
  ]
};
var COW_JUMP_ANIMATION = {
  name: "cow_jump",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 5,
  frames: [
    51,
    53,
    54
  ],
  airFrames: [54]
};
var COW_SLEEP_ANIMATION = {
  name: "cow_sleep",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 10,
  frames: [
    55
  ]
};

// src/content/menu/cow-menu.ts
var COW_MENU = {
  name: "cow",
  description: "Cows are your workers.\nUse them to harvest resources.",
  icon: {
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    padding: [2, 2],
    frames: [51]
  },
  items: [
    {
      name: "harvest",
      ...COW_SLEEP_ANIMATION,
      label: "harvest",
      hidden: {
        occupied: ["house", "No harvest on house"],
        harvesting: true
      },
      disabled: {
        proximity: ["foe", "Nearby foes,\ntoo dangerous."]
      },
      actions: [
        {
          deselect: true
        },
        {
          harvest: true
        },
        {
          clearMoves: true
        }
      ]
    },
    {
      name: "stopHarvest",
      ...COW_ANIMATION,
      label: "stop harvest",
      hidden: {
        notHarvesting: true
      },
      actions: [
        {
          deselect: true
        },
        {
          stopHarvest: true
        }
      ]
    },
    {
      name: "bull",
      ...BULL_ANIMATION,
      label: "evolve into\nbull",
      researchNeeded: ["taurology"],
      resourceCost: {
        gold: 30
      },
      actions: [
        {
          deselect: true,
          create: {
            definition: "bull",
            selfSelect: true
          }
        },
        {
          selfDestroy: true
        }
      ]
    }
  ]
};

// src/content/animations/dog.ts
var DOG_ANIMATION = {
  name: "dog",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    46
  ]
};
var DOG_WAIT_ANIMATION = {
  name: "dog_wait",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 20,
  frames: [
    46,
    47
  ]
};
var DOG_JUMP_ANIMATION = {
  name: "dog_jump",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 2,
  frames: [
    47,
    48,
    49,
    49,
    50
  ],
  airFrames: [48, 49]
};

// src/content/animations/house.ts
var HOUSE_ANIMATION = {
  name: "house",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    27,
    28,
    29
  ],
  mul: 20
};
var CABANA_ANIMATION = {
  name: "cabana",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    61
  ]
};
var HOUSE_EXPAND_ANIMATION = {
  name: "house_expand",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    120
  ]
};
var VILLAGE_ANIMATION = {
  name: "village",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    121,
    122,
    123
  ],
  mul: 20
};

// src/content/animations/sheep.ts
var SHEEP_ANIMATION = {
  name: "sheep",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    6
  ]
};
var SHEEP_WAIT_ANIMATION = {
  name: "sheep_wait",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 20,
  frames: [
    6,
    7
  ]
};
var SHEEP_JUMP_ANIMATION = {
  name: "sheep_jump",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 2,
  frames: [
    6,
    7,
    8,
    8
  ],
  airFrames: [8]
};

// src/content/animations/squirrel.ts
var SQUIRREL_ANIMATION = {
  name: "squirrel",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    98
  ]
};
var SQUIRREL_WAIT_ANIMATION = {
  name: "squirrel_wait",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 20,
  frames: [
    98,
    99
  ]
};
var SQUIRREL_JUMP_ANIMATION = {
  name: "squirrel_jump",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 2,
  frames: [
    98,
    100,
    101,
    102
  ],
  airFrames: [100, 101, 102]
};
var SQUIRREL_ATTACK_ANIMATION = {
  name: "squirrel_attack",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 5,
  frames: [
    103,
    104
  ],
  once: true
};
var SQUIRREL_SLEEP_ANIMATION = {
  name: "squirrel_jump",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    101
  ]
};

// src/content/animations/turtle.ts
var TURTLE_ANIMATION = {
  name: "turtle",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    114
  ]
};
var TURTLE_WAIT_ANIMATION = {
  name: "turtle_wait",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 20,
  frames: [
    114,
    115
  ]
};
var TURTLE_JUMP_ANIMATION = {
  name: "turtle_jump",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 10,
  frames: [
    114,
    115
  ],
  airFrames: [114]
};
var TURTLE_SLEEP_ANIMATION = {
  name: "turtle_wait",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    127
  ]
};

// src/content/animations/beaver.ts
var BEAVER_ANIMATION = {
  name: "beaver",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    106
  ]
};
var BEAVER_WAIT_ANIMATION = {
  name: "beaver_wait",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 20,
  frames: [
    106,
    107
  ]
};
var BEAVER_JUMP_ANIMATION = {
  name: "beaver_jump",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 3,
  frames: [
    106,
    108,
    109,
    106
  ],
  airFrames: [108, 109]
};

// src/content/menu/house-menu-debug.ts
var HOUSE_MENU_DEBUG = [
  {
    name: "hobo",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    padding: [2, 2],
    frames: [94, 95],
    label: "spawn\nhobo",
    disabled: {},
    actions: [
      {
        deselect: true,
        create: {
          definition: "hobo",
          selfSelect: true
        }
      }
    ],
    debug: true
  },
  {
    name: "soldier",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    padding: [2, 2],
    frames: [65, 66, 65, 67],
    label: "spawn\nsoldier",
    disabled: {},
    actions: [
      {
        deselect: true,
        create: {
          definition: "soldier",
          selfSelect: true
        }
      }
    ],
    debug: true
  },
  {
    name: "squirrel",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    padding: [2, 2],
    frames: [98],
    label: "spawn\nsquirrel",
    hidden: {
      occupied: ["unit", "tile occupied\nby a unit"]
    },
    disabled: {
      cannotAct: [true, "wait\nnext turn"]
    },
    actions: [
      {
        deselect: true,
        create: {
          definition: "squirrel",
          selfSelect: true
        }
      }
    ],
    debug: true
  },
  {
    name: "beaver",
    ...BEAVER_ANIMATION,
    label: "spawn\nbeaver",
    hidden: {
      occupied: ["unit", "tile occupied\nby a unit"]
    },
    disabled: {
      cannotAct: [true, "wait\nnext turn"]
    },
    actions: [
      {
        deselect: true,
        create: {
          definition: "beaver",
          selfSelect: true
        }
      }
    ],
    debug: true
  }
];

// src/content/menu/house-menu.ts
var HOUSE_MENU = {
  name: "house",
  description: "Use settlements to grow your animal kingdom.",
  icon: HOUSE_ANIMATION,
  items: [
    {
      name: "sheep",
      imageSource: "./assets/tiles.png",
      ...SHEEP_ANIMATION,
      label: "spawn\nsheep",
      resourceCost: {
        wood: 10
      },
      hidden: {
        occupied: ["unit", "Tile occupied\nby a unit"]
      },
      disabled: {
        levelBelowEqual: [1, "Settlement\nlevel too low"],
        cannotAct: [true, "wait\nnext turn"]
      },
      actions: [
        {
          deselect: true,
          level: -1,
          create: {
            definition: "sheep",
            selfSelect: true
          }
        }
      ],
      researchNeeded: ["oviculture"]
    },
    {
      name: "cow",
      imageSource: "./assets/tiles.png",
      ...COW_ANIMATION,
      resourceCost: {
        wood: 5
      },
      label: "spawn\ncow",
      hidden: {
        occupied: ["unit", "Tile occupied\nby a unit"]
      },
      disabled: {
        unitLimit: ["cow", "Increase settlement level\nto spawn more"]
      },
      actions: [
        {
          deselect: true,
          create: {
            definition: "cow",
            selfSelect: true
          }
        }
      ],
      researchNeeded: ["bovine"]
    },
    {
      name: "dog",
      imageSource: "./assets/tiles.png",
      ...DOG_ANIMATION,
      label: "spawn\ndog",
      resourceCost: {
        wood: 10
      },
      hidden: {
        occupied: ["unit", "tile occupied\nby a unit"]
      },
      disabled: {
        cannotAct: [true, "wait\nnext turn"]
      },
      actions: [
        {
          deselect: true,
          create: {
            definition: "dog",
            selfSelect: true
          }
        }
      ],
      researchNeeded: ["canine"]
    },
    {
      name: "squirrel",
      imageSource: "./assets/tiles.png",
      ...SQUIRREL_ANIMATION,
      label: "spawn\nsquirrel",
      resourceCost: {
        wood: 10
      },
      hidden: {
        occupied: ["unit", "tile occupied\nby a unit"]
      },
      disabled: {
        cannotAct: [true, "wait\nnext turn"]
      },
      actions: [
        {
          deselect: true,
          create: {
            definition: "squirrel",
            selfSelect: true
          }
        }
      ],
      researchNeeded: ["squirrel"]
    },
    {
      name: "turtle",
      ...TURTLE_ANIMATION,
      label: "spawn\nturtle",
      resourceCost: {
        wood: 10
      },
      hidden: {
        occupied: ["unit", "tile occupied\nby a unit"]
      },
      disabled: {
        cannotAct: [true, "wait\nnext turn"]
      },
      actions: [
        {
          deselect: true,
          create: {
            definition: "turtle",
            selfSelect: true
          }
        }
      ],
      researchNeeded: ["tortoise"]
    },
    {
      name: "village",
      ...VILLAGE_ANIMATION,
      label: "upgrade to\nvillage",
      disabled: {
        levelBelowEqual: [5, "You need to level up\nyour settlement first"]
      },
      resourceCost: {
        wood: 60
      },
      researchNeeded: ["village"],
      actions: [
        {
          selfDestroy: true
        },
        {
          create: {
            definition: "village",
            selfSelect: true
          }
        }
      ]
    },
    ...HOUSE_MENU_DEBUG
  ]
};

// src/content/animations/goat.ts
var GOAT_ANIMATION = {
  name: "goat",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    128
  ]
};
var GOAT_WAIT_ANIMATION = {
  name: "goat_wait",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 20,
  frames: [
    128,
    129
  ]
};
var GOAT_JUMP_ANIMATION = {
  name: "goat_jump",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 2,
  frames: [
    128,
    130,
    131,
    132
  ],
  airFrames: [130, 131, 132]
};
var GOAT_SLEEP_ANIMATION = {
  name: "goat_sleep",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    129
  ]
};

// src/content/menu/sheep-menu.ts
var SHEEP_MENU = {
  name: "sheep",
  description: "The sheep is your settler.\nUse it to build settlements.",
  icon: {
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    padding: [2, 2],
    frames: [6, 7]
  },
  items: [
    {
      name: "build",
      imageSource: "./assets/tiles.png",
      spriteSize: [64, 64],
      padding: [2, 2],
      frames: [27, 28, 29],
      label: "build\nsettlement",
      disabled: {
        proximity: ["house", "Too close to\nanother house"]
      },
      actions: [
        {
          deselect: true,
          create: {
            definition: "house",
            selfSelect: true
          }
        },
        {
          selfDestroy: true
        }
      ]
    },
    {
      name: "goat",
      ...GOAT_ANIMATION,
      label: "evolve into\ngoat",
      researchNeeded: ["goat"],
      resourceCost: {
        gold: 10
      },
      actions: [
        {
          deselect: true,
          create: {
            definition: "goat",
            selfSelect: true
          }
        },
        {
          selfDestroy: true
        }
      ]
    }
  ]
};

// src/content/research/beaver.ts
var BEAVER_RESEARCH = {
  name: "beaver",
  description: "Beavers can build dams to turn rivers into lakes.",
  icon: BEAVER_ANIMATION,
  waitIcon: BEAVER_WAIT_ANIMATION,
  dependency: ["squirrel"],
  cost: 30,
  recommended: 5
};

// src/content/research/bovine.ts
var BOVINE_RESEARCH = {
  name: "bovine",
  description: "Cows are your workers.\nUse them to harvest resources.",
  icon: COW_ANIMATION,
  waitIcon: COW_WAIT_ANIMATION,
  dependency: [],
  cost: 10,
  recommended: 1
};

// src/content/research/canine.ts
var CANINE_RESEARCH = {
  name: "canine",
  description: "Dogs are your scouts.\nUse them to explore the world.",
  icon: DOG_ANIMATION,
  waitIcon: DOG_WAIT_ANIMATION,
  dependency: [],
  cost: 10,
  recommended: 2
};

// src/content/research/goat.ts
var GOAT_RESEARCH = {
  name: "goat",
  description: "Goats can climb mountains.",
  icon: GOAT_ANIMATION,
  dependency: ["oviculture"],
  cost: 20,
  recommended: 5,
  forceInDebug: true
};

// src/content/research/squirrel.ts
var SQUIRREL_RESEARCH = {
  name: "nutology",
  description: "Squirrels can climb trees and throw nuts.",
  icon: SQUIRREL_ANIMATION,
  waitIcon: SQUIRREL_WAIT_ANIMATION,
  dependency: [],
  cost: 20,
  recommended: 4
};

// src/content/research/tortoise.ts
var TORTOISE_RESEARCH = {
  name: "tortoise",
  description: "Turtles can carry others on water, and have high defense.",
  icon: TURTLE_ANIMATION,
  waitIcon: TURTLE_WAIT_ANIMATION,
  dependency: [],
  cost: 20,
  recommended: 5
};

// src/content/research/wolves.ts
var WOLVES_RESEARCH = {
  name: "wolves",
  description: "Wolves are ferocious fighters.",
  icon: {
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    padding: [2, 2],
    frames: [46]
  },
  dependency: ["canine"],
  cost: 40,
  recommended: 7
};

// src/content/resources/brain.ts
var BRAIN_RESOURCE = {
  icon: {
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    padding: [2, 2],
    frames: [58]
  },
  global: true
};

// src/content/resources/gold.ts
var GOLD_RESOURCE = {
  icon: {
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    padding: [2, 2],
    frames: [59]
  },
  global: true
};

// src/content/resources/trade.ts
var TRADE_RESOURCE = {
  icon: {
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    padding: [2, 2],
    frames: [60]
  },
  global: true,
  hidden: true
};

// src/content/resources/wheat.ts
var WHEAT_RESOURCE = {
  icon: {
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    padding: [2, 2],
    frames: [56]
  },
  forGrowth: true
};

// src/content/resources/wood.ts
var WOOD_RESOURCE = {
  icon: {
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    padding: [2, 2],
    frames: [57]
  }
};

// src/content/animations/indicators.ts
var TRIANGLE_ANIMATION = {
  name: "triangle",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 2,
  frames: [
    0,
    1,
    2,
    3
  ]
};
var HOVER_ANIMATION = {
  name: "hover",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    20
  ]
};
var INDIC_ANIMATION = {
  name: "indic",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 3,
  frames: [
    9,
    9,
    10,
    11,
    12,
    11,
    10
  ]
};
var BLUE_ANIMATION = {
  name: "blue",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    13
  ]
};
var BLUE_SELECTED_ANIMATION = {
  name: "blue_selected",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    23,
    23,
    23,
    23,
    24,
    24,
    24,
    23,
    23,
    23,
    23,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22
  ]
};
var WAIT_ICON = {
  name: "wait",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    110
  ]
};
var WAVE_ICON = {
  name: "wave",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    111
  ]
};

// src/content/animations/terrain.ts
var GRASSLAND_ANIMATION = {
  name: "grassland",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    14
  ]
};
var PLAIN_ANIMATION = {
  name: "plain",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    30
  ]
};
var GRASS_ANIMATION = {
  name: "grass",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    15
  ]
};
var TREE_ANIMATION = {
  name: "tree",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    16
  ]
};
var TREE_LEAF_ANIMATION = {
  name: "tree_leaf",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    17
  ]
};
var MOUNTAIN_ANIMATION = {
  name: "mountain",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    25
  ]
};
var LAKE_ANIMATION = {
  name: "lake",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    33
  ]
};
var WAVE_ANIMATION = {
  name: "wave",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    34
  ]
};
var RIVER_ANIMATION = {
  name: "river",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    32
  ]
};

// src/content/animations/cloud.ts
var CLOUD_ANIMATION = {
  name: "cloud",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    18
  ]
};

// src/content/animations/shadow.ts
var SHADOW_ANIMATION = {
  name: "shadow",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    19
  ]
};

// src/content/animations/digits.ts
var DIGITS_ANIMATION = new Array(10).fill(36).map((base, i) => ({
  name: `num_${i}`,
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    base + i
  ]
}));

// src/content/animations/resources.ts
var WHEAT_ANIMATION = {
  name: "wheat",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    56
  ]
};
var WOOD_ANIMATION = {
  name: "wood",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    57
  ]
};
var BRAIN_ANIMATION = {
  name: "brain",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    58
  ]
};
var GOLD_ANIMATION = {
  name: "gold",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    59
  ]
};
var TRADE_ANIMATION = {
  name: "trade",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    60
  ]
};

// src/content/elems/cursor.ts
var CURSOR = {
  name: "cursor",
  type: "cursor",
  gameObject: {
    pos: [0, 0],
    size: [2, 2]
  },
  animation: {
    name: "triangle"
  },
  mouseFollower: {
    snap: 1
  },
  dynamic: true
};

// src/content/elems/cloud.ts
var CLOUD = {
  name: "cloud",
  type: "cloud",
  owner: 0,
  gameObject: {
    pos: [0, 0],
    size: [2, 2]
  },
  group: {
    grid: [SIZE + 1, SIZE + 1]
  },
  animation: {
    name: "cloud"
  },
  spread: {
    animation: "cloud",
    count: [4, 5],
    color: "#ffffffaa",
    size: 1.2,
    moving: 0.1
  }
};

// src/content/elems/grass.ts
var GRASS = {
  name: "grass",
  type: "tile",
  resourcesProduced: {
    wheat: 2
  },
  group: {
    grid: [SIZE + 1, SIZE + 1]
  },
  gameObject: {
    pos: [0, 0],
    size: [2, 2]
  },
  animation: {
    name: "grassland"
  },
  spread: {
    animation: "grass",
    count: [3, 7]
  }
};

// src/content/elems/plain.ts
var PLAIN = {
  name: "plain",
  type: "tile_overlay",
  resourcesProduced: {
    wood: 1,
    wheat: -1
  },
  group: {
    grid: [SIZE + 1, SIZE + 1],
    chance: 0.9
  },
  gameObject: {
    pos: [0, 0],
    size: [2, 2]
  },
  animation: {
    name: "plain"
  },
  spread: {
    animation: "grass",
    count: [3, 7]
  }
};

// src/content/elems/lake.ts
var LAKE = {
  group: {
    grid: [SIZE + 1, SIZE + 1],
    chance: 0.1
  },
  name: "lake",
  type: "tile_overlay",
  resourcesProduced: {
    wheat: -1,
    trade: 2
  },
  gameObject: {
    size: [2, 2]
  },
  animation: {
    name: "lake"
  },
  spread: {
    animation: "wave",
    count: [3, 7]
  },
  branchOut: {
    count: [3, 5],
    chance: 0.3,
    element: {
      definition: "river"
    }
  },
  water: true,
  copy: true
};

// src/content/elems/tree.ts
var TREE = {
  definition: "tree",
  group: {
    grid: [SIZE + 1, SIZE + 1],
    chance: 0.5,
    farFromCenter: 4
  }
};

// src/content/elems/mountain.ts
var MOUNTAIN = {
  name: "mountain",
  type: "decor",
  resourcesProduced: {
    wheat: -2
  },
  group: {
    grid: [SIZE + 1, SIZE + 1],
    chance: 0.3
  },
  condition: {
    tile: "plain"
  },
  gameObject: {
    pos: [0, 0],
    size: [2, 2]
  },
  animation: {
    name: "mountain"
  },
  spread: {
    animation: "mountain",
    count: [8, 10],
    radius: 0.3,
    behind: true
  }
};

// src/content/definitions/hobo.ts
var HOBO_DEFINITION = {
  name: "hobo",
  type: "unit",
  hitpoints: 10,
  maxHitPoints: 10,
  gameObject: {
    offset: [0, 0.2],
    size: [1.2, 1.2],
    speed: 0.08
  },
  animation: {
    name: "hobo"
  },
  onHover: {
    hideCursor: true,
    indic: {
      animation: "hover"
    }
  },
  selected: {
    animation: "hobo_wait",
    indic: {
      animation: "indic"
    },
    moveIndic: {
      animation: "blue",
      selectedAnimation: "blue_selected"
    }
  },
  move: {
    animation: "hobo_jump",
    distance: 1
  },
  shadow: {
    animation: "shadow"
  },
  dynamic: true,
  turn: {
    moves: 1,
    attacks: 1
  },
  attack: {
    damage: 2,
    defense: 2
  }
};

// src/content/elems/sheep.ts
var SHEEP = {
  definition: "sheep",
  owner: 1,
  disableQuickActions: true
};

// src/content/elems/cabana.ts
var CABANA = {
  name: "cabana",
  group: {
    grid: [SIZE + 1, SIZE + 1],
    chance: 0.1,
    farFromCenter: 4
  },
  definition: "cabana"
};

// src/content/animations/hobo.ts
var HOBO_ANIMATION = {
  name: "hobo",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    94
  ]
};
var HOBO_WAIT_ANIMATION = {
  name: "hobo_wait",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 10,
  frames: [
    94,
    95
  ]
};
var HOBO_JUMP_ANIMATION = {
  name: "hobo_jump",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  mul: 2,
  frames: [
    94,
    96,
    94,
    97
  ]
};

// src/content/definitions/squirrel.ts
var SQUIRREL_DEFINITION = {
  name: "squirrel",
  type: "unit",
  hitpoints: 10,
  maxHitPoints: 10,
  gameObject: {
    size: [1.8, 1.8],
    speed: 0.08
  },
  animation: {
    name: "squirrel"
  },
  onHover: {
    hideCursor: true,
    indic: {
      animation: "hover"
    }
  },
  selected: {
    animation: "squirrel_wait",
    indic: {
      animation: "indic"
    },
    moveIndic: {
      animation: "blue",
      selectedAnimation: "blue_selected"
    }
  },
  move: {
    animation: "squirrel_jump",
    disabled: {
      harvesting: true
    }
  },
  shadow: {
    animation: "shadow"
  },
  clearCloud: true,
  dynamic: true,
  turn: {
    moves: 1,
    attacks: 1
  },
  attack: {
    animation: "squirrel_attack",
    range: 2,
    damage: 2,
    defense: 1,
    attackAfterMove: true,
    projectile: "nut"
  },
  worker: true,
  canCrossTerrains: ["tree"],
  advise: {
    name: "squirrel",
    message: "Squirrel can throw nuts and foes, and climb on trees.\nYou can also find some buttons on the bottom left for additional actions.\nHover over them to see what they do."
  }
};

// src/content/elems/test-units.ts
var TEST_UNITS = [];

// src/content/animations/soldier.ts
var SOLDIER_ANIMATION = {
  soldier_blue_center_down_still: {
    name: "soldier_blue_center_down_still",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    frames: [
      62
    ]
  },
  soldier_red_center_down_still: {
    name: "soldier_red_center_down_still",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    frames: [
      65
    ]
  },
  soldier_blue_center_down_walk: {
    name: "soldier_blue_center_down_walk",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    mul: 5,
    frames: [
      62,
      63,
      64,
      63
    ]
  },
  soldier_red_center_down_walk: {
    name: "soldier_red_center_down_walk",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    mul: 5,
    frames: [
      65,
      66,
      67,
      66
    ]
  },
  soldier_blue_center_up_still: {
    name: "soldier_blue_center_up_still",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    frames: [
      68
    ]
  },
  soldier_red_center_up_still: {
    name: "soldier_red_center_up_still",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    frames: [
      71
    ]
  },
  soldier_blue_center_up_walk: {
    name: "soldier_blue_center_up_walk",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    mul: 5,
    frames: [
      68,
      69,
      70,
      69
    ]
  },
  soldier_red_center_up_walk: {
    name: "soldier_red_center_up_walk",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    mul: 5,
    frames: [
      71,
      72,
      73,
      72
    ]
  },
  soldier_blue_right_down_still: {
    name: "soldier_blue_right_down_still",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    frames: [
      74
    ]
  },
  soldier_red_right_down_still: {
    name: "soldier_red_right_down_still",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    frames: [
      77
    ]
  },
  soldier_blue_right_down_walk: {
    name: "soldier_blue_right_down_walk",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    mul: 5,
    frames: [
      74,
      75,
      76,
      75
    ]
  },
  soldier_red_right_down_walk: {
    name: "soldier_red_right_down_walk",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    mul: 5,
    frames: [
      77,
      78,
      79,
      78
    ]
  },
  soldier_blue_right_up_still: {
    name: "soldier_blue_right_up_still",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    frames: [
      80
    ]
  },
  soldier_red_right_up_still: {
    name: "soldier_red_right_up_still",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    frames: [
      83
    ]
  },
  soldier_blue_right_up_walk: {
    name: "soldier_blue_right_up_walk",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    mul: 5,
    frames: [
      80,
      81,
      82,
      81
    ]
  },
  soldier_red_right_up_walk: {
    name: "soldier_red_right_up_walk",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    mul: 5,
    frames: [
      83,
      84,
      85,
      84
    ]
  },
  soldier_blue_right_center_still: {
    name: "soldier_blue_right_center_still",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    frames: [
      86
    ]
  },
  soldier_red_right_center_still: {
    name: "soldier_red_right_center_still",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    frames: [
      90
    ]
  },
  soldier_blue_right_center_walk: {
    name: "soldier_blue_right_center_walk",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    mul: 5,
    frames: [
      86,
      87,
      88,
      89
    ]
  },
  soldier_red_right_center_walk: {
    name: "soldier_red_right_center_walk",
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    mul: 5,
    frames: [
      90,
      91,
      92,
      93
    ]
  }
};

// src/content/definitions/soldier.ts
var SOLDIER_DEFINITION = {
  name: "soldier",
  type: "unit",
  hitpoints: 15,
  maxHitPoints: 15,
  gameObject: {
    offset: [0, 0.2],
    size: [1.2, 1.2],
    speed: 0.08
  },
  animation: {
    name: "soldier_blue_center_down_still"
  },
  onHover: {
    hideCursor: true,
    indic: {
      animation: "hover"
    }
  },
  selected: {
    animation: "soldier_blue_center_down_walk",
    indic: {
      animation: "indic"
    },
    moveIndic: {
      animation: "blue",
      selectedAnimation: "blue_selected"
    }
  },
  move: {
    animation: "soldier_blue_center_down_walk",
    distance: 1
  },
  shadow: {
    animation: "shadow"
  },
  dynamic: true,
  turn: {
    moves: 1,
    attacks: 1
  },
  attack: {
    damage: 2,
    defense: 2
  }
};

// src/content/animations/nut.ts
var NUT_ANIMATION = {
  name: "nut",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    105
  ]
};

// src/content/research/oviculture.ts
var OVICULTURE_RESEARCH = {
  name: "oviculture",
  description: "You can spawn more sheeps, which build settlements.",
  icon: SHEEP_ANIMATION,
  waitIcon: SHEEP_WAIT_ANIMATION,
  dependency: [],
  cost: 10,
  recommended: 3
};

// src/content/definitions/beaver.ts
var BEAVER_DEFINITION = {
  name: "beaver",
  type: "unit",
  hitpoints: 10,
  maxHitPoints: 10,
  gameObject: {
    size: [1.5, 1.5],
    speed: 0.08
  },
  animation: {
    name: "beaver"
  },
  onHover: {
    hideCursor: true,
    indic: {
      animation: "hover"
    }
  },
  selected: {
    animation: "beaver_wait",
    indic: {
      animation: "indic"
    },
    moveIndic: {
      animation: "blue",
      selectedAnimation: "blue_selected"
    }
  },
  move: {
    animation: "beaver_jump"
  },
  shadow: {
    animation: "shadow"
  },
  clearCloud: true,
  dynamic: true,
  turn: {
    moves: 1,
    attacks: 1
  },
  attack: {
    animation: "beaver_attack",
    damage: 1,
    defense: 2
  },
  canCrossTerrains: ["tree", "lake"],
  advise: {
    name: "beaver",
    message: "Beavers can cut down trees and turn rivers into lakes."
  }
};

// src/content/menu/squirrel-menu.ts
var SQUIRREL_MENU = {
  name: "squirrel",
  description: "Squirrels can climb on trees to harvest, and throw nuts.",
  icon: SQUIRREL_ANIMATION,
  items: [
    {
      name: "harvest",
      ...SQUIRREL_SLEEP_ANIMATION,
      label: "harvest",
      hidden: {
        occupied: ["house", "No harvest on house"],
        harvesting: true
      },
      disabled: {
        proximity: ["foe", "Nearby foes,\ntoo dangerous."]
      },
      actions: [
        {
          deselect: true
        },
        {
          harvest: true
        },
        {
          clearMoves: true
        }
      ]
    },
    {
      name: "stopHarvest",
      ...SQUIRREL_ANIMATION,
      label: "stop harvest",
      hidden: {
        notHarvesting: true
      },
      actions: [
        {
          deselect: true
        },
        {
          stopHarvest: true
        }
      ]
    },
    {
      name: "beaver",
      ...BEAVER_ANIMATION,
      label: "evolve into\nbeaver",
      researchNeeded: ["beaver"],
      resourceCost: {
        gold: 10
      },
      actions: [
        {
          deselect: true,
          create: {
            definition: "beaver",
            selfSelect: true
          }
        },
        {
          selfDestroy: true
        }
      ]
    }
  ]
};

// src/content/definitions/bull.ts
var BULL_DEFINITION = {
  name: "bull",
  type: "unit",
  hitpoints: 15,
  maxHitPoints: 15,
  gameObject: {
    size: [1.8, 1.8],
    speed: 0.08
  },
  animation: {
    name: "bull"
  },
  onHover: {
    hideCursor: true,
    indic: {
      animation: "hover"
    }
  },
  selected: {
    animation: "bull_wait",
    indic: {
      animation: "indic"
    },
    moveIndic: {
      animation: "blue",
      selectedAnimation: "blue_selected"
    }
  },
  move: {
    animation: "bull_jump",
    distance: 2
  },
  shadow: {
    animation: "shadow"
  },
  clearCloud: true,
  dynamic: true,
  turn: {
    moves: 1,
    attacks: 1
  },
  attack: {
    damage: 3.5,
    defense: 1,
    attackAfterMove: true,
    attackAfterAttack: true
  }
};

// src/content/research/taurology.ts
var TAUROLOGY_RESEARCH = {
  name: "taurology",
  description: "Bulls are strong fighters.",
  icon: BULL_ANIMATION,
  waitIcon: BULL_WAIT_ANIMATION,
  dependency: ["bovine"],
  cost: 40,
  recommended: 7
};

// src/content/menu/beaver-menu.ts
var BEAVER_MENU = {
  name: "beaver",
  description: "Beavers can build dam, turning rivers into lakes.\nThey can also cut down trees.",
  icon: {
    imageSource: "./assets/tiles.png",
    spriteSize: [64, 64],
    padding: [2, 2],
    frames: [51]
  },
  items: [
    {
      name: "lake",
      ...LAKE_ANIMATION,
      label: "make lake",
      hidden: {
        notOnTile: ["river", "Must be\non a river"],
        onTile: ["lake", "Already a lake"]
      },
      actions: [
        {
          deselect: true
        },
        {
          create: {
            definition: "lake"
          }
        },
        {
          clearMoves: true
        }
      ]
    },
    {
      name: "river",
      ...RIVER_ANIMATION,
      label: "produce a river",
      hidden: {
        onTile: ["river", "Already on a river"],
        nonProximity: ["lake", "Must be\nnext to a lake"]
      },
      actions: [
        {
          deselect: true
        },
        {
          create: {
            definition: "river"
          }
        },
        {
          clearMoves: true
        }
      ]
    },
    {
      name: "tree",
      ...TREE_ANIMATION,
      label: "cut tree",
      hidden: {
        notOnTile: ["tree", "Must be\non a tree"]
      },
      actions: [
        {
          deselect: true
        },
        {
          destroy: "tree"
        },
        {
          clearMoves: true
        }
      ]
    }
  ]
};

// src/content/definitions/tree.ts
var TREE_DEFINITION = {
  name: "tree",
  type: "decor",
  resourcesProduced: {
    wood: 1
  },
  condition: {
    tile: "plain",
    noTile: "lake"
  },
  gameObject: {
    size: [2, 2]
  },
  animation: {
    name: "tree"
  },
  spread: {
    animation: "tree_leaf",
    count: [50, 100],
    radius: 0.25
  }
};

// src/content/definitions/turtle.ts
var TURTLE_DEFINITION = {
  name: "turtle",
  type: "unit",
  hitpoints: 10,
  maxHitPoints: 10,
  gameObject: {
    size: [1.8, 1.8],
    speed: 0.03
  },
  animation: {
    name: "turtle"
  },
  worker: true,
  onHover: {
    hideCursor: true,
    indic: {
      animation: "hover"
    }
  },
  selected: {
    animation: "turtle_wait",
    indic: {
      animation: "indic"
    },
    moveIndic: {
      animation: "blue",
      selectedAnimation: "blue_selected"
    }
  },
  move: {
    animation: "turtle_jump",
    disabled: {
      harvesting: true
    }
  },
  shadow: {
    animation: "shadow"
  },
  clearCloud: true,
  dynamic: true,
  turn: {
    moves: 1,
    attacks: 1
  },
  attack: {
    damage: 1,
    defense: 4
  },
  canCrossTerrains: ["lake"]
};

// src/content/definitions/fruit.ts
var FRUIT_DEFINITION = {
  name: "fruit",
  type: "goodies",
  resourcesProduced: {
    wheat: 2
  },
  condition: {
    noTile: ["lake", "mountain"]
  },
  gameObject: {
    size: [1, 1]
  },
  animation: {
    name: "fruit"
  }
};

// src/content/animations/goodies.ts
var FRUIT_ANIMATION = {
  name: "fruit",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    116
  ]
};
var POTGOLD_ANIMATION = {
  name: "potgold",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    117
  ]
};
var CORAL_ANIMATION = {
  name: "coral",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    118
  ]
};

// src/content/elems/fruit.ts
var FRUIT = {
  definition: "fruit",
  group: {
    grid: [SIZE + 1, SIZE + 1],
    chance: 0.03,
    farFromCenter: 1
  }
};

// src/content/definitions/potgold.ts
var POTGOLD_DEFINITION = {
  name: "potgold",
  type: "goodies",
  resourcesProduced: {
    gold: 5
  },
  condition: {
    tile: "mountain"
  },
  gameObject: {
    size: [1, 1]
  },
  animation: {
    name: "potgold"
  }
};

// src/content/definitions/coral.ts
var CORAL_DEFINITION = {
  name: "coral",
  type: "goodies",
  resourcesProduced: {
    wheat: 2,
    brain: 2
  },
  condition: {
    tile: "lake"
  },
  gameObject: {
    size: [1, 1]
  },
  animation: {
    name: "coral"
  }
};

// src/content/elems/coral.ts
var CORAL = {
  definition: "coral",
  group: {
    grid: [SIZE + 1, SIZE + 1],
    chance: 0.1
  }
};

// src/content/elems/potgold.ts
var POTGOLD = {
  definition: "potgold",
  group: {
    grid: [SIZE + 1, SIZE + 1],
    chance: 0.1
  }
};

// src/content/animations/globe.ts
var GLOBE_ANIMATION = {
  name: "globe",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    119
  ]
};

// src/content/research/exploration.ts
var EXPLORATION = {
  name: "exploration",
  description: "Exploration lets you view the entire map.",
  icon: GLOBE_ANIMATION,
  dependency: ["village"],
  cost: 100,
  recommended: 10,
  action: {
    clearFogOfWar: true
  }
};

// src/content/research/productivity.ts
var PRODUCTIVITY_RESEARCH = {
  name: "productivity",
  description: "Each settlement will produces one unit of production.",
  icon: WOOD_ANIMATION,
  dependency: [],
  cost: 5,
  recommended: 0
};

// src/content/research/expansion.ts
var EXPANSION_RESEARCH = {
  name: "expansion",
  description: "Settlements have a larger area for harvesting resources.",
  icon: HOUSE_EXPAND_ANIMATION,
  dependency: ["oviculture"],
  cost: 20,
  recommended: 5,
  action: {
    updateHouseCloud: true
  }
};

// src/content/definitions/village.ts
var VILLAGE_DEFINITION = {
  name: "village",
  type: "house",
  level: 7,
  gameObject: {
    offset: [0, 0.7],
    size: [2, 2]
  },
  animation: {
    name: "village"
  },
  onHover: {
    hideCursor: true,
    indic: {
      animation: "hover"
    }
  },
  selected: {
    animation: "village",
    indic: {
      animation: "indic"
    }
  },
  dynamic: true,
  settler: true,
  harvesting: true,
  building: true,
  turn: {
    moves: 0,
    attacks: 0,
    actions: 1
  },
  resourcesProduced: {
    trade: 2
  },
  rewards: [],
  advise: {
    name: "house",
    message: "Villages hold more population and can produce more resources."
  },
  clearCloud: true
};

// src/content/research/village.ts
var VILLAGE_RESEARCH = {
  name: "village",
  description: "Your settlements can turn into a village, growing beyond level 6.",
  icon: VILLAGE_ANIMATION,
  dependency: ["oviculture"],
  cost: 30,
  recommended: 5,
  forceInDebug: true
};

// src/content/animations/spaceship.ts
var SPACESHIP_ANIMATION = {
  name: "spaceship",
  imageSource: "./assets/tiles.png",
  spriteSize: [64, 64],
  frames: [
    124,
    125,
    126
  ]
};

// src/content/menu/village-menu.ts
var VILLAGE_MENU = {
  name: "village",
  description: "Villages hold a larger population.",
  icon: VILLAGE_ANIMATION,
  items: [
    {
      name: "sheep",
      imageSource: "./assets/tiles.png",
      ...SHEEP_ANIMATION,
      label: "spawn\nsheep",
      resourceCost: {
        wood: 10
      },
      hidden: {
        occupied: ["unit", "Tile occupied\nby a unit"]
      },
      disabled: {
        levelBelowEqual: [1, "Settlement\nlevel too low"],
        cannotAct: [true, "wait\nnext turn"]
      },
      actions: [
        {
          deselect: true,
          level: -1,
          create: {
            definition: "sheep",
            selfSelect: true
          }
        }
      ],
      researchNeeded: ["oviculture"]
    },
    {
      name: "cow",
      imageSource: "./assets/tiles.png",
      ...COW_ANIMATION,
      resourceCost: {
        wood: 5
      },
      label: "spawn\ncow",
      hidden: {
        occupied: ["unit", "Tile occupied\nby a unit"]
      },
      disabled: {
        unitLimit: ["cow", "Increase settlement level\nto spawn more"]
      },
      actions: [
        {
          deselect: true,
          create: {
            definition: "cow",
            selfSelect: true
          }
        }
      ],
      researchNeeded: ["bovine"]
    },
    {
      name: "dog",
      imageSource: "./assets/tiles.png",
      ...DOG_ANIMATION,
      label: "spawn\ndog",
      resourceCost: {
        wood: 10
      },
      hidden: {
        occupied: ["unit", "tile occupied\nby a unit"]
      },
      disabled: {
        cannotAct: [true, "wait\nnext turn"]
      },
      actions: [
        {
          deselect: true,
          create: {
            definition: "dog",
            selfSelect: true
          }
        }
      ],
      researchNeeded: ["canine"]
    },
    {
      name: "squirrel",
      imageSource: "./assets/tiles.png",
      ...SQUIRREL_ANIMATION,
      label: "spawn\nsquirrel",
      resourceCost: {
        wood: 10
      },
      hidden: {
        occupied: ["unit", "tile occupied\nby a unit"]
      },
      disabled: {
        cannotAct: [true, "wait\nnext turn"]
      },
      actions: [
        {
          deselect: true,
          create: {
            definition: "squirrel",
            selfSelect: true
          }
        }
      ],
      researchNeeded: ["squirrel"]
    },
    {
      name: "turtle",
      ...TURTLE_ANIMATION,
      label: "spawn\nturtle",
      resourceCost: {
        wood: 10
      },
      hidden: {
        occupied: ["unit", "tile occupied\nby a unit"]
      },
      disabled: {
        cannotAct: [true, "wait\nnext turn"]
      },
      actions: [
        {
          deselect: true,
          create: {
            definition: "turtle",
            selfSelect: true
          }
        }
      ],
      researchNeeded: ["tortoise"]
    },
    {
      name: "spaceship",
      ...SPACESHIP_ANIMATION,
      label: "build\nspaceship",
      disabled: {
        levelBelowEqual: [15, "You need to level up\nyour village to level 16"]
      },
      resourceCost: {
        wood: 200,
        gold: 200
      },
      researchNeeded: ["spaceship"],
      actions: [
        {
          spaceship: true
        }
      ]
    }
  ]
};

// src/content/research/spaceship.ts
var SPACESHIP_RESEARCH = {
  name: "spaceship",
  description: "Build a spaceship to leave this planet.",
  icon: SPACESHIP_ANIMATION,
  dependency: ["exploration"],
  cost: 200,
  recommended: 20,
  forceInDebug: true
};

// src/content/menu/turtle-menu.ts
var TURTLE_MENU = {
  name: "turtle",
  description: "Turtle can swim in the lake.",
  icon: TURTLE_ANIMATION,
  items: [
    {
      name: "harvest",
      ...TURTLE_SLEEP_ANIMATION,
      label: "harvest",
      hidden: {
        occupied: ["house", "No harvest on house"],
        harvesting: true
      },
      disabled: {
        proximity: ["foe", "Nearby foes,\ntoo dangerous."]
      },
      actions: [
        {
          deselect: true
        },
        {
          harvest: true
        },
        {
          clearMoves: true
        }
      ]
    },
    {
      name: "stopHarvest",
      ...TURTLE_ANIMATION,
      label: "stop harvest",
      hidden: {
        notHarvesting: true
      },
      actions: [
        {
          deselect: true
        },
        {
          stopHarvest: true
        }
      ]
    }
  ]
};

// src/content/elems/barbarian.ts
var HOBO = {
  definition: "hobo",
  group: {
    grid: [SIZE + 1, SIZE + 1],
    chance: 0.05,
    farFromCenter: 7
  }
};

// src/content/definitions/goat.ts
var GOAT_DEFINITION = {
  name: "goat",
  type: "unit",
  hitpoints: 15,
  maxHitPoints: 15,
  gameObject: {
    size: [1.8, 1.8],
    speed: 0.06
  },
  animation: {
    name: "goat"
  },
  onHover: {
    hideCursor: true,
    indic: {
      animation: "hover"
    }
  },
  selected: {
    animation: "goat_wait",
    indic: {
      animation: "indic"
    },
    moveIndic: {
      animation: "blue",
      selectedAnimation: "blue_selected"
    }
  },
  clearCloud: true,
  move: {
    animation: "goat_jump",
    distance: 1,
    disabled: {
      harvesting: true
    }
  },
  harvest: {
    animation: "goat_sleep"
  },
  shadow: {
    animation: "shadow"
  },
  worker: true,
  turn: {
    moves: 1,
    attacks: 1,
    actions: 1
  },
  attack: {
    damage: 2,
    defense: 1
  },
  advise: {
    name: "goat",
    message: "Goats can climb on mountains."
  },
  canCrossTerrains: ["mountain"]
};

// src/content/world.ts
var worldData = {
  scale: 80,
  quickActions: [
    {
      name: "wait",
      icon: WAIT_ICON,
      description: "Leave the animal idle until it encounters a human."
    },
    {
      name: "abandon",
      icon: WAVE_ICON,
      description: "Release the animal into the wild."
    }
  ],
  turn: {
    player: 1,
    turn: 1
  },
  players: [
    {
      tax: 50,
      resources: {
        brain: 0,
        gold: 0
      }
    }
  ],
  layers: {
    tile: 0,
    tile_overlay: 1,
    road: 3,
    house: 4,
    unit: 4,
    decor: 4,
    goodies: 5,
    cloud: 6,
    cursor: 7
  },
  colayers: {
    house: 1,
    decor: 2,
    unit: 3
  },
  definitions: [
    HOBO_DEFINITION,
    SHEEP_DEFINITION,
    DOG_DEFINITION,
    COW_DEFINITION,
    RIVER_DEFINITION,
    HOUSE_DEFINITION,
    CABANA_DEFINITION,
    SQUIRREL_DEFINITION,
    SOLDIER_DEFINITION,
    BEAVER_DEFINITION,
    BULL_DEFINITION,
    TREE_DEFINITION,
    TURTLE_DEFINITION,
    FRUIT_DEFINITION,
    POTGOLD_DEFINITION,
    CORAL_DEFINITION,
    VILLAGE_DEFINITION,
    GOAT_DEFINITION
  ],
  animations: [
    TRIANGLE_ANIMATION,
    SHEEP_ANIMATION,
    SHEEP_WAIT_ANIMATION,
    SHEEP_JUMP_ANIMATION,
    HOVER_ANIMATION,
    INDIC_ANIMATION,
    BLUE_ANIMATION,
    BLUE_SELECTED_ANIMATION,
    GRASSLAND_ANIMATION,
    PLAIN_ANIMATION,
    GRASS_ANIMATION,
    TREE_ANIMATION,
    TREE_LEAF_ANIMATION,
    MOUNTAIN_ANIMATION,
    CLOUD_ANIMATION,
    SHADOW_ANIMATION,
    LAKE_ANIMATION,
    WAVE_ANIMATION,
    RIVER_ANIMATION,
    HOUSE_ANIMATION,
    CABANA_ANIMATION,
    ...DIGITS_ANIMATION,
    DOG_ANIMATION,
    DOG_WAIT_ANIMATION,
    DOG_JUMP_ANIMATION,
    COW_ANIMATION,
    COW_WAIT_ANIMATION,
    COW_JUMP_ANIMATION,
    COW_SLEEP_ANIMATION,
    WHEAT_ANIMATION,
    WOOD_ANIMATION,
    BRAIN_ANIMATION,
    GOLD_ANIMATION,
    TRADE_ANIMATION,
    HOBO_ANIMATION,
    HOBO_JUMP_ANIMATION,
    HOBO_WAIT_ANIMATION,
    SQUIRREL_ANIMATION,
    SQUIRREL_WAIT_ANIMATION,
    SQUIRREL_JUMP_ANIMATION,
    SQUIRREL_ATTACK_ANIMATION,
    ...Object.values(SOLDIER_ANIMATION),
    NUT_ANIMATION,
    BEAVER_ANIMATION,
    BEAVER_WAIT_ANIMATION,
    BEAVER_JUMP_ANIMATION,
    BULL_ANIMATION,
    BULL_WAIT_ANIMATION,
    BULL_JUMP_ANIMATION,
    TURTLE_ANIMATION,
    TURTLE_WAIT_ANIMATION,
    TURTLE_JUMP_ANIMATION,
    FRUIT_ANIMATION,
    POTGOLD_ANIMATION,
    CORAL_ANIMATION,
    HOUSE_EXPAND_ANIMATION,
    VILLAGE_ANIMATION,
    SPACESHIP_ANIMATION,
    GOAT_ANIMATION,
    GOAT_JUMP_ANIMATION,
    GOAT_WAIT_ANIMATION,
    GOAT_SLEEP_ANIMATION
  ],
  elems: [
    CURSOR,
    CLOUD,
    SHEEP,
    GRASS,
    PLAIN,
    LAKE,
    TREE,
    MOUNTAIN,
    CABANA,
    FRUIT,
    POTGOLD,
    CORAL,
    HOBO,
    ...TEST_UNITS
  ],
  menu: [
    SHEEP_MENU,
    HOUSE_MENU,
    COW_MENU,
    SQUIRREL_MENU,
    BEAVER_MENU,
    VILLAGE_MENU,
    TURTLE_MENU
  ],
  resources: {
    wheat: WHEAT_RESOURCE,
    wood: WOOD_RESOURCE,
    brain: BRAIN_RESOURCE,
    gold: GOLD_RESOURCE,
    trade: TRADE_RESOURCE
  },
  research: [
    CANINE_RESEARCH,
    WOLVES_RESEARCH,
    BOVINE_RESEARCH,
    SQUIRREL_RESEARCH,
    OVICULTURE_RESEARCH,
    TAUROLOGY_RESEARCH,
    BEAVER_RESEARCH,
    TORTOISE_RESEARCH,
    EXPLORATION,
    PRODUCTIVITY_RESEARCH,
    EXPANSION_RESEARCH,
    VILLAGE_RESEARCH,
    SPACESHIP_RESEARCH,
    GOAT_RESEARCH
  ]
};
window.worldData = worldData;

// src/index.ts
var gameInit = function() {
};
var gameUpdate = function() {
  manager2.refresh();
};
var postUpdate = function() {
};
var render = function() {
};
var renderPost = function() {
};
var manager2 = new Manager(worldData);
window.manager = manager2;
engineInit(gameInit, gameUpdate, postUpdate, render, renderPost, manager2.animation.imageSources);

//# debugId=5EA152C6C030389464756e2164756e21
